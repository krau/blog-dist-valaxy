[{"title":"ChatGPT简单使用体验|你的下一个Google，何必是搜索引擎","tags":["AI"],"categories":"小技术","author":"柯罗krau","excerpt":"\n最近openai整的[ChatGPT](https://chat.openai.com/chat)有点小火，看了官方和民间的一些截图之后，感觉这东西确实有点意思，所以就想办法注册了个号来体验体验。\n\n","link":"/posts/ChatGPT-simple-exp","content":"\n最近openai整的[ChatGPT](https://chat.openai.com/chat)有点小火，看了官方和民间的一些截图之后，感觉这东西确实有点意思，所以就想办法注册了个号来体验体验。\n\n<!-- more -->\n\n先说结论：ChatGPT像一面镜子，只要问题详尽，描述清楚，用词专业，那么它就能给你一个基本准确的答案，这比使用谷歌搜索要节省很多时间。但是有些问题它给出的答案还有待优化。\n\n下面是我提问的一些问题。\n\nLinux使用相关\n---\n\n切换个时区，完全正确，简简单单\n![](/photo/post-pics/ChatGPT-simple-exp/ChatGPT-simple-exp_2022-12-05-20-57-25.webp)\n\n装个docker，少说了个要加上docker的源之后才能用apt安装\n![](/photo/post-pics/ChatGPT-simple-exp/ChatGPT-simple-exp_2022-12-05-20-59-13.webp)\n\nnginx的使用，示例配置文件写的格式也对\n![](/photo/post-pics/ChatGPT-simple-exp/ChatGPT-simple-exp_2022-12-05-21-01-20.webp)\n\n![](/photo/post-pics/ChatGPT-simple-exp/ChatGPT-simple-exp_2022-12-05-21-03-33.webp)\n\n这个我感觉最逆天，它能针对一个具体的项目给出使用文档\n![](/photo/post-pics/ChatGPT-simple-exp/ChatGPT-simple-exp_2022-12-05-21-05-57.webp)\n\nPython编程相关\n---\n\n字符串匹配问题，~~我以为它会给我写一个ac算法~~，没想到直接用的for in，只能说又不是不能用吧\n![](/photo/post-pics/ChatGPT-simple-exp/ChatGPT-simple-exp_2022-12-05-21-15-11.webp)\n\n简单的json使用问题\n![](/photo/post-pics/ChatGPT-simple-exp/ChatGPT-simple-exp_2022-12-05-21-16-28.webp)\n\npython的日期和时间\n![](/photo/post-pics/ChatGPT-simple-exp/ChatGPT-simple-exp_2022-12-05-21-17-41.webp)\n\n来排个经典的解码问题错误吧\n![](/photo/post-pics/ChatGPT-simple-exp/ChatGPT-simple-exp_2022-12-05-21-19-37.webp)\n\n还要第三方包的导入问题\n![](/photo/post-pics/ChatGPT-simple-exp/ChatGPT-simple-exp_2022-12-05-21-24-13.webp)\n\n这个就有点厉害了，给出的答案基本是正确的，可以直接使用。如果使用Google解决这些问题，那么要花费一定的时间去翻看不同网站的回答，还不一定准确。\n\n其他\n---\n\n来问个我以前写过的文章（\n![](/photo/post-pics/ChatGPT-simple-exp/ChatGPT-simple-exp_2022-12-05-21-30-19.webp)\n有点厉害，但是不是我想要的结果，我是想把图片直接保存在本地的，所以我又追问它：\n![](/photo/post-pics/ChatGPT-simple-exp/ChatGPT-simple-exp_2022-12-05-21-33-17.webp)\n结果给了我一个最麻烦的办法，所以我继续追问：\n![](/photo/post-pics/ChatGPT-simple-exp/ChatGPT-simple-exp_2022-12-05-21-35-23.webp)\n似乎我想要的答案要出来了，但是它突然卡壳了，不知道怎么回事😅\n\n总结\n---\n\n就这样，总体感觉是，在某些场景它比Google是要好用很多的，但是要说取代谷歌，我觉得还有点距离。在简单而足够具体的问题上，使用chatGPT要比使用Google效率高的多，但是比较抽象的问题就不是了。\n"},{"title":"关于hexo每次上传github后都会显示404的解决方法","tags":["hexo"],"categories":["小技术"],"author":"柯罗krau","excerpt":"\n在博客目录的\\source中，新建一个名为CNAME的文本文件，用记事本打开并填入你的域名，保存退出，然后删除文件后缀名即可。此时再使用\n\n`hexo clean && hexo g -d`\n\n测试","link":"/posts/about-hexo404","content":"\n在博客目录的\\source中，新建一个名为CNAME的文本文件，用记事本打开并填入你的域名，保存退出，然后删除文件后缀名即可。此时再使用\n\n`hexo clean && hexo g -d`\n\n测试一下看看吧\n"},{"title":"使用ACME脚本申请并配置SSL证书","tags":["SSL"],"categories":"小技术","author":"柯罗krau","excerpt":"\n## 前言|为什么选择ACME方法\n\n要想通过TLS/https协议访问自己域名下的服务，就必须申请SSL证书。类似宝塔这种面板提供了简单快捷的方法一键申请，但终究不是良好的解决方案。一来宝塔过于臃肿，二来其需要手机实名验证。使用各大云服务商提供的【免费证书】则还需要登录网页、申请、导入证书，未免操作繁琐。更何况这些云服务商提供的ssl证书只能给你很少的自由选择性。\n\n而ACME则很好地解决了这些问题。\n","link":"/posts/acmessl","content":"\n## 前言|为什么选择ACME方法\n\n要想通过TLS/https协议访问自己域名下的服务，就必须申请SSL证书。类似宝塔这种面板提供了简单快捷的方法一键申请，但终究不是良好的解决方案。一来宝塔过于臃肿，二来其需要手机实名验证。使用各大云服务商提供的【免费证书】则还需要登录网页、申请、导入证书，未免操作繁琐。更何况这些云服务商提供的ssl证书只能给你很少的自由选择性。\n\n而ACME则很好地解决了这些问题。\n<!-- more -->\n系统环境：Debian\n\n## 准备工作与脚本安装\n\n在开始之前，首先将域名解析到服务器的ip上。\n\n### 安装\n\n首先安装socat，它是acme所需的组件\n\n```shell\napt update\napt install socat -y\n```\n\n然后安装acme脚本\n\n```shell\ncurl https://get.acme.sh | sh\n```\n\n脚本安装在用户目录下的`.acme.sh`（隐藏）文件夹内，使用 `. .bashrc` 让acme.sh命令生效\n\n接下来使用脚本申请证书\n\n## 证书申请\n\n首先注册CA账户，将下列命令中的邮箱改为自己的邮箱地址\n\n```shell\nacme.sh --register-account -m xxxx@xxxx.com\n```\n\n注册成功的输出结果如下\n\n![1](/photo/post-pics/acmessl/acmessl1.webp)_注册成功\n\n然后申请证书，接下来的方法有多种，根据自己情况选择可用的一种即可\n\n### 监听80端口申请证书\n\n如果服务器的80端口空闲，且能够访问，可以让acme临时监听80端口，完成验证。执行以下命令即可。将domain.com改为自己的域名\n\n```shell\nacme.sh --issue -d domain.com --standalone\n```\n\n### 通过Nginx服务申请\n\n如果服务器上已经安装了nginx，且网页能够正常打开，执行以下命令即可通过nginx验证并申请证书。\n\n```shell\nacme.sh --issue -d mydomain.com --nginx\n```\n\n---\n如果成功申请了证书，将会看到的输出结果是一长串自己的证书和证书文件存放路径。\n\n## 安装证书到指定路径\n\n生成的证书文件默认存放在与acme.sh脚本相同文件夹内，大多数情况下不应直接使用该路径下的证书文件，而使用以下命令安装证书到指定路径。\n\n```shell\nacme.sh --install-cert -d domain.com --key-file <path>privkey.pem --fullchain-file <path>fullchain.pem\n```\n\n其中`--key-file <path>privkey.pem`指定的为私钥文件，`--fullchain-file <path>fullchain.pem`为证书文件。\n\ndone\n\n## 善后工作\n\n在安装acme.sh脚本时，它自动为创建 cronjob, 每天 0:00 点自动检测所有的证书, 如果快过期了, 需要更新, 则会自动更新证书。\n但由于acme 协议和 letsencrypt CA 都在频繁的更新, 因此 acme.sh 也应当经常更新以保持同步。参考以下命令\n\n```shell\nacme.sh --upgrade --auto-upgrade  #开启acme的自动更新\nacme.sh --upgrade --auto-upgrade 0  #关闭自动更新\n```\n"},{"title":"为 valaxy 博客 yun 主题添加 artitalk 说说页面","tags":["博客"],"categories":["小技术"],"author":"柯罗krau","excerpt":"## Artitalk\n\n[Artitalk](https://artitalk.js.org/) 是一个基于 Leancloud 的简单说说 js，具体参见官方文档。\n\n我成功将它接入了我的博客，[","link":"/posts/add-artitalk-for-valaxy-yun","content":"## Artitalk\n\n[Artitalk](https://artitalk.js.org/) 是一个基于 Leancloud 的简单说说 js，具体参见官方文档。\n\n我成功将它接入了我的博客，[点这里看看](https://krau.top/about)。下面简单介绍一下接入方法。\n\n> 由于构建上的一些问题，我把它暂时移除了\n\n## 注册并配置 Leancloud\n\n这一步与官方文档完全相同，[点击查看](https://artitalk.js.org/doc.html#%F0%9F%8C%88-leancloud-%E7%9A%84%E7%9B%B8%E5%85%B3%E5%87%86%E5%A4%87)\n\n## 配置 valaxy\n\n在博客根目录下，新建 index.heml，写入以下内容\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0\">\n    <link rel=\"icon\" href=\"favicon.ico\">\n    <title><%= htmlWebpackPlugin.options.title %></title>\n  </head>\n  <body>\n    <noscript>\n      <strong>We're sorry but <%= htmlWebpackPlugin.options.title %> doesn't work properly without JavaScript enabled. Please enable it to continue.</strong>\n    </noscript>\n    <div id=\"app\"></div>\n      <script src=\"https://cdn.jsdelivr.net/npm/artitalk\"></script>\n  </body>\n</html>\n```\n\n然后在 /components/ 目录下，新建 Artitalk.vue ，写入以下内容\n\n```vue\n<template>\n  <div id=\"artitalk_main\" />\n</template>\n\n<script>\nexport default {\n  mounted() {\n    function addScript(url) {\n      var s = document.createElement(\"script\");\n      s.id = \"at\";\n      url.indexOf(\"appId\") == -1 ? (s.src = url) : (s.innerHTML = url);\n      document.head.appendChild(s);\n    }\n    addScript(`\n      new Artitalk({\n          appId: '你的appid',\n          appKey: '你的key',\n          shuoPla: '',\n          bgImg: 'https://cdn.jsdelivr.net/gh/drew233/cdn/20200409110727.webp',\n          atEmoji: {\n              huaji: 'https://cdn.jsdelivr.net/gh/moezx/cdn@3.1.9/img/Sakura/images/smilies/icon_huaji.gif',\n              baiyan: 'https://cdn.jsdelivr.net/gh/Artitalk/Artitalk-emoji/baiyan.png',\n              bishi: 'https://cdn.jsdelivr.net/gh/Artitalk/Artitalk-emoji/bishi.png',\n              bizui: 'https://cdn.jsdelivr.net/gh/Artitalk/Artitalk-emoji/bizui.png',\n              chan: 'https://cdn.jsdelivr.net/gh/Artitalk/Artitalk-emoji/chan.png'          \n          },\n      })\n    `);\n  },\n  destroyed() {\n    document\n      .querySelectorAll(\"#at\")\n      .forEach(element => element.parentNode.removeChild(element));\n    delete window.AV;\n  }\n};\n</script>\n```\n\n这样就可以啦。在你想要显示说说的页面(.md文件)里，写上`<Artitalk />` 就可以显示了。\n\n## 问题\n\n目前 Artitalk 只支持以 Leancloud 作为数据库，并且 cdn 用的还是 jsdeliver，速度感人。我提了 issue 希望能支持更多部署方式，不过看起来作者已经失踪有一段时间了...\n\n可惜我不会 js，只能等大佬实现啦。~~现在又不是不能用~~\n"},{"title":"动画电影 HELLO WORLD","tags":["ACG","动画"],"categories":"日常","author":"柯罗krau","excerpt":"\n![1](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200424173731.jpg)\n\n![2](https://cdn.jsde","link":"/posts/anime-helloworld","content":"\n![1](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200424173731.jpg)\n\n![2](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200424173903.jpg)\n\n![3](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200424173932.jpg)\n\n![4](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200424173940.jpg)\n\n![5](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200424173949.jpg)\n\n![6](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200424173958.jpg)\n\n![7](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200424174018.jpg)\n\n![8](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200424174027.jpg)\n\n![9](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200424174037.jpg)\n\n![10](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200424174045.jpg)\n\n![11](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200424174059.jpg)\n\n![12](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200424174108.jpg)\n\n![13](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200424174121.jpg)\n\n![14](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200424174135.jpg)\n\n![15](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200424174146.jpg)\n\n![16](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200424174226.jpg)\n\n![17](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200424174237.jpg)\n\n![18](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200424174246.jpg)\n\n![19](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200424174257.jpg)\n\n![20](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200424174306.jpg)\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200424174353.jpg)\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200424174403.jpg)\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200424174416.jpg)\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200424174423.jpg)\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200424174431.jpg)\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200424174448.jpg)\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200424174537.jpg)\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200424174547.jpg)\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200424174556.jpg)\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200424174606.jpg)\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200424174612.jpg)\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200424174622.jpg)\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200424174700.jpg)\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200424174631.jpg)\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200424174640.jpg)\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200424174649.jpg)\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200424174715.jpg)\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200424174734.jpg)\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200424174745.jpg)\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200424174758.jpg)\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200424174805.jpg)\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200424174814.jpg)\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200424174823.jpg)\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200424174836.jpg)\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200424174846.jpg)\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200424174853.jpg)\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200424174902.jpg)\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200424174914.jpg)\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200424174923.jpg)\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200424174943.jpg)\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200424174955.jpg)\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200424175004.jpg)\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200424175013.jpg)\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200424175023.jpg)\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200424175032.jpg)\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200424175045.jpg)\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200424175052.jpg)\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200424175151.jpg)\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200424175205.jpg)\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200424175300.jpg)\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200424175309.jpg)\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200424175330.jpg)\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200424175338.jpg)\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200424175347.jpg)\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200424175354.jpg)\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200424175401.jpg)\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200424175412.jpg)\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200424175422.jpg)\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200424175433.jpg)\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200424175443.jpg)\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200424175452.jpg)\n\n---\n\n## 短评\n\n这是一部以科幻和恋爱为题材的动画电影。故事起因是2027年的京都一名高中生直实面前，突然出现来自十年后的自己，并希望和他一起改变未来，拯救三个月后的恋人一行瑠璃。整体作画三渲二，极具个性。剧情反转离奇，出其不意而又合情合理。标题『HELLO WORLD』一语双关，预示故事整体世界观是数据构建的世界，又有向世界问好之意，与结尾“这一定是一个全新的世界”相照应。在嵌套或平行的世界中寻觅虚拟与真实，看似酷似『源代码』或『盗梦空间』，实际上却有极大创新，尤其是两个不同时间轴上的男主的设定更升华了感情。\n\n>\"不论世界如何崩坏，我想再见你一面－－\"\n\n已确定消息今年会引入国内\n"},{"title":"声之形","tags":["ACG","动画"],"categories":"日常","author":"柯罗krau","excerpt":"\n## The shape of voice\n\n","link":"/posts/anime-the-shape-of-voice","content":"\n## The shape of voice\n\n<!-- more -->\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200705222922.jpg)\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200705223001.jpg)\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200705223156.jpg)\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200705223337.jpg)\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200705223353.jpg)\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200705223650.jpg)\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200705223703.jpg)\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200705223715.jpg)\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200705223743.jpg)\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200705223824.jpg)\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200705223925.jpg)\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200705223940.jpg)\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200705223951.jpg)\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200705224001.jpg)\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200705224018.jpg)\n\n![](https://i.loli.net/2020/07/05/HkYW9sl87KESJfd.jpg)\n\n![](https://img.asnet.ga/i/2020/07/06/ddsx5z.jpg)\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200706080952.jpg)\n\n![](https://img.asnet.ga/i/2020/07/06/3q50y91.jpg)\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200706081209.jpg)\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200706081228.jpg)\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200706081241.jpg)\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200706081543.jpg)\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200706081559.jpg)\n\n![](https://pic.downk.cc/item/5f026fbf14195aa594b4d9fb.jpg)\n\n![](https://pic.downk.cc/item/5f026fed14195aa594b4ee00.jpg)\n\n![](https://pic.downk.cc/item/5f026fed14195aa594b4ee02.jpg)\n\n![](https://pic.downk.cc/item/5f026fed14195aa594b4ee04.jpg)\n\n![](https://pic.downk.cc/item/5f026fed14195aa594b4ee07.jpg)\n\n![](https://pic.downk.cc/item/5f026fed14195aa594b4ee0c.jpg)\n\n![](https://pic.downk.cc/item/5f02700814195aa594b4f8c1.jpg)\n![](https://pic.downk.cc/item/5f02700814195aa594b4f8c3.jpg)\n![](https://pic.downk.cc/item/5f02700814195aa594b4f8c8.jpg)\n![](https://pic.downk.cc/item/5f02700814195aa594b4f8cc.jpg)\n![](https://pic.downk.cc/item/5f02700814195aa594b4f8ce.jpg)\n![](https://pic.downk.cc/item/5f02701a14195aa594b50087.jpg)\n![](https://pic.downk.cc/item/5f02701a14195aa594b5008a.jpg)\n![](https://pic.downk.cc/item/5f02701a14195aa594b5008e.jpg)\n![](https://pic.downk.cc/item/5f02701a14195aa594b50092.jpg)\n![](https://pic.downk.cc/item/5f02701a14195aa594b50095.jpg)\n![](https://pic.downk.cc/item/5f02702b14195aa594b50795.jpg)\n![](https://pic.downk.cc/item/5f02702b14195aa594b50799.jpg)\n![](https://pic.downk.cc/item/5f02702b14195aa594b5079c.jpg)\n![](https://pic.downk.cc/item/5f02702b14195aa594b5079e.jpg)\n![](https://pic.downk.cc/item/5f02702b14195aa594b507a5.jpg)\n![](https://pic.downk.cc/item/5f02703914195aa594b50e0a.jpg)\n![](https://pic.downk.cc/item/5f02703914195aa594b50e0c.jpg)\n![](https://pic.downk.cc/item/5f02703914195aa594b50e0e.jpg)\n![](https://pic.downk.cc/item/5f02703914195aa594b50e10.jpg)\n![](https://pic.downk.cc/item/5f02703914195aa594b50e12.jpg)\n![](https://pic.downk.cc/item/5f02704a14195aa594b515ac.jpg)\n![](https://pic.downk.cc/item/5f02704a14195aa594b515ae.jpg)\n![](https://pic.downk.cc/item/5f02704a14195aa594b515b0.jpg)\n![](https://pic.downk.cc/item/5f02704a14195aa594b515b2.jpg)\n![](https://pic.downk.cc/item/5f02704a14195aa594b515b7.jpg)\n![](https://pic.downk.cc/item/5f02704a14195aa594b515ac.jpg)\n![](https://pic.downk.cc/item/5f02704a14195aa594b515ae.jpg)\n![](https://pic.downk.cc/item/5f02704a14195aa594b515b0.jpg)\n![](https://pic.downk.cc/item/5f0270d814195aa594b547f5.jpg)\n![](https://pic.downk.cc/item/5f0270d814195aa594b547f7.jpg)\n![](https://pic.downk.cc/item/5f0270e414195aa594b54cb7.jpg)\n![](https://pic.downk.cc/item/5f0270e414195aa594b54cb9.jpg)\n![](https://pic.downk.cc/item/5f0270e414195aa594b54cbe.jpg)\n"},{"title":"博客一周年！","tags":[],"categories":"告示牌","author":"柯罗krau","excerpt":"\n本博客自2020.3.9建站以来已经一年啦\n\n截止目前，总浏览量11682次，访客4291人（数据来源：busuanzi）\n\n感谢各位朋友的支持\n","link":"/posts/anniversary1","content":"\n本博客自2020.3.9建站以来已经一年啦\n\n截止目前，总浏览量11682次，访客4291人（数据来源：busuanzi）\n\n感谢各位朋友的支持\n"},{"title":"ArchLinux on Y9000P2022十分好用,就是有点难用","tags":["Linux"],"categories":["日常"],"author":"柯罗krau","excerpt":"受不了啦，给笔记本装上 Arch 折磨自己！\n","link":"/posts/archlinux-on-y9kp22-1","content":"受不了啦，给笔记本装上 Arch 折磨自己！\n<!-- more -->\n\n## 起因\n\n突然想安装 Arch 的理由：\n\n1. 酷！不觉得这很酷吗，做为一个理科生我觉得用一个完全手动安装的Linux发行版真的太酷了，很符合我对带黑客的想象！\n2. 自由！不同于乌班图、opensuse、centos这些具有实体维护者（商业公司）的发行版，Arch是由社区驱动的，属于自由阵营！不会受到各种奇怪法律的管辖！\n3. 简洁！Arch连安装的gui图形界面都没有，需要什么都要自己手动安装，最后的系统组件和应用将会不多也不少，符合自己的需求。\n4. 软件丰富！绝大多数软件已经有其他人帮你打包好了，安装就是一条命令解决！\n5. 不想用win了！但是不想用乌班图，太臃肿了！也不想用debian，太土了！\n6. 编不动了\n\n电脑是拯救者Y9000P2022款，配置：\n\n- CPU：I7 12700H\n- GPU：RTX3060M\n\n## 关于如何安装\n\n很简单，查 [Archlinux官方wiki](https://wiki.archlinux.org/) 就可以了。嫌官方的不够友好的话可以看这个：[ArchLinux简明指南](https://arch.icekylin.online/)\n\n## 遇到的问题\n\n### Nvidia显卡驱动\n\nSoNvidiaFUCKYOU!\n折腾了很长时间，这n卡的驱动就是装不上，最后是重装了系统，然后安装开源版驱动解决了：\n\n`sudo pacman -S nvidia-open`\n\n安装之后的处理和wiki里是一样的，好像比较新的型号的显卡（30系）都是要安装这个驱动。\n\n这个开源版并不是社区的那个逆向出来的开源版，而是nvidia官方给的，性能是没有太大问题的\n\n### Nvidia对wayland的兼容性\n\nSoNvidiaFUCKYOU!\n\nn卡+linux桌面=shit!N卡用户建议暂时不要用wayland，老老实实Xorg，兼容性比wayland好太多了。\n\n### 多显示器无法正常使用\n\n简单来说这还是N卡的锅，各种折腾尝试有可能会解决，玄学就是了。\n\n我能正常使用多显示器的情景有两个：\n\n1. BIOS设置混合模式，安装 `optimus-manager` 开核显模式。\n2. BIOS开独显直连，把nvidia驱动写进早加载，不要安装 `optimus-manager`。\n\n另外这两种模式都是Xorg，nvidia对wayland真的没啥兼容性，会出现一堆奇怪问题。\n\n### 蓝牙耳机无法连接\n\n安装这个就可以了\n\n`sudo pacman -S bluez bluez-utils pulseaudio-bluetooth`\n\n## 体验\n\n太好用啦！所有软件都用pacman或者yay直接安装，并且能纳入滚动升级中。\n\n### 聊天通讯\n\nTelegram：字体有问题，安装了几个中文字体之后正常了，体验和win是一样的，tg官方对于linux平台也是下了精力的。实在不行还能用web端。\n\nQQ：你没事吧？跟张小龙学会了登个号还得手机扫码？口区。而且登录的时候还会提示安全风险，难绷，不愧是腾讯。\n\n### 浏览器\n\n火狐，很不错。但是缩放有时候会出问题，打开的时候界面突然很小或者很大...应该是我多显示器的原因。\n\n然后还试了试 brave，只能说好像没多好用，而且一股子去中心化web3区块链虚拟币的味道。\n\n### 游戏\n\n出乎意料的流畅啊！谁说的linux打游戏是ppt的，体验和win没感知上的差距。当然可能是我不玩什么3a大作（实际上来说我几乎不玩游戏了），玩了 muse dash 这个音游试了下，体验真的和win没什么区别。\n\n### 开发与运维\n\n终端软件用的是 Termius（学生包白嫖的不用白不用），IDE还是vscode。\n\n好用！\n\n---\n\n快来加入Arch邪教吧！\n\n顺便，Arch的图标真的是太好看啦！\n\n![图片.png](https://s2.loli.net/2023/02/20/C2uoFdGhVQZrwvb.png)\n"},{"title":"dairy-butterfly","tags":["日记"],"categories":"日常","author":"柯罗krau","excerpt":"\n晚自习，教室里飞来一只蝴蝶。\n\n黑色的翅膀点缀着几点橙色，灵动地在教室里飞着。从前排飞到后排，又墙角飞到中央，从过道飞到讲台，在教室里转着圈。不知道是不是吊扇的风太大的缘故，它忽上忽下地翻旋。\n\n本","link":"/posts/dairy-butterfly","content":"\n晚自习，教室里飞来一只蝴蝶。\n\n黑色的翅膀点缀着几点橙色，灵动地在教室里飞着。从前排飞到后排，又墙角飞到中央，从过道飞到讲台，在教室里转着圈。不知道是不是吊扇的风太大的缘故，它忽上忽下地翻旋。\n\n本来没有人在意这只班级的不速之客，但它就这样一直盘旋了十分钟多，以至于连后排备课的老师的注意力都被它吸引了，当老师站起来想送它出门时，却又找不到了它。\n\n过了一会，还是不见它的身影，我望向座边窗户想要放松一下眼睛，正巧看到它落在了那里。我对邻桌说，你看这只蝴蝶怎么停在我们这里不走了。“关你什么事”，换来的是一句漫不经心的回复。\n\n下课了，四周的人也都注意到了这只黑蝴蝶，于是同组的同学说起了自己以前抓蝴蝶的事。\n\n坐在我前面的同学拿起笔，对着这只蝴蝶准备下杀手。我的心里咯噔一下。但旁边的几个人拦住了他，过了一会，那位同学又想去扎死它，我慌忙站了起来，抢先他一步，去抓那只蝴蝶的翅膀，于是它飞走了。\n\n它又开始在教室里盘旋，但这次飞的更高了一些，我揪紧了心，但我害怕的事情还是发生了：高速旋转的吊扇打到了它，它被击落在地。\n\n班里的人都注意到了，没有多想什么，我起身去捡起拿只蝴蝶的尸体。所幸的是那不是尸体，吊扇没有击中要害，也没有把翅膀打为残翅的，它还能勉强地扑动翅膀，但飞不了多高了。\n\n我把它放在了我的桌子上，听到了周围的嘁声。我又轻轻抓住了它，向教室门走去。\n\n到了教室外面，我放开了手，它又开始在走廊里盘旋，但过了一会不见了。\n\n这个时候，上课了，我回到了教室。同学都开始问我那只蝴蝶怎么样了，“放飞了”，我说。"},{"title":"FastAPI dependency injection system","tags":["Python","代码","FastAPi"],"categories":["学习笔记"],"author":"柯罗krau","excerpt":"\n## 什么是「依赖注入」 {lang=\"zh-CN\"}\n## What is \"Dependency Injection\" {lang=\"en\"}\n\n::: zh-CN\n\n>编程中的「依赖注入」是声明代码（本文中为路径操作函数 ）运行所需的，或要使用的「依赖」的一种方式。\n>\n>然后，由系统（本文中为 FastAPI）负责执行任意需要的逻辑，为代码提供这些依赖（「注入」依赖项）。\n>\n>依赖注入常用于以下场景：\n>\n>- 共享业务逻辑（复用相同的代码逻辑）\n>- 共享数据库连接\n>- 实现安全、验证、角色权限等……\n>\n>上述场景均可以使用依赖注入，将代码重复最小化。\n:::\n\n\n::: en\n\n>\"Dependency Injection\" means, in programming, that there is a way for your code (in this case, your path operation functions) to declare things that it requires to work and use: \"dependencies\".\n>\n>And then, that system (in this case FastAPI) will take care of doing whatever is needed to provide your code with those needed dependencies (\"inject\" the dependencies).\n>\n>This is very useful when you need to:\n>\n>- Have shared logic (the same code logic again and again).\n>- Share database connections.\n>- Enforce security, authentication, role requirements, etc.\n>- And many other things...\n>\n>All these, while minimizing code repetition.\n:::\n\n","link":"/posts/fastapi-dependency-injection","content":"\n## 什么是「依赖注入」 {lang=\"zh-CN\"}\n## What is \"Dependency Injection\" {lang=\"en\"}\n\n::: zh-CN\n\n>编程中的「依赖注入」是声明代码（本文中为路径操作函数 ）运行所需的，或要使用的「依赖」的一种方式。\n>\n>然后，由系统（本文中为 FastAPI）负责执行任意需要的逻辑，为代码提供这些依赖（「注入」依赖项）。\n>\n>依赖注入常用于以下场景：\n>\n>- 共享业务逻辑（复用相同的代码逻辑）\n>- 共享数据库连接\n>- 实现安全、验证、角色权限等……\n>\n>上述场景均可以使用依赖注入，将代码重复最小化。\n:::\n\n\n::: en\n\n>\"Dependency Injection\" means, in programming, that there is a way for your code (in this case, your path operation functions) to declare things that it requires to work and use: \"dependencies\".\n>\n>And then, that system (in this case FastAPI) will take care of doing whatever is needed to provide your code with those needed dependencies (\"inject\" the dependencies).\n>\n>This is very useful when you need to:\n>\n>- Have shared logic (the same code logic again and again).\n>- Share database connections.\n>- Enforce security, authentication, role requirements, etc.\n>- And many other things...\n>\n>All these, while minimizing code repetition.\n:::\n\n<!-- more -->\n\n## 示例 {lang=\"zh-CN\"}\n## Examples {lang=\"en\"}\n\n### 函数作为依赖 {lang=\"zh-CN\"}\n### Function as dependence {lang=\"en\"}\n\n::: zh-CN\n\n```python\nfrom fastapi import FastAPI, Depends\n\napp = FastAPI()\n\nasync def common_parameters(q: str | None = None, page: int = 1, limit: int = 10):\n    return {\"q\": q, \"page\": page, \"limit\": limit}\n\n@app.get(\"/dependency\")\nasync def dependency(commons: dict = Depends(common_parameters)):\n    return commons\n```\n\n`common_parameters` 函数定义了一组通用的查询参数`（q,page,limit）`，该函数接受这些参数并返回一个字典，该字典包含这些参数及其值。这些参数之间可以通过逗号进行分隔，表示它们是可选参数，并且有默认值。\n\n`@app.get(\"/dependency\")` 的路由装饰器绑定了一个API路由，这个路由接受一个名为 `commons` 的参数，这个参数需要调用 `common_parameters` 函数的返回值。Depends可以让我们把一个函数当做参数来传递到另一个函数，这里的 `Depends(common_parameters)` 表示该API路由需要调用 `common_parameters` 来获取查询参数。\n\n当请求到达API路由时，**FastAPI将调用 `common_parameters` 函数，将返回的字典作为 `commons` 参数的值注入到 `dependency` 函数中**，然后执行处理请求的逻辑并返回响应。因此，**`dependency` 的 `commons` 参数包含所有通用查询参数的值**，实现了依赖注入的功能。\n\n也就是说,通过依赖注入,我们使得一个代码块(函数)中可以调用另一个代码块,并访问其中的变量或属性\n\n::: tip\n实际上,这里是实现了类似类的继承的功能,由于 FastAPI 是以函数式编程为主,所以才有了依赖注入系统,来实现类的一些功能.\n\n在上面的例子中，`common_parameters` 可以看作是一个公共的基类（类似于父类），它定义了一组通用的查询参数。同时，`@app.get(\"/dependency\")` 中的函数可以看作是派生类（类似于子类），它需要使用通用查询参数来处理请求。\n\n当调用dependency函数时，`Depends` 会自动调用 `common_parameters` 函数，获取查询参数，然后将其注入到 `dependency` 函数中，类似于子类调用父类的构造函数获取公共配置，并继承其行为的方式。\n\n虽然Depends和依赖注入并不是类的继承，但它们可以实现类似的效果，使代码更加清晰和易于维护。\n:::\n\n::: en\nThe function common_parameters defines a set of common query parameters (q, page, limit) and accepts these parameters as input, then returns a dictionary containing these parameters and their values. These parameters can be separated by commas to indicate they are optional and have default values.\n\nThe API route decorator @app.get(\"/dependency\") binds an API route that accepts a parameter named commons, which needs to call the common_parameters function to get the query parameters. Depends allows us to pass a function as a parameter to another function. Here, the Depends(common_parameters) indicates that this API route needs to call common_parameters to get the query parameters.\n\nWhen a request arrives at the API route, FastAPI will call the common_parameters function and inject the returned dictionary as the value of the commons parameter into the dependency function. Then, it executes the logic to handle the request and returns the response. Therefore, the commons parameter of the dependency function contains the values of all the common query parameters, achieving the functionality of dependency injection.\n\n::: tip\nIn fact, here we are implementing a function similar to class inheritance. Since FastAPI is mainly based on functional programming, it has the dependency injection system to implement some functionality similar to class inheritance.\n\nIn the example above, common_parameters can be seen as a common base class (similar to a parent class) that defines a set of common query parameters. At the same time, the function in @app.get(\"/dependency\") can be seen as a derived class (similar to a child class) which needs to use the common query parameters to handle requests.\n\nWhen calling the dependency function, Depends automatically calls common_parameters to get the query parameters and injects them into the dependency function, similar to calling the parent class constructor to get common configurations and inherit its behavior.\n\nAlthough Depends and dependency injection are not inheritance of classes, they can achieve similar effects, making the code more clear and easy to maintain.\n:::\n\n### 类作为依赖 {lang=\"zh-CN\"}\n### Class as dependence {lang=\"en\"}\n\n::: zh-CN\n\n```python\nfake_item_db = [{\"item\": \"foo\"}, {\"item\": \"qwq\"}, {\"item\": \"awa\"}]\n\nclass CommonQueryParams:\n    def __init__(self, q: str | None = None, page: int = 1, limit: int = 100) -> None:\n        self.q = q\n        self.page = page\n        self.limit = limit\n\n\n@app.get(\"/classes_as_dependencies\")\nasync def class_as_dependencies(commons=Depends(CommonQueryParams)):\n    resp = {}\n    if commons.q:\n        resp.update({\"q\": commons.q})\n    items = fake_item_db[commons.page:commons.limit]\n    resp.update({\"items\": items})\n    return resp\n# 下面这两种写法也可以将类作为依赖\n# async def class_as_dependencies(commons:CommonQueryParams=Depends(CommonQueryParams))\n# async def class_as_dependencies(commons:CommonQueryParams=Depends())\n```\n\n当用户访问 `/classes_as_dependencies` 时，`CommonQueryParams` 依赖项会注入为 `commons` 参数。该端点然后检查请求中是否有指定搜索查询，并在有指定查询时使用它来更新 resp 字典。然后它根据 page 和 limit 参数从 fake_item_db 数据库检索项目，并返回一份带有搜索查询内容（如果有的话）和检索到的项目的响应。\n:::\n\n::: en\n\n```python\nfake_item_db = [{\"item\": \"foo\"}, {\"item\": \"qwq\"}, {\"item\": \"awa\"}]\n\nclass CommonQueryParams:\n    def __init__(self, q: str | None = None, page: int = 1, limit: int = 100) -> None:\n        self.q = q\n        self.page = page\n        self.limit = limit\n\n\n@app.get(\"/classes_as_dependencies\")\nasync def class_as_dependencies(commons=Depends(CommonQueryParams)):\n    resp = {}\n    if commons.q:\n        resp.update({\"q\": commons.q})\n    items = fake_item_db[commons.page:commons.limit]\n    resp.update({\"items\": items})\n    return resp\n```\n\nWhen a user accesses the /classes_as_dependencies endpoint, the CommonQueryParams dependency is injected as the commons parameter. The endpoint then checks if there is a search query specified in the request and updates the resp dictionary with the query if there is one. It then retrieves items from the fake_item_db database based on the page and limit parameters, and returns a response with the search query (if any) and the retrieved items.\n:::\n\n### 嵌套依赖 {lang=\"zh-CN\"}\n### nested dependencies {lang='en'}\n\n::: zh-CN\n依赖之间可以嵌套,**一个依赖可以依赖于另一个依赖**,即称为子依赖\n:::\n\n### 路径装饰器依赖与全局依赖 {lang=\"zh-CN\"}\n### Path decorator dependencies and global dependencies {lang=\"en\"}\n\n::: zh-CN\n可以为 FastAPI 的路径装饰器传入 dependencies 参数,该参数的值是 Depend() 类列表 ,传入后可以在装饰器下的函数中调用依赖项\n\n也可以在创建 FastAPI 或 APIRouter 实例时导入依赖,同样是传入 dependencies 参数,这样的依赖在整个应用下都可以调用\n:::\n\n::: en\nYou can pass the \"dependencies\" parameter to the path decorator of FastAPI, and the value of this parameter is a \"Depend()\" class list. After passing it, the dependencies can be called in the function under the decorator.\n\nYou can also import dependencies when creating FastAPI or APIRouter instances by passing the \"dependencies\" parameter. Such dependencies can be called throughout the entire application.\n:::"},{"title":"JWT 认证及其在 FastAPI 中的使用","tags":["Python","代码","FastAPi"],"categories":["学习笔记"],"author":"柯罗krau","excerpt":"\n## 什么是 JWT\n\nJWT: JSON Web Tokens,它是一种将 JSON 对象编码为没有空格，且难以理解的长字符串的标准。在具体上,它就是一段字符串,下面就是 FastAPI 文档中给出的例子\n\n```txt\neyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c\n```\n\n抽象地把它看成是这样的\n\n```txt\naaaaaaaaaaaa.bbbbbbbbbbbb.cccccccccccc\n```\n\n","link":"/posts/fastapi-jwt","content":"\n## 什么是 JWT\n\nJWT: JSON Web Tokens,它是一种将 JSON 对象编码为没有空格，且难以理解的长字符串的标准。在具体上,它就是一段字符串,下面就是 FastAPI 文档中给出的例子\n\n```txt\neyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c\n```\n\n抽象地把它看成是这样的\n\n```txt\naaaaaaaaaaaa.bbbbbbbbbbbb.cccccccccccc\n```\n\n<!-- more -->\n\njwt 由三个部分组成,这三个部分之间用点`.`拼接起来,这三个部分分别是\n\n- Header --- 头,定义了 jwt 使用的算法等信息\n- Payload --- 载荷,存储有效信息的地方\n- Signature --- 签名,用于校验 jwt 令牌\n\n这三个部分中,只有第三个部分是无法还原的,前两个部分只是简单的进行了 base64 编码,把上面例子中的前两部分解码之后,看起来是这样的:\n\nHeader:\n\n```json\n{\n    \"alg\":\"HS256\",\n    \"typ\":\"JWT\"\n}\n\n```\n\nalg 即为算法,这里使用了 HS256 算法\n\ntyp 即为类型,指明这里是一个 JWT 字符串\n\nPayload\n\n```json\n{\n    \"sub\":\"1234567890\",\n    \"name\":\"John Doe\",\n    \"iat\":1516239022\n}\n```\n\n可以看到 Payload 中存储了主要的信息\n\n::: tip 提示\n根据 JWT 规范, Payload 中的 `sub` 是一个预定义的声明（Claim），表示JWT的主题（**Subject**）。它指定了JWT所代表的实体或主题，通常是用户或客户端应用程序。\n`sub`声明的值是字符串类型，通常是**唯一**标识用户或客户端应用程序的ID。\n:::\n\n而 Signature 则是通过加盐加密得到的,加密由服务端实现\n\n::: tip 关于具体如何实现\n\n参考下图\n\n![图 1](/photo/post-pics/fastapi-jwt/fastapi-jwt_03-22-11-28-26.webp)\n\n即,把 header 和 payload 部分进行 base64编码,用点拼接起来,得到**结果**,把这个结果用我们设置的密钥和算法进行加盐加密,就得到了 Signature\n\n:::\n\n### JWT 有什么用\n\n其实它与 token ,cookie 的作用类似,就是用来免密码认证客户端\n\n比如你去上学,学校是服务端,你是客户端.你完成学籍注册之后,学校发给你一个学生证,学生证就是你的 jwt 令牌.\n\n你使用学校的很多服务,都要出示学生证.\n\n而在实际业务中,jwt 令牌是有过期时间的,过期之后,需要客户端再次登录,获取新的 jwt\n\n## FastAPI 实现 Bearer JWT 令牌验证\n\n需要安装以下几个包\n\npython-jose，在 Python 中生成和校验 JWT 令牌\n\n```bash\npip install python-jose[cryptography]\n```\n\nPasslib ,处理密码哈希\n\n```bash\npip install passlib[bcrypt]\n```\n\n::: warning\n\n密码哈希和 jwt 的加密不是同一个问题.\n\n哈希是指把特定内容（本例中为密码）转换为乱码形式的字节序列（其实就是字符串）。\n\n每次传入完全相同的内容时（比如，完全相同的密码），返回的都是完全相同的乱码。\n\n但这个乱码无法转换回传入的密码。\n\n把密码进行哈希并存储是必要的安全措施\n\n:::\n\n先不考虑用户注册的问题,假设我们已经有了一个在数据库中的用户,那么这里的逻辑是这样的:\n\n1. 该用户通过用户名和密码登录\n2. 服务端对其进行校验和认证\n3. 完成认证后,用户拿到 jwt 令牌(token)\n4. 用户使用 jwt 令牌(token)访问其他服务\n\n所以,我们需要:\n\n1. 一个存储了用户信息的数据库,其中密码存储的是哈希值\n2. 用户和 jwt 令牌(token)的模型\n3. 用于从数据库中获得用户信息,并验证的函数. 包括获取用户,哈希传入的密码,验证用户等\n4. 用于创建 jwt 令牌的函数\n5. 给用户登录并获取 jwt 令牌(token)的接口\n6. 验证用户的 jwt 是否正确和有效\n\n### 数据库与模型\n\n呃,为了简便和偷懒,就用 FastAPI 文档中的假数据库吧\n\n```python\nfake_users_db = {\n    \"johndoe\": {\n        \"username\": \"johndoe\",\n        \"full_name\": \"John Doe\",\n        \"email\": \"johndoe@example.com\",\n        \"hashed_password\": \"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW\",\n        \"disabled\": False,\n    }\n}\n```\n\n定义之后要用到的模型\n\n```python\nfrom pydantic import BaseModel\nfrom typing import Union\n\nclass Token(BaseModel):\n    access_token: str\n    token_type: str\n\n\nclass TokenData(BaseModel):\n    username: Union[str, None] = None\n\n\nclass User(BaseModel):\n    username: str\n    email: Union[str, None] = None\n    full_name: Union[str, None] = None\n    disabled: Union[bool, None] = None\n\n\nclass UserInDB(User):\n    hashed_password: str\n\n```\n\n`Token` 模型用于在登录接口中指定 `response_model`\n\n`TokenData` 用于从 token 中获取数据\n\n`User` 即用户模型,供外部使用\n\n`UserInDB` 是用户在数据库中的模型,它继承自 `User` 添加了 `hashed_password` 属性\n\n这些模型在之后会用到\n\n### 对用户名和密码的校验与认证\n\n这部分比较简单,就是把用户输入的密码哈希之后和数据库中的对比就好了\n\n```python\nfrom passlib.context import CryptContext\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n\ndef verify_password(plain_password, hashed_password):\n    \"\"\"\n    校验密码是否正确\n    将传入的明文密码与数据库中的哈希值进行比对\n    \"\"\"\n    return pwd_context.verify(plain_password, hashed_password)\n\n\ndef get_password_hash(password):\n    \"\"\"获取传入的密码的哈希值\"\"\"\n    return pwd_context.hash(password)\n\n\ndef get_user(db, username: str):\n    \"\"\"根据用户名从指定数据库中获取用户\"\"\"\n    if username in db:\n        user_dict = db[username]\n        return UserInDB(**user_dict)\n\n\ndef authenticate_user(fake_db, username: str, password: str):\n    \"\"\"身份验证, 返回用户对象或者 False\"\"\"\n    user = get_user(fake_db, username)\n    if not user:\n        return False\n    if not verify_password(password, user.hashed_password):\n        return False\n    return user\n```\n\n### 创建 jwt token\n\n完成认证之后,就可以给用户创建 token 了\n\n首先,定义 jwt 的加密密钥,加密算法和过期时间\n\n```python\nSECRET_KEY = \"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7\"\nALGORITHM = \"HS256\"\nACCESS_TOKEN_EXPIRE_MINUTES = 30\n```\n\n::: warning 注意\n\n在实际项目中,jwt 的密钥不应该直接写在代码中,而是应该从环境变量中读取\n\n例如,从环境变量中获取 SECRET_KEY\n\n```python\nimport os\nSECRET_KEY = os.environ.get(\"SECRET_KEY\")\n```\n\n:::\n\n然后写创建 token 的函数\n\n```python\nfrom datetime import datetime, timedelta\nfrom jose import JWTError, jwt\n\ndef create_access_token(data: dict, expires_delta=None):\n    \"\"\"创建 jwt token\"\"\"\n    to_encode = data.copy()\n    if expires_delta:\n        expire = datetime.utcnow() + expires_delta\n    else:\n        expire = datetime.utcnow() + timedelta(minutes=15)\n    to_encode.update({\"exp\": expire})\n    # 注意这里就用到了上面定义的 SECRET_KEY 和 ALGORITHM\n    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)\n    return encoded_jwt\n```\n\n上面这个函数把传入的用于获取 jwt 的数据进行拷贝,并添加过期时间,然后 encode 得到 jwt token 并返回\n\n至此,我们完成了对用户的校验和认证,以及创建 jwt token 的功能,下面我们要在接口中使用它们\n\n### 提供登录并创建token的接口\n\n```python\nfrom fastapi import Depends, FastAPI, HTTPException, status\nfrom fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm\n\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"token\")\n@app.post(\"/token\", response_model=Token)\nasync def login_for_access_token(form_data: OAuth2PasswordRequestForm = Depends()):\n    \"\"\"登录并获取 token\"\"\"\n    # 通过用户名和密码获取用户, 如果用户不存在或者密码错误, 则抛出异常\n    user = authenticate_user(fake_users_db, form_data.username, form_data.password)\n\n    if not user:\n        raise HTTPException(\n            # 这部分是规范, 401 表示未授权\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Incorrect username or password\",\n            headers={\"WWW-Authenticate\": \"Bearer\"},\n        )\n\n    # 上面已经相当于进行了用户身份验证, 所以这里可以直接创建 token\n    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)\n    access_token = create_access_token(\n        data={\"sub\": user.username}, expires_delta=access_token_expires\n    )\n    # 这里如何返回也是规范, 我们已在上面已经定义好了 response_model=Token\n    return {\"access_token\": access_token, \"token_type\": \"bearer\"}\n```\n\n`oauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"token\")` 声明了用户应该从哪个路由获取 token (相对路径),但是并未实现具体的功能\n\n而我们自己写的 `login_for_access_token` 则是实现.\n\n现在用户成功登录后,就拿到了 jwt token ,访问其他服务时,浏览器会携带 jwt token 一起发送请求\n\n我们只需要在其他接口中,对用户传来的 jwt token 进行验证即可\n\n### 在其他接口中验证jwt token\n\n比如我们有一个获取用户信息的接口 `read_users_me` ,那么,我们需要:\n\n1. 获取用户传来的 token\n2. 验证 token 是否正确和有效\n3. 通过 token 获取当前的用户信息\n\n首先,解密 jwt token ,获取当前用户:\n\n```python\nasync def get_current_user(token: str = Depends(oauth2_scheme)):\n    \"\"\"依赖函数, 用于获取当前用户\"\"\"\n    # 定义一个异常, 用于在用户身份验证失败时抛出\n    credentials_exception = HTTPException(\n        status_code=status.HTTP_401_UNAUTHORIZED,\n        detail=\"Could not validate credentials\",\n        headers={\"WWW-Authenticate\": \"Bearer\"},\n    )\n\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        # 从 payload 中获取 username\n        # 关于 sub 的解释, 可以参考文档\n        username: str = payload.get(\"sub\")\n        if username is None:\n            raise credentials_exception\n        token_data = TokenData(username=username)\n    except JWTError:\n        raise credentials_exception\n    user = get_user(fake_users_db, username=token_data.username)\n    if user is None:\n        raise credentials_exception\n    return user\n\nasync def get_current_active_user(current_user: User = Depends(get_current_user)):\n    \"\"\"依赖函数, 用于获取当前活跃的用户,用到了上面的依赖函数 get_current_user\n    为什么 current_user 可以是 User 类型而不是 get_current_user 返回的 UserInDB 类型呢?\n    因为 UserInDB 类型是 User 类型的子类, 所以可以直接赋值给 User 类型的变量\n    \"\"\"\n    if current_user.disabled:\n        raise HTTPException(status_code=400, detail=\"Inactive user\")\n    return current_user\n```\n\n在 数据库与模型 中, 我们定义的 `TokenData` 就是这里要用的\n\n因为只是演示,所以这个 `TokenData` 类显得有点多此一举.\n\n但是如果你需要传递多个 JWT 数据，或者有多个函数需要访问 JWT 数据，那么 `TokenData` 类可以方便地将这些数据打包在一起，并在函数之间传递它们。\n\n之后就可以在接口中利用依赖注入,验证用户请求\n\n```python\n@app.get(\"/users/me/\", response_model=User)\nasync def read_users_me(current_user: User = Depends(get_current_active_user)):\n    \"\"\"获取当前用户信息\"\"\"\n    return current_user\n```\n\n## 总结\n\nJWT 是一种认证方式,它的本质是一段带有签名的字符串.\n\n在 Python 中,我们可以使用 `jwt` 模块来创建和解析 jwt token.\n\n在 FastAPI 中,我们可以使用 `OAuth2PasswordBearer` 来获取用户传来的 token,然后使用 `jwt` 模块来解析 token,从而获取用户信息.\n\n## 参考\n\n[JWT 官方文档](https://jwt.io/introduction/)\n\n[FastAPI 官方文档 - 安全性](https://fastapi.tiangolo.com/tutorial/security/)\n\n[FastAPI 官方文档 - 依赖注入](https://fastapi.tiangolo.com/tutorial/dependencies/)"},{"title":"freda-一个多种自定义的电子书阅读器","tags":["阅读","安利"],"categories":"日常","author":"柯罗krau","excerpt":"\n## 简评\n\n这是一个可本地和在线的电子书阅读器，支持各种常见的电子书/文档格式，几乎免费，除了首页底部有一条横幅广告需要付费去除外，还未发现任何需要付费的功能\n\n## 安装\n\nfreda上架在Mi","link":"/posts/freda-recommend","content":"\n## 简评\n\n这是一个可本地和在线的电子书阅读器，支持各种常见的电子书/文档格式，几乎免费，除了首页底部有一条横幅广告需要付费去除外，还未发现任何需要付费的功能\n\n## 安装\n\nfreda上架在Microsoft store，直接去搜索 freda 即可安装\n\n## 体验\n\n### 特点\n\n这是主界面，非常win10原生的风格\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200416212839.png)\n主页下方有横条广告，需要付费大约2刀去除。对于我来说，主页面的广告可以不在意，但如果是阅读过程中的广告会让我直接劝退\n\n可以看到，freda可以从本地，或是feedbooks/calibre/onedrive/gutenberg/epub books/smashwords导入/备份/同步你的电子书，但是我几乎只把它当作本地阅读器使用了2333\n\nfreda的高级功能是免费的，支持书签，注释和突出显示，还有文本到语音转换，很适合学生用。\n\n支持很多种格式\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200416213435.png)\n\n可以使用标题或是tag等方式管理电子书\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200416213701.png)\n\n具有非常强的自定义性，我很喜欢这一点\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200416213933.png)\n\n多种主题样式可选择，可以按照自己喜好自定义出好看的程序外观\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200416214030.png)\n\n文本字体，主题背景，页面纸张，文字颜色等等都是可以自定义的\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200416220501.png)\n\n### 缺点\n\n1. 不支持中文的程序页面\n2. 有横幅广告\n3. 无法阅读受保护的Kindle书籍\n"},{"title":"简单汇总下那些推过的galgame（持续更新）","tags":["ACG","galgame"],"categories":["日常"],"author":"柯罗krau","excerpt":"\n","link":"/posts/gal-collection","content":"\n<!-- more -->\n\n## 个人 galgame 整理&安利\n\n就按照我能回想起来的先后顺序排序吧（，而且也懒得分类什么的，都混着列出来得了（\n反正我玩的不算多←是真话\n\n---\n\n### 将所有的歌献给未来的你\n\n![](https://i.loli.net/2021/06/02/FEuSNprv2xtG3LH.png)\n\n> 未来のキミと、すべての歌に―是Supplement Time在2008年04月04日[1]发售的初音同人游戏。是Supplement Time出品的初音系列的同人游戏的第一部。其后续作有鈴が歌う、未来の音色―和未来の歌と、つながるヒトミ。\n详见[萌娘百科](https://zh.moegirl.org/zh-hans/%E5%B0%86%E6%89%80%E6%9C%89%E7%9A%84%E6%AD%8C%E7%8C%AE%E4%BA%8E%E6%9C%AA%E6%9D%A5%E7%9A%84%E4%BD%A0)\n\n应该是我玩的第一款gal？？不太确定了，反正玩的挺早的\n\n算是比较日常但是又有些波折的剧情，总之就是在大街上捡回家了只miku然后发生的种种......\n\n### nekopara\n\n![](https://pic.downk.cc/item/5f04083814195aa5946cd80d.jpg)\n>《猫娘乐园》（日语：ネコぱら；英语：NEKOPARA）是由NEKO WORKs发行的Galgame。\n详见萌娘百科[猫娘乐园](https://zh.moegirl.org/zh-hans/%E7%8C%AB%E5%A8%98%E4%B9%90%E5%9B%AD#)\n  \n经典的猫系gal，~~听说打个补丁会更有趣~~\n\n### 美少女万华镜\n\n不配图了这个emmmm\n>《美少女万华镜》美少女万拔镜（日语：美少女万華鏡）是日本游戏品牌ωstar制作并发售的纯爱系超自然官能AVG系列作品。 详见萌娘百科[美少女万华镜](https://zh.moegirl.org/zh-hans/%E7%BE%8E%E5%B0%91%E5%A5%B3%E4%B8%87%E5%8D%8E%E9%95%9C#)\n\n### 哥哥，早上起床之前都要抱紧我哦\n\n![](https://pic.downk.cc/item/5f0409ee14195aa5946d78e2.jpg)\n>《哥哥，早上起床之前都要抱紧我哦！》是由Tinkle Position制作的一部Galgame。 [萌娘百科详情](https://zh.moegirl.org/zh-hans/%E5%93%A5%E5%93%A5%EF%BC%8C%E6%97%A9%E4%B8%8A%E8%B5%B7%E5%BA%8A%E4%B9%8B%E5%89%8D%E9%83%BD%E8%A6%81%E6%8A%B1%E7%B4%A7%E6%88%91%E5%93%A6%EF%BC%81)\n\n~~国欠妹系列~~\n\n### 缘之空\n\n![](https://pic.downk.cc/item/5f040afe14195aa5946dd903.jpg)\n>《缘之空》（ヨスガノソラ，Yosuga no Sora）是Sphere于2008年12月5日发售的恋爱文字冒险游戏，也是Sphere的处女作。亦有漫画、动画、Fandisk、广播剧等衍生作品。[萌娘百科：缘之空](https://zh.moegirl.org/zh-hans/%E7%BC%98%E4%B9%8B%E7%A9%BA#)\n\n国欠妹*2\n对应的续作还有一部『悠之空』\n\n### 双子洛丽塔后宫\n\n   ![](https://pic.downk.cc/item/5f040b9114195aa5946e11b6.jpg)\n\n   不说什么~\n\n### 東津萌米-穗姬\n\n![](https://i.loli.net/2020/07/07/ygVwB4o3i19zxXm.jpg)_找不到更高清的图了_\n> 穗姬是原产于台湾屏东县东港镇的杂交稻米品种“高雄145”以及该稻米所产的大米“东津萌米”的萌娘化形象，也登场于游戏《东津萌米-穗姬》中。 [萌娘百科：穗姬](https://zh.moegirl.org/zh-hans/%E7%A9%97%E5%A7%AC#)\n\n国产游戏，更偏向于养成系的（种大米），姑且也算是galgame吧\n~~万物皆可萌~~\n\n### 家有仙妻～无名小猫又与神Tuber～\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200707140100.png)\n\n猫系galgame*2\n\n萌百没收录这个......明明挺~~社保~~的\n\n### 恋爱少女人格崩坏\n\n![](https://pic.downk.cc/item/5f154ec714195aa5942c10a6.jpg)\n\n能搞笑又能社保~~（指男主）~~\n\n### 魔女的夜宴\n\n时间：2020.7.17-2020.7.24±\n![](https://cdn.jsdelivr.net/gh/voidoath/photo@master/blog-img/sabbatofwitch.png)\n\n谁敢反对狗头，我就打爆他的宁宁（错乱\n\n### 千恋万花\n\n时间：2020.7.26±-2020.7.28±（只过了从雨线）\n从雨天下第一！\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200804182632.png)\n\n### ATRI -My Dear Moments-\n\n时间：2020.7.29-2020.8.2？\n咕噜咕噜~呸\n![](https://i.loli.net/2020/08/04/kEtr4q3MexlNzvA.png)\n\n### 星光咖啡馆与死神之蝶\n\n时间：2020.8.28-8.31（明月栞那）\n~~星巴克与大扑棱蛾子~~\n![](https://i.loli.net/2020/09/11/eRyb7AahWzgdKkD.png)\n\n### RIDDLEJOKER\n\n时间：2020.9.7-9.16（在原七海）\n能推睡着的一gal......但感觉还不戳，（七海天下第一）\n![图片.png](https://i.loli.net/2021/06/02/VC8r7GvWoeUTm4M.png)\n\n### 想要传达给你的爱恋\n\n时间：5.24-5.30\n苟利星奏生死以，岂因新岛避趋之\n![](https://i.loli.net/2021/06/02/2zX4i3DFrco7Lhs.png)\n\n### 异想魅惑\n\n时间:2021.6.4（云）\n\n# 异想魅惑\n\n探索解密式的剧情玩法+色气可爱的唯一女主魅魔设定\n虽然te确实很感人，但其他五条结局也很绝望和惊悚\n![](https://i.loli.net/2021/06/04/Bir1Gpe7KzbDxT5.png)\n\n### 诱惑自大洛丽塔\n\n时间：2021年\n![](https://i.loli.net/2021/06/04/LQpf9eHyVNYbaCM.png)\n\n### 九次九日九重色\n\n时间：2021.6.5\n![](https://i.loli.net/2021/06/06/tZD7gOkq6lzo1WR.png)\n喵都太可爱了\n\n### 天色天歌天籁音\n\n时间：2021.6.6\n国欠我一个天妹\n![](https://i.loli.net/2021/06/06/4Med61olIyfZv5t.png)\n\n### 春色春恋春熙风\n\n时间：2021.6.7\n\n### 雪色雪花雪余痕\n\n时间：2021.6.7-6.8\n\n### 9-nine- 新章\n\n时间：2021.6.8\n\n### 牵绊闪耀的恋之伊吕波\n\n时间：2021.8.25-8.29\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20210829224332.png)\n\n发椿啦发椿啦，当然椿恋歌也会推的啦，这里就只写一个好了\n\n### 星空列车与白的旅行\n\n时间：2021.9\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/000_title.png)\n这是一部“童话”\n\n### 巧可甜恋\n\n时间：2021.9\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20211001193405.png)\n剧情是真的短，但她真的太可爱了太刑了\n\n### 糖调！-sugarfull tempering-\n\n时间：2021.9\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/Sugarful_cover.jpg)\n冰织天下第一！\n"},{"title":"2021新年快乐!","tags":[],"categories":"日常","author":"柯罗krau","excerpt":"\n勤勉的我已经给所有友联发了新年祝福（纯手动），如果没收到可能有以下原因：\n\n1. 博客内没有设置评论入口且没有提供邮箱联系方式\n2. 评论系统炸了且没有提供邮箱联系方式\n3. 链接失效\n4. 单向本","link":"/posts/happynewyear2021","content":"\n勤勉的我已经给所有友联发了新年祝福（纯手动），如果没收到可能有以下原因：\n\n1. 博客内没有设置评论入口且没有提供邮箱联系方式\n2. 评论系统炸了且没有提供邮箱联系方式\n3. 链接失效\n4. 单向本站\n5. 我没看见你的邮箱或者没找到评论入口（\n\n这次顺便清查了一些挂掉的链接，单向本站的都删除了，链接挂了或者很长时间（约8个月以上）没有任何更新的移动到了失联组\n\n总之祝各位新年快乐啦\n"},{"title":"hexo设备迁移","tags":["hexo","博客"],"categories":"小技术","author":"柯罗krau","excerpt":"\n","link":"/posts/hexo-devices-migrate","content":"\n<!-- more -->\n\n1. 备份整个blog文件夹（除 node_modules 文件夹以及一些临时文件）\n2. 在新设备上安装 node.js 、npm、git\n3. 使用npm全局安装hexo\n4. 在博客文件夹下执行`npm install`安装依赖\n5. 配置ssh密钥\n\n   `ssh-keygen -t rsa -C \"example@email.com\"`\n    生成密钥后复制内容粘贴到代码托管网站的个人密钥设置中 github>settings>SSH and GPG keys>New SSH key\n\n6. 设置git全局身份\n\n    `git config --global user.name \"your user name\"`\n\n    `git config --global user.email \"example@email.com\"`\n\n7. 定位到备份下来的blog文件夹，执行hexo d部署尝试，可能会遇到以下错误提示：\n\n    “Warning: Permanently added the RSA host key for IP address 'i.p.i.p' to the list of known hosts.”\n\n    并会询问是否仍要建立连接（yes/no）\n    yes 就可以了"},{"title":"将 hexo 博客迁移至 valaxy","tags":["hexo","valaxy","博客","安利"],"categories":["小技术"],"author":"柯罗krau","excerpt":"\n::: warning 注意\n本文章作于 valaxy 版本 0.12.2 , 部分内容可能已经过时 , 请结合[官方文档](https://valaxy.site/guide/getting-started)一起阅读\n:::\n\n## 前言\n\n在 2022 年 8 月份，我向[云游君](https://github.com/YunYouJun)的 hexo 主题 [hexo-theme-yun](https://github.com/YunYouJun/hexo-theme-yun) 提 issue 的时候，他向我提到了 [valaxy](https://valaxy.site/) 这个由他开发的静态博客框架。当时 valaxy 十分先进的技术栈和一些优良特性一下就吸引了我，但是由于我已经使用 hexo 写了很多文章，且 valaxy 也没有迁移文档/工具，所以那时我并没有迁移。\n\n时隔半年，我再去看 valaxy 的时候，它已经基本可用了，文档虽然还是不完整，但是够用。于是我决定将我的 hexo 博客迁移至 valaxy。~~hexo 这贼船越早下越好~~\n\n","link":"/posts/hexo-migrate-to-valaxy","content":"\n::: warning 注意\n本文章作于 valaxy 版本 0.12.2 , 部分内容可能已经过时 , 请结合[官方文档](https://valaxy.site/guide/getting-started)一起阅读\n:::\n\n## 前言\n\n在 2022 年 8 月份，我向[云游君](https://github.com/YunYouJun)的 hexo 主题 [hexo-theme-yun](https://github.com/YunYouJun/hexo-theme-yun) 提 issue 的时候，他向我提到了 [valaxy](https://valaxy.site/) 这个由他开发的静态博客框架。当时 valaxy 十分先进的技术栈和一些优良特性一下就吸引了我，但是由于我已经使用 hexo 写了很多文章，且 valaxy 也没有迁移文档/工具，所以那时我并没有迁移。\n\n时隔半年，我再去看 valaxy 的时候，它已经基本可用了，文档虽然还是不完整，但是够用。于是我决定将我的 hexo 博客迁移至 valaxy。~~hexo 这贼船越早下越好~~\n\n<!-- more -->\n\n### 关于 hexo\n\n相信很多博主在搜索“白嫖”建自己的博客网站的时候，第一个了解到的方案就是 hexo + GitHub pages 。hexo 确实经典、成熟，但是却有很多历史问题。功能上不够组件化、体验上不能热更新、性能上构建速度不够快等等。尤其让我感到别扭的是它杂乱的目录结构...尽管已经使用 hexo 三年，我还是决定放弃它了。\n\n### 关于 valaxy\n\n这是一个各种意义上很新的东西，主要由云游君开发，它的目标是成为下一代静态博客框架。\n\n关于 valaxy 的介绍可以在下面获取\n\n- 项目地址：[YunYouJun/valaxy](https://github.com/YunYouJun/valaxy)\n\n- 官方文档：[valaxy](https://valaxy.site/)\n\n但是 valaxy 并不旨在成为下一代的 hexo ，也就是说并不向着与 hexo 的兼容的方向开发。因此迁移起来并不是特别简单。\n\n---\n\n## 创建 valaxy 项目\n\n### 环境\n\nValaxy 要求 Node.js 的 14.18 以上，如果你是从 hexo 的较新版本迁移的，一般不需要去升级。\n\nvalaxy 建议使用 pnpm 作为包管理器，使用 `npm i -g pnpm` 全局安装它\n\n### 创建\n\n在工作文件夹下，使用以下命令\n\n```shell\npnpm create valaxy\n```\n\n然后输入你的博客文件夹名，同时也是项目名称，默认为 `valaxy-blog`。我这里使用 `valaxy-demo`\n\n![输入项目名称](/photo/post-pics/hexo-migrate-to-valaxy/hexo-migrate-to-valaxy_01-16-13-37-38.webp)\n\n随后询问是否现在安装并启动，确定。\n\n![询问是否安装并启动](/photo/post-pics/hexo-migrate-to-valaxy/hexo-migrate-to-valaxy_01-16-13-39-16.webp)\n\n很快就完成了项目创建，此时可以在终端中按 o 打开浏览器预览\n\n![预览](/photo/post-pics/hexo-migrate-to-valaxy/hexo-migrate-to-valaxy_01-16-13-40-50.webp)\n\n进入创建好的项目文件夹，使用以下命令安装依赖\n\n```shell\n# install\npnpm i\n```\n\n### 命令\n\nvalaxy 在默认局部配置脚本下的一些命令\n\n开启本地开发环境（预览，支持热重载）\n\n```shell\npnpm run dev\n```\n\n构建静态文件\n\n```shell\npnpm run build\n```\n\n升级(pnpm 交互升级命令)\n\n```shell\n# upgrade valaxy\npnpm up --latest -i\n```\n\n新建文章\n\n```shell\npnpm new post-title\n```\n\n## 修改配置\n\n在此简要了解一下[目录结构](https://valaxy.site/guide/getting-started#%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84)，见下图\n\n![valaxy目录结构](/photo/post-pics/hexo-migrate-to-valaxy/hexo-migrate-to-valaxy_01-16-14-13-22.webp)\n\n其中 `valaxy.config.ts` 是主要需要修改的配置。建议使用 VSCode 编辑它，并按照提示安装推荐的插件。\n\n> valaxy.config.ts 提供了完备的类型提示，这意味着你在 VSCode 中可以直接鼠标悬浮查看各参数注释。\n\n默认有些配置项未在 valaxy.config.ts 中给出，使用的是默认值，可以自己添加上就可以覆盖默认值。\n\n### 站点与作者信息\n\n![站点与作者信息配置](/photo/post-pics/hexo-migrate-to-valaxy/hexo-migrate-to-valaxy_01-16-13-50-34.webp)\n\n- url: '站点链接'\n- lang: '默认语言(valaxy支持单页国际化)'\n- title: '站点标题'\n- subtitle: '副标题'\n- author:\n  - name: '博主名字'\n  - avatar: '头像地址'\n  - status:\n    - emoji: '一个emoji'\n    - message: '状态说明'\n- mode: '默认颜色模式'\n- lastUpdated: '开启最近更新:true'\n- favicon: '站点图标地址'\n- description: '描述'\n\n示例:\n\n```ts\n  url: 'http://krau.top',\n  lang: 'zh-CN',\n  title: '柯罗krau的博客 | krau\\'s blog',\n  subtitle: '',\n  author: {\n    name: '柯罗krau',\n    avatar: '/photo/avatar/avatar.jpg',\n    status:\n    {\n      emoji: '😐',\n      message: '真不想上学'\n  }},\n  mode: 'auto',\n  lastUpdated: true,\n  favicon: '',\n  description: '年轻，就要折腾',\n  //...\n```\n\n### 社交链接\n\n- social\n  - name: '名称'\n  - link: '链接'\n  - icon: '图标'\n  - color: '颜色'\n\n示例:\n\n```ts\nsocial: [\n    {\n      name: 'RSS',\n      link: '/atom.xml',\n      icon: 'i-ri-rss-line',\n      color: 'orange',\n    },\n    {\n      name: 'GitHub',\n      link: 'https://github.com/krau',\n      icon: 'i-ri-github-line',\n      color: '#6e5494',\n    },\n    {\n      name: '网易云音乐',\n      link: 'https://music.163.com/#/user/home?id=1428613796',\n      icon: 'i-ri-netease-cloud-music-line',\n      color: '#C20C0C',\n    },\n    {\n      name: '哔哩哔哩',\n      link: 'https://space.bilibili.com/296036767',\n      icon: 'i-ri-bilibili-line',\n      color: '#FF8EB3',\n    },\n    {\n      name: 'Telegram Channel',\n      link: 'https://t.me/acherkrau',\n      icon: 'i-ri-telegram-line',\n      color: '#0088CC',\n    },\n    {\n      name: 'Telegram Group',\n      link: 'https://t.me/blogszh',\n      icon: 'i-ri:telegram-fill',\n      color: '\"#0088CC'\n    },\n    {\n      name: 'E-Mail',\n      link: 'mailto:me@krau.top',\n      icon: 'i-ri-mail-line',\n      color: '#8E71C1',\n    },\n    {\n      name: 'Travelling',\n      link: 'https://www.travellings.cn/go.html',\n      icon: 'i-ri-train-line',\n      color: 'var(--va-c-text)',\n    },\n  ],\n```\n\n### 搜索\n\n- search\n  - enable: 开启搜索功能:true\n  - type: '搜索方式:local|engine|algolia'\n\n示例:\n\n```ts\n  search: {\n    enable: true,\n    type: 'engine',\n  },\n```\n\n### 赞助\n\n- sponsor\n  - enable: true|false\n  - title: '赞助标题'\n  - methods\n    - name: '赞助方式名称'\n    - url: '链接'\n    - color: '颜色'\n    - icon: '图标'\n\n示例:\n\n```ts\n  sponsor: {\n    enable: false,\n    title: '我很可爱，请给我钱！',\n    methods: [\n      {\n        name: '支付宝',\n        url: '',\n        color: '#00A3EE',\n        icon: 'i-ri-alipay-line',\n      },\n      {\n        name: 'QQ 支付',\n        url: '',\n        color: '#12B7F5',\n        icon: 'i-ri-qq-line',\n      },\n      {\n        name: '微信支付',\n        url: '',\n        color: '#2DC100',\n        icon: 'i-ri-wechat-pay-line',\n      },\n    ],\n  },\n```\n\n### yun主题配置\n\nvalaxy 目前默认主题是 [yun](https://github.com/YunYouJun/valaxy/tree/main/packages/valaxy-theme-yun)\n\n- theme: '主题名称'\n- themeConfig\n  - banner\n    - enable: 是否开启首页标题动画:true|false\n    - title: '标题'\n  - bg_image:\n    - enable: 是否开启背景图:true|false\n    - url: '背景图链接'\n    - dark: '深色模式下的背景图'\n    - opactity: 背景不透明度:float\n  - colors:\n    - primary: '主题色,支持16进制任意配色'\n  - say:\n    - enable: 是否开启一言:true|false\n    - api: '一言api地址,可留空使用默认'\n  - pages //页面配置\n    - name: '名称'\n    - url: '路径|链接'\n    - icon: '图标'\n    - color: '颜色'\n  - footer\n    - since: 网站开始年份\n    - beian\n      - enable: 是否开启备案信息显示:true|false\n      - icp: '备案信息'\n\n示例:\n\n```ts\n  theme: 'yun',\n\n  themeConfig: {\n    banner: {\n      enable: true,\n      title: '柯罗の自留地',\n    },\n    bg_image: {\n      enable: true,\n      url: '/photo/bg/atri.webp',\n      dark: '/photo/bg/bg.webp',\n      opacity: 0.7\n    },\n    colors: {\n      primary: '#39c5bb'\n    },\n    say:{\n      enable: false\n    },\n    pages: [\n      {\n        name: '友人帐',\n        url: '/links/',\n        icon: 'i-ri-genderless-line',\n        color: 'dodgerblue',\n      },\n      {\n        name: 'My Love',\n        url: '/girls/',\n        icon: 'i-ri-women-line',\n        color: 'hotpink',\n      },\n    ],\n\n    footer: {\n      since: 2020,\n      beian: {\n        enable: false,\n        icp: '苏ICP备17038157号',\n      },\n\n    },\n  },\n```\n\n### 评论\n\nvalaxy 通过插件的方式实现评论，目前实现了对 [waline](https://waline.js.org) 的支持\n\n```ts\n  comment: {\n    enable: true,\n  },\n\n  addons: [\n    addonWaline({\n      serverURL: '后端链接',\n      //以下功能未实现，但可以先写进配置里\n      pageview: true,\n      dark: 'auto',\n      requiredMeta: ['nick','mail'],\n      locale:{\n        placeholder: '填写邮箱，可以收到回复通知~'\n      }\n        \n    }),\n  ],\n```\n\n### 完整配置文件示例\n\n```ts\nimport { defineConfig } from 'valaxy'\nimport type { ThemeConfig } from 'valaxy-theme-yun'\nimport { addonWaline } from 'valaxy-addon-waline'\n//import { defineConfig } from 'vite'\n// add icons what you will need\n\n/**\n * User Config\n */\n\nexport default defineConfig<ThemeConfig>({\n  url: 'https://krau.top',\n  lang: 'zh-CN',\n  title: '柯罗krau的博客 | krau\\'s blog',\n  subtitle: '',\n  author: {\n    name: '柯罗krau',\n    avatar: '/photo/avatar/avatar.jpg',\n    status:\n    {\n      emoji: '😐',\n      message: '真不想上学'\n  }},\n  mode: 'auto',\n  lastUpdated: true,\n  favicon: '',\n  description: '年轻，就要折腾',\n  social: [\n    {\n      name: 'RSS',\n      link: '/atom.xml',\n      icon: 'i-ri-rss-line',\n      color: 'orange',\n    },\n    {\n      name: 'GitHub',\n      link: 'https://github.com/krau',\n      icon: 'i-ri-github-line',\n      color: '#6e5494',\n    },\n    {\n      name: '网易云音乐',\n      link: 'https://music.163.com/#/user/home?id=1428613796',\n      icon: 'i-ri-netease-cloud-music-line',\n      color: '#C20C0C',\n    },\n    {\n      name: '哔哩哔哩',\n      link: 'https://space.bilibili.com/296036767',\n      icon: 'i-ri-bilibili-line',\n      color: '#FF8EB3',\n    },\n    {\n      name: 'Telegram Channel',\n      link: 'https://t.me/acherkrau',\n      icon: 'i-ri-telegram-line',\n      color: '#0088CC',\n    },\n    {\n      name: 'Telegram Group',\n      link: 'https://t.me/blogszh',\n      icon: 'i-ri:telegram-fill',\n      color: '\"#0088CC'\n    },\n    {\n      name: 'E-Mail',\n      link: 'mailto:me@krau.top',\n      icon: 'i-ri-mail-line',\n      color: '#8E71C1',\n    },\n    {\n      name: 'Travelling',\n      link: 'https://www.travellings.cn/go.html',\n      icon: 'i-ri-train-line',\n      color: 'var(--va-c-text)',\n    },\n  ],\n\n  search: {\n    enable: true,\n    type: 'engine',\n  },\n\n  sponsor: {\n    enable: false,\n    title: '我很可爱，请给我钱！',\n    methods: [\n      {\n        name: '支付宝',\n        url: '',\n        color: '#00A3EE',\n        icon: 'i-ri-alipay-line',\n      },\n      {\n        name: 'QQ 支付',\n        url: '',\n        color: '#12B7F5',\n        icon: 'i-ri-qq-line',\n      },\n      {\n        name: '微信支付',\n        url: '',\n        color: '#2DC100',\n        icon: 'i-ri-wechat-pay-line',\n      },\n    ],\n  },\n\n  theme: 'yun',\n\n  themeConfig: {\n    banner: {\n      enable: true,\n      title: '柯罗の自留地',\n    },\n    bg_image: {\n      enable: true,\n      url: '/photo/bg/atri.webp',\n      dark: '/photo/bg/bg.webp',\n      opacity: 0.7\n    },\n    colors: {\n      primary: '#39c5bb'\n    },\n    say:{\n      enable: false\n    },\n    pages: [\n      {\n        name: '友人帐',\n        url: '/links/',\n        icon: 'i-ri-genderless-line',\n        color: 'dodgerblue',\n      },\n      {\n        name: 'My Love',\n        url: '/girls/',\n        icon: 'i-ri-women-line',\n        color: 'hotpink',\n      },\n    ],\n\n    footer: {\n      since: 2020,\n      beian: {\n        enable: false,\n        icp: '苏ICP备17038157号',\n      },\n\n    },\n  },\n\n  unocss: {\n    safelist: [\n      'i-ri-home-line',\n    ],\n  },\n\n  comment: {\n    enable: true,\n  },\n\n  addons: [\n    addonWaline({\n      serverURL: 'https://后端',\n      pageview: true,\n      dark: 'auto',\n      requiredMeta: ['nick','mail'],\n      locale:{\n        placeholder: '填写邮箱，可以收到回复通知~'\n      }\n        \n    }),\n  ],\n})\n```\n\n## 迁移文章\n\n### 批量修改 frontmatter\n\n由于原先在 hexo 的文章有太多 valaxy 不支持的 frontmatter 项，所以需要批量修改它们，以免引起奇怪的问题\n\n由于文章数多，所以写个简单的脚本批量操作\n\n需要先安装 `python-frontmatter`\n\n```shell\npip3 install python-frontmatter\n```\n\n```python\nimport frontmatter\nimport glob\n\npath = 'posts' #你的文章路径，相对于该脚本\nmds = glob.glob(f'./{path}/*.md')\n\ndef del_metedata(md: str, key: str | list):\n    post = frontmatter.load(md)\n    metedata = post.metadata\n    try:\n        if isinstance(key, list):\n            for k in key:\n                try:\n                    del metedata[k]\n                except:\n                    continue\n        elif isinstance(key, str):\n            del metedata[key]\n        else:\n            raise TypeError('key 是 str 或 list')\n        frontmatter.dump(post, md)\n    except Exception as e:\n        print(f'{e} 在 {md}')\n\n\ndef add_metedata(md: str, key: str, value: str):\n    post = frontmatter.load(md)\n    metedata = post.metadata\n    try:\n        metedata[key] = value\n        frontmatter.dump(post, md)\n    except Exception as e:\n        print(f'{e} 在 {md}')\n\ndef main():\n    del_keys = [\n        #要删除的项，你可以根据需要修改\n        'toc',\n        'abbrlink',\n        'mathjax',\n        'author',\n        'hide',\n        'sitemap',\n        'indexing',\n        'top',\n        'password',\n        'summary',\n        'comments',\n        'reward',\n        'license',\n        'edit',\n        'copyright',\n        'sticky',\n        'description'\n    ]\n    for md in mds:\n        del_metedata(md,del_keys)\n        #添加你需要的项,如添加 layout: post\n        add_metedata(md, 'layout', 'post')\n\n\nif __name__ == '__main__':\n    main()\n```\n\n### 修改文章内图片路径\n\n如果你全站都使用的图床，可以忽略这一步。而我为了方便管理，把图片放在了本地，所以需要修改\n\n原先是在 hexo 的 source 目录下，需要使用相对路径引用。而 valaxy 可以**直接引用**静态文件夹(`public`)内的文件，直接使用 /xxxx 即可\n\n例如，我原先的图片路径是\n\n`../photos/post-pics/1.webp`\n\n那么只需要**将原先在 hexo 博客目录的 photos 文件夹移动到 valaxy 的 public 文件夹**下，然后将路径修改为\n\n`/photos/post-pics/1.webp`\n\n这里的修改可以使用 VSCode 的全局关键字替换功能\n\n### 移动文章\n\n把文章移动到 `博客文件夹/pages/posts` 下即可\n\n但是我在操作的时候发现，一次性塞进去太多文章会导致预览页面加载不出来，这可能是一个 bug (版本 0.12.2 )。当然构建是没问题的，所以如果你不需要本地预览的话，可以直接都丢进去。\n\n## 迁移友联页面\n\nvalaxy 的 yun 主题的友联页面在 pages/links/index.md，在 frontmatter 里配置就可以了，参考 [valaxy-theme-yun 文档](https://github.com/YunYouJun/valaxy/tree/main/packages/valaxy-theme-yun/docs/zh-CN)\n\n注意 frontmatter 的下面要写一个\n\n```html\n<YunLinks :links=\"frontmatter.links\" :random=\"frontmatter.random\" />\n```\n\n## 迁移 [girls](/girls/) 页面\n\n与 [hexo-theme-yun](https://yun.yunyoujun.cn/guide/page.html#girls) 的配置相同，但是 frontmatter 下面要加上\n\n```html\n<YunGirls :girls=\"frontmatter.girls\" :random=\"frontmatter.random\" />\n```\n\n~~哪来的二次元~~\n\n---\n\n这样就完成迁移了。如果有其他问题，或者需要更多信息，可以对比[云游君的博客仓库](https://valaxy.site/migration/hexo#%E7%A4%BA%E4%BE%8B)中 hexo 和 valaxy 分支的差异。或者提出 [issue](https://github.com/YunYouJun/valaxy/issues/new) 、提出[讨论](https://github.com/YunYouJun/valaxy/discussions/new/choose) ，以及在我博客下评论留言。\n"},{"title":"使用官方脚本一键安装docker|安装docker-compose","tags":["linux","docker"],"categories":"小技术","author":"柯罗krau","excerpt":"\n## 安装docker\n\ndocker官方提供了傻瓜式安装脚本，为你做好所有工作，免去了手动安装的繁琐。\n\n本文实测系统环境：debian11\n\n执行以下命令\n\n::: tip 2023-03-07更新\n\n不知道从什么时候开始官方脚本已经默认也安装了 `docker compose`,不需要后面的手动安装了\n\n注意是 `docker compose` 而不是 `docker-compose`. 执行命令时候也没有这个杠\n\n:::\n\n```shell\ncurl -fsSL https://get.docker.com | bash -s docker\n```\n","link":"/posts/install-docker-one-key","content":"\n## 安装docker\n\ndocker官方提供了傻瓜式安装脚本，为你做好所有工作，免去了手动安装的繁琐。\n\n本文实测系统环境：debian11\n\n执行以下命令\n\n::: tip 2023-03-07更新\n\n不知道从什么时候开始官方脚本已经默认也安装了 `docker compose`,不需要后面的手动安装了\n\n注意是 `docker compose` 而不是 `docker-compose`. 执行命令时候也没有这个杠\n\n:::\n\n```shell\ncurl -fsSL https://get.docker.com | bash -s docker\n```\n<!-- more -->\n可在此命令后附带`--mirror`参数设置镜像源，以提高国内服务器下载docker的速度\n\n**若登录linux的用户不是root，则需要docker的用户加入 docker 用户组。** 参考以下命令。\n\n```bash\nsudo groupadd docker # 建立docker用户组\nsudo usermod -aG docker $USER #将当前用户加入 docker 组\n```\n\ndone\n\n重新登录ssh终端，可执行以下命令测试是否正确安装docker\n`docker run hello-world`\n正确安装的输出信息如下：\n\n```bash\nUnable to find image 'hello-world:latest' locally\nlatest: Pulling from library/hello-world\nd1725b59e92d: Pull complete\nDigest: xxxxxxxxxxxxxxxx\nStatus: Downloaded newer image for hello-world:latest\n\nHello from Docker!\nThis message shows that your installation appears to be working correctly.\n\nTo generate this message, Docker took the following steps:\n 1. The Docker client contacted the Docker daemon.\n 2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub.\n    (amd64)\n 3. The Docker daemon created a new container from that image which runs the\n    executable that produces the output you are currently reading.\n 4. The Docker daemon streamed that output to the Docker client, which sent it\n    to your terminal.\n\nTo try something more ambitious, you can run an Ubuntu container with:\n $ docker run -it ubuntu bash\n\nShare images, automate workflows, and more with a free Docker ID:\n https://hub.docker.com/\n\nFor more examples and ideas, visit:\n https://docs.docker.com/get-started/\n ```\n\n## 安装docker-compose\n\n执行以下命令\n\n```shell\ncurl -L https://github.com/docker/compose/releases/download/v2.14.0/docker-compose-linux-`uname -m` > ./docker-compose\n```\n\n注释：\n\n- `uname -m`用于获取本机架构\n- 注意将`/2.14.0/`换成所需的版本号，可前往[docker-compose的仓库](https://github.com/docker/compose/releases)查看详情\n\n记得授予权限\n`chmod +x ./docker-compose`\n移动到正确路径\n`mv ./docker-compose /usr/local/bin/docker-compose`\n"},{"title":"Debian/Linux安装最新Python版本及多版本环境管理","tags":["Python","Linux"],"categories":"小技术","author":"柯罗krau","excerpt":"\nPython 的环境管理确实烦,而且会出现版本之间不兼容的情况,所以有必要知道如何安装不同版本的 Python 并管理其环境.\n\n本文系统环境为 Debian11, 虚拟环境工具使用的是 venv, 采用编译安装的方法. 截止此文创建时, Python 最新版本为 3.11.3\n\n","link":"/posts/install-manage-python-version-on-linux","content":"\nPython 的环境管理确实烦,而且会出现版本之间不兼容的情况,所以有必要知道如何安装不同版本的 Python 并管理其环境.\n\n本文系统环境为 Debian11, 虚拟环境工具使用的是 venv, 采用编译安装的方法. 截止此文创建时, Python 最新版本为 3.11.3\n\n<!-- more -->\n\n## 安装\n\n### 下载Python源码\n\n去往 [Python 官网](https://www.python.org/downloads/) 下载你想安装的版本的源码, 以目前最新的 Python3.11 为例\n\n![图 3](/photo/post-pics/install-manage-python-version-on-linux/install-manage-python-version-on-linux_04-13-15-38-10.webp)  \n\n使用 wget 下载:\n\n```shell\nwget https://www.python.org/ftp/python/3.11.3/Python-3.11.3.tar.xz\n```\n\n### 配置构建\n\n下载完成后, 将其解压:\n\n```shell\ntar -xf Python-3.11.3.tar.xz\n```\n\n安装必要的依赖软件:\n\n```shell\nsudo apt update\n\nsudo apt install build-essential zlib1g-dev libncurses5-dev \\\nlibgdbm-dev libnss3-dev libssl-dev libsqlite3-dev pkg-config \\\nlibreadline-dev libffi-dev curl libbz2-dev curl -y\n```\n\n进入 Python 源码文件夹, 并配置\n\n```shell\ncd Python-3.11.3\n./configure --enable-optimizations --with-lto\n```\n\n::: tip 注意\n`configure` 后的 `--enable-optimizations` `--with-lto` 两个参数是为了提高性能, 但它会使得 Python 编译过程变慢, 你可以选择不启用它们. 如果你遇到了问题, 可以尝试只开启 `--enable-optimizations`, 或者二者都不使用\n\n关于配置参数的更多信息, 可以参阅[官方文档](https://docs.python.org/zh-cn/3/using/configure.html)\n:::\n\n如果上面命令的输出没有错误, 那么就可以开始编译了.\n\n![图 4](/photo/post-pics/install-manage-python-version-on-linux/install-manage-python-version-on-linux_04-13-15-52-08.webp)  \n\n若提示缺少某个依赖, 请手动安装它\n\n### 编译安装\n\n运行 `make` 即可开始构建 Python , 若你有多个 cpu 核心, 可以加上 `-j` 参数来多核编译, `-j` 后是你的 cpu 核心数, 可以使用 `nproc` 获取\n\n若你机器的性能不佳, 这一过程可能十分漫长(几十分钟甚至更久), 你可以使用 screen 或 tmux 使其在后台运行\n\n![图 5](/photo/post-pics/install-manage-python-version-on-linux/install-manage-python-version-on-linux_04-13-15-57-12.webp)  \n\n完成后, 使用 `sudo make altinstall` 安装(可能也很漫长,但比上一步要快), 之后你就可以使用 Python3.11:\n\n![图 6](/photo/post-pics/install-manage-python-version-on-linux/install-manage-python-version-on-linux_04-13-16-21-43.webp)  \n\n```shell\npython3.11 --version\n```\n\n![图 7](/photo/post-pics/install-manage-python-version-on-linux/install-manage-python-version-on-linux_04-13-16-25-55.webp)  \n\n## 环境管理\n\n### 虚拟环境\n\n#### 创建\n\nPython 的虚拟环境可以将项目与全局环境相互隔离,可以避免污染你的系统环境,并方便得使多个 Python 版本共存与切换.\n\n本文使用的虚拟环境工具是 [venv](https://docs.python.org/3/library/venv.html) , 它是 Python 官方推荐的工具.\n\n但其实更现代的工具是 [poetry](https://python-poetry.org/) , 然而其使用比较复杂,且主要面向 pypl 模块开发者, 如有兴趣你可以自行了解.\n\n安装 venv:\n\n```shell\napt install python3-venv\n```\n\n使用以下命令在当前目录下创建虚拟环境:\n\n```shell\npython3.11 -m venv myenv\n```\n\n这个命令会在你当前目录下创建 `myenv` 文件夹, 它就是一个\"虚拟环境\", 其中包含了你所指定的 `Python3.11` 版本, 未来在虚拟环境中安装的第三方库等文件也会在此文件夹内.\n\n显然, 如果你想创建一个其他 Python 版本的虚拟环境, 那么只需要将前面的 `python3.11` 改成你需要的版本且已经安装的即可\n\n#### 使用\n\n创建完成后,要进入到虚拟环境,需要激活它,使用以下命令.\n\n```shell\nsource myenv/bin/activate\n```\n\n这时你的终端应该会有一些标识来提示你处在虚拟环境中,如下\n\n![图 10](/photo/post-pics/install-manage-python-version-on-linux/install-manage-python-version-on-linux_04-13-16-54-47.webp)  \n\n在虚拟环境中, `python` `python3.11` `python3` 命令都可以打开 python ,并且版本都是 python3.11\n\n在其中使用 pip 安装的包也都在虚拟环境中\n\n使用 `deactive` 命令可退出虚拟环境\n\n#### 删除\n\n使用 venv 工具创建的虚拟环境实际上就是一个文件夹, 删除它就是删除了环境\n\n### 默认版本\n\n始终建议使用官方软件源提供的 python 作为默认版本, 如果你真的想要替换默认版本, 那么可以使用下面的命令\n\n```shell\nsudo ln -sf /usr/bin/python3.11 /usr/bin/python\n```\n\n这条命令将 python3.11 的可执行文件链接到 linux PATH 的默认搜索路径中, 此时系统的默认版本就是 3.11\n\n::: tip\n即使默认版本就是你想要使用的 Python 版本, 你也应该在你的项目里创建虚拟环境, 除非你想把自己的系统环境搞得乱七八糟\n:::"},{"title":"使用Kotodama更优雅地管理waline评论系统后台","tags":["waline","博客"],"categories":"小技术","author":"柯罗krau","excerpt":"\n不少博主已经在用waline作为评论系统了吧，但是众所周知，waline的后台管理属实不能说是好用。无论是界面构建还是交互设计都有点复古陈旧的感觉。\n\n还好有[云游君](https://github.com/YunYouJun)开发了[kotadama](https://github.com/YunYouJun/kotodama)，适配了waline的后端管理。用它作为waline的后端管理再好不过。\n\n要使用kotadama，直接打开网址登录使用即可：<https://kotodama.vercel.app>\n\n","link":"/posts/kotodama","content":"\n不少博主已经在用waline作为评论系统了吧，但是众所周知，waline的后台管理属实不能说是好用。无论是界面构建还是交互设计都有点复古陈旧的感觉。\n\n还好有[云游君](https://github.com/YunYouJun)开发了[kotadama](https://github.com/YunYouJun/kotodama)，适配了waline的后端管理。用它作为waline的后端管理再好不过。\n\n要使用kotadama，直接打开网址登录使用即可：<https://kotodama.vercel.app>\n\n<!-- more -->\n\n以下是官方文档\n\n---\n\nkotodama 是一个纯静态的站点，您可以 fork 其自行部署，也可以直接使用已部署的 `kotodama.yunyoujun.cn` | `kotodama.vercel.app` 站点。\n\n> `kotodama.yunyoujun.cn` 纯静态托管于 GitHub Pages，代码将始终保持开源，不会也无法获取您的用户名密码，请放心使用。\n\n## Features\n\n- 💬 目前只适配 [Waline](https://github.com/walinejs/waline)（~~未来可能适配更多评论系统，假的~~）\n- ⚡️ [Vue 3](https://github.com/vuejs/vue-next), [Vite 2](https://github.com/vitejs/vite), [pnpm](https://pnpm.js.org/), [element-plus](https://github.com/element-plus/element-plus) - ([vitesse](https://github.com/antfu/vitesse/)) born for future\n\n## Waline\n\n- 适配 [Waline](https://github.com/walinejs/waline) 后台管理（开发中...）\n  - 已实现基础的登录、评论预览、翻页、删除功能\n  - Todo: 编辑评论、细节优化、GitHub 登录、批量删除、审核\n\n> More info see [#552 | Waline](https://github.com/walinejs/waline/issues/552)\n\n## 自行部署\n\n> 推荐直接使用 [kotodama.yunyoujun.cn](https://kotodama.yunyoujun.cn) 或 [kotodama.vercel.app](https://kotodama.vercel.app)。如果您不放心，也可以自行部署，但可能需要自己记得更新。\n\n```bash\n# fork 或直接 clone 本项目\ngit clone https://github.com/YunYouJun/kotodama\n\ncp .env.example .env\n```\n\n配置 `.env` 中的 `VITE_API_BASE_URL` 环境变量为您的 Waline 后台地址，例如 `https://waline.xxx.xxx`。\n\n### 自行构建\n\n```bash\n# 安装依赖\nnpm install\n\n# 构建产物\nnpm run build\n```\n\n将 `dist` 下的静态文件托管于您的服务器。\n\n### GitHub Actions\n\nFork 本项目。\n\n进入 `Settings/Pages` Source 设置 Branch 为 `gh-pages`，以启用 GitHub Pages。\n\n进入 `Actions`，触发 GitHub Page Workflow run。\n\n> `.github/workflows/gh-pages.yml` 文件将会自动触发构建，并将构建产物推送至 `gh-pages` 分支。\n\n如果您需要自定义域名，请修改项目中 `public/CNAME` 文件内容为您自己的域名。\n\n## FAQ\n\n### Waline 403 Authorization 错误\n\n如果您无法正常连接您的 Waline 后台 API，您可能需要配置一下安全域名。\n将 `kotodama.yunyoujun.cn` 添加至您的安全域名中。\n\n> [secureDomains | Waline](https://waline.js.org/reference/server.html#securedomains)\n"},{"title":"自己动手制作网线水晶头","tags":["DIY"],"categories":"小技术","author":"柯罗krau","excerpt":"\n我最近买了一台二手主机当nas用，但是由于我家的布局设置，必须要把这台主机放置在离路由器较远的一个位置。所以我直接买了根超长网线（指30m）以防长度不够，但是到手之后发现，我严重高估了我所需的长度，于是把这根长网线剪去一大段，并去学会了接网线水晶头的操作。\n\n","link":"/posts/make-cable","content":"\n我最近买了一台二手主机当nas用，但是由于我家的布局设置，必须要把这台主机放置在离路由器较远的一个位置。所以我直接买了根超长网线（指30m）以防长度不够，但是到手之后发现，我严重高估了我所需的长度，于是把这根长网线剪去一大段，并去学会了接网线水晶头的操作。\n\n<!-- more -->\n\n## 准备工具\n\n制作水晶头需要以下工具：\n\n1. 网线钳（某宝十块钱左右一个，还送一些水晶头和墙钉）\n2. 水晶头（买网线钳送）\n3. 剥线刀（买网线钳也送）\n\n所以实际上你只需要去某宝购买一个小套装即可。\n\n## 实操\n\n一般购买到的一根超长网线，两端是接好水晶头的，但是我们不需要这么长，所以截取你需要的长度，用剪刀剪下一端。\n\n![](/photo/post-pics/make-cable/make-cable_2022-06-20-22-37-16.webp)\n\n然后用剥线刀把这端的一段外皮剥去。\n把剥线刀在剥线位点上转一圈即可。\n![](/photo/post-pics/make-cable/make-cable_2022-06-20-22-38-39.webp)\n\n剥完皮是这样的\n\n![](/photo/post-pics/make-cable/make-cable_2022-06-20-22-39-25.webp)\n\n仔细观察，这根网线内有八根线，各自有着不同的颜色，尤其注意白线，它们带有的颜色也是不同的。这八根线色分别是 **橙白、绿白、蓝白、棕白、橙色、绿色、蓝色、棕色**。\n\n![](/photo/post-pics/make-cable/make-cable_2022-06-20-22-43-11.webp)\n\n![](/photo/post-pics/make-cable/make-cable_2022-06-20-22-43-20.webp)\n\n接下来把这八根线理顺好，用网线钳把它们剪成齐平。\n\n![](/photo/post-pics/make-cable/make-cable_2022-06-20-22-44-37.webp)\n\n然后理顺八根线的次序，如图（引用自淘宝某店铺）。\n\n![](/photo/post-pics/make-cable/make-cable_2022-06-20-22-46-03.webp)\n\n![](/photo/post-pics/make-cable/make-cable_2022-06-20-22-46-23.webp)\n\n再把线塞入水晶头，注意排列顺序与水晶头的正反。\n\n![](/photo/post-pics/make-cable/make-cable_2022-06-20-22-47-27.webp)\n\n最后用网线钳压下水晶头，听见咔哒声就算完成了。\n\n![](/photo/post-pics/make-cable/make-cable_2022-06-20-22-49-06.webp)\n"},{"title":"使用conda安装和管理python多版本环境","tags":["Python"],"categories":"小技术","author":"柯罗krau","excerpt":"\n~~感觉不如编译安装~~\n\n","link":"/posts/manage-python-version-by-conda","content":"\n~~感觉不如编译安装~~\n\n<!-- more -->\n\n## conda\n\nconda 是一个 python 的环境管理器, 它包含在 [Anaconda](https://www.anaconda.com/) 内, Anaconda 是专注于数据分析的Python发行版本.\n\n即使你没有数据分析\\科学计算的需求, 也可以使用 conda 这个强大的工具来管理 python 环境\n\n如果你不想安装这么大一个东西, 可以看我上次发的使用 [venv + 编译安装的方式管理python环境](./install-manage-python-version-on-linux.md)\n\n## 安装\n\n去[Anaconda官网](https://www.anaconda.com/products/distribution#Downloads)下载\n\n或者你可以选择 [Miniconda](https://docs.conda.io/en/latest/miniconda.html)\n\n```shell\nwget https://repo.anaconda.com/archive/Anaconda3-2023.03-Linux-x86_64.sh\n```\n\n下载完成后, 执行 `bash Anaconda3-2023.03-Linux-x86_64.sh` 即可开始安装\n\n安装完成后, 重启终端, 即可使用 conda\n\n## 使用\n\n更新\n\n```shell\nconda update --all \n```\n\n创建虚拟环境\n\n```shell\nconda create -n <name> python=<version>\n```\n\n-n 后是虚拟环境的名字, python=version 指定要使用的 python 版本\n\n激活环境\n\n```shell\nconda activate <name>\n```\n\n退出虚拟环境\n\n```shell\nconda deactivate\n```\n\n删除虚拟环境\n\n```shell\nconda env remove <name>\n```\n\n列出虚拟环境\n\n```shell\nconda env list\n```\n\n列出当前环境的包\n\n```shell\nconda list\n```\n\n安装包, 和 pip 一样\n\n```shell\nconda install <package>\n```\n"},{"title":"Minecraft开服入门","tags":["Minecraft","DIY","游戏","服务器"],"categories":"小技术","author":"柯罗krau","excerpt":"\n想和基友们联机玩mc，相比于使用各种联机平台，或搭建虚拟局域网，不如自己直接开个服务器。既不用保持至少一人在线，又能避免玩游戏时需要额外运行一个联机程序的臃肿。\n\n本文记录博主自己的mc开服经历。\n","link":"/posts/mc-host-server","content":"\n想和基友们联机玩mc，相比于使用各种联机平台，或搭建虚拟局域网，不如自己直接开个服务器。既不用保持至少一人在线，又能避免玩游戏时需要额外运行一个联机程序的臃肿。\n\n本文记录博主自己的mc开服经历。\n<!-- more -->\n\n## 工具选择与准备\n\n### 主机选择\n\n我起初有开mc服的计划时是还在上高三，没有详细了解各方面的信息，因此当时想拉上几个基友集资购买云主机，在云主机上开服。\n\n但高考完放假之后我去了解了一下云主机的价格，还是把原来的打算作废了。\n\n我的需求是让我的服务器 **安装一些大型模组并保证十人能同时在线不卡顿**。而显然价格相对低的轻量云主机（指几百块一年）难以满足。\n\n于是我决定在自己电脑上开服。但是用自己的主力机实在感觉不妥，一来它的高功耗会导致电费的额外支出，~~二来心疼它二十四小时不关机~~。\n\n最终，我决定再组一台**低功耗**主机，用来开设mc服务器的同时，还能当nas用。\n\n但是我发现，由于洋垃圾市场炒的厉害，分别购买cpu、主板、内存、硬盘配件，还不如直接购买二手整机来的划算。于是去海鲜市场（闲鱼）买了台整机。\n\n![](/photo/post-pics/mc-host-server/mc-host-server_1.webp)\n\n以T结尾的intel处理器代表低功耗，正适合作为服务器使用。\n\n到手之后重装了Windows10 LTSC，更新少，简洁、运行稳定。\n\n### 游戏版本选择\n\n游戏版本选择是我最纠结的地方，由于学业原因，我近乎三年没有碰mc，再回过来看的时候最新版本已经是1.19了，而且fabric似乎也流行了起来，越来越多的模组和资源包开始仅支持较高版本且仅兼容fabric，就连java的最新版本居然也到了17。但我更熟悉的是forge和旧版本。本想跟联机基友们共同商量，可他们也是什么都不知道。最终抱着延续初中的玩法的态度，选择了1.12.2这个时至今日已经是远古的版本。\n\n### 服务端软件选择\n\n由于我此前只有建设mc基岩版服的经验，当时基岩版只有官方服务端，所以也没有什么选择。\n\n但je（java edition）服务端不一样，各种服务端看的我眼花缭乱，最终草率地随大流，选择了[Catserver（猫端）](https://catmc.org/)这一使用人数众多的服务端。\n~~慎重？先开了再说，大不了redo~~\n\n## 开服\n\n选择好以上这些东西之后，就有了开服的方向，接下来的事情就很简单了，只需要动手去做就完事了。\n\n### 配置服务端\n\n#### 下载与初始化catserver服务端\n\n先在java官网，下载最新的java8。\n\n前往[catserver官网](https://catmc.org/)或[github仓库](https://github.com/Luohuayu/CatServer)下载所需版本的catserver。\n\n下载的是一个.jar单文件，把它重命名为Catserver.jar放入一个空文件夹，该文件夹名与路径尽量使用纯英文，避免出现奇怪的错误。\n\n在该空文件夹内，新建一个文本文档，并写入以下内容：\n\n```bat\njava -Xmx6G -XX:+UseG1GC -XX:+ParallelRefProcEnabled -XX:MaxGCPauseMillis=200 -XX:+UnlockExperimentalVMOptions -XX:+DisableExplicitGC -XX:+AlwaysPreTouch -XX:G1NewSizePercent=30 -XX:G1MaxNewSizePercent=40 -XX:G1HeapRegionSize=8M -XX:G1ReservePercent=20 -XX:G1HeapWastePercent=5 -XX:G1MixedGCCountTarget=4 -XX:InitiatingHeapOccupancyPercent=15 -XX:G1MixedGCLiveThresholdPercent=90 -Dfml.queryResult=confirm -jar CatServer.jar\n```\n\n这段内容的解释：\n\n-Xmx6G ：设定服务端最大内存为6G\n\n-XX等参数：开启G1GC和优化GC，[详见此贴](https://www.mcbbs.net/thread-1085422-1-1.html)\n\n然后把该文本重命名为strat.bat，双击运行该bat。\n\n之后，猫端会自动下载所需的文件，并释放到同目录下，这样就完成了服务端的初始化。初始化完成后的目录文件如下\n\n![](/photo/post-pics/mc-host-server/mc-host-server_2.webp)\n\n#### 修改服务端配置文件\n\n初始化完成后，需要修改以下几个文件\n\n- server.properties\n- bukkit.yml\n- catserver.yml\n- spigot.yml\n\n参考这两帖，根据需求进行修改。\n\n[ [服务器应用] 【优化】服务器优化指南 | 和卡顿永远说再见 ](https://www.mcbbs.net/forum.php?mod=viewthread&tid=774469)\n\n[ [服务器应用] Minecraft服务器优化教程 —— 让多带50%的玩家不再是梦 ](https://www.mcbbs.net/forum.php?mod=viewthread&tid=478126)\n\n下面是我修改后的配置文件\n\n- server.properties\n\n```ini\n#Minecraft server properties\n#Sun Jun 19 19:24:15 CST 2022\nspawn-protection=16\nmax-tick-time=60000\ngenerator-settings=\nforce-gamemode=false\nallow-nether=true\ngamemode=0\nbroadcast-console-to-ops=true\nenable-query=false\nplayer-idle-timeout=0\ndifficulty=2\nspawn-monsters=true\nop-permission-level=4\npvp=true\nsnooper-enabled=true\nlevel-type=DEFAULT\nhardcore=false\nenable-command-block=true\nmax-players=10\nnetwork-compression-threshold=-1\nresource-pack-sha1=\nmax-world-size=29999984\nserver-port=25565\nserver-ip=0.0.0.0\nspawn-npcs=true\nallow-flight=true\nlevel-name=world\nview-distance=8\nresource-pack=\nspawn-animals=true\nwhite-list=true #开启白名单\ngenerate-structures=true\nonline-mode=flase #关闭正版验证\nmax-build-height=256\nlevel-seed=\nprevent-proxy-connections=false\nenable-rcon=false\nmotd=fish world\n```\n\n- bukkit.yml\n\n```yaml\nsettings:\n  allow-end: true\n  warn-on-overload: true\n  permissions-file: permissions.yml\n  update-folder: update\n  plugin-profiling: false\n  connection-throttle: 4000\n  query-plugins: true\n  deprecated-verbose: default\n  shutdown-message: Server closed\nspawn-limits:\n  monsters: 50\n  animals: 15\n  water-animals: 5\n  ambient: 3\nchunk-gc:\n  period-in-ticks: 400\n  load-threshold: 300\nticks-per:\n  animal-spawns: 400\n  monster-spawns: 2\n  autosave: 6000\naliases: now-in-commands.yml\n```\n\n- catserver.yml\n\n```yaml\nworld:\n  keepSpawnInMemory: false\n  enableSkipEntityTick: true\n  enableSkipTileEntityTick: false\n  worldGenMaxTick: 15\n  disableForgeGenerateWorlds:\n  - ExampleCustomWorld\n  preventBlockLoadChunk: false\n  autoUnloadDimensions:\n  - 99999999\n  enableRealtime: true\n  forceSaveOnWatchdog: true\n  maxEntityCollision: 8\n  saveBukkitWorldDimensionId: true\nfakePlayer:\n  permissions:\n  - essentials.build\n  eventPass: false\nvanilla:\n  fixPlayBossSoundToOtherWorld: true\n  fixLessCrystalRespawnDragon: false\n  preventPistonPushRail: false\n  preventPistonPushSlimeBlock: false\n  limitFastClickGUI: false\nplugin:\n  patcher:\n    enableDynmapCompatible: true\n    enableCoreProtectModBlockCompatible: true\n    enableEssentialsNewVersionCompatible: true\n    enableMythicMobsPatcherCompatible: true\n    enableWorldEditCompatible: true\n    enableCitizensCompatible: true\n  disableHopperMoveEventWorlds: []\n  defaultInstall:\n    spark: true\nasync:\n  waitForgeServerChatEvent: false\nsecurity:\n  opManager: false\n  gameModeManager: false\ndisableUpdateGameProfile: false\ndisableFMLHandshake: false\ndisableFMLStatusModInfo: false\ndisableAsyncCatchWarn: false\nversionCheck: true\n```\n\n- spigot.yml\n\n```yaml\nconfig-version: 11\nsettings:\n  debug: false\n  attribute:\n    maxHealth:\n      max: 2048.0\n    movementSpeed:\n      max: 2048.0\n    attackDamage:\n      max: 2048.0\n  netty-threads: 4\n  timeout-time: 60\n  restart-on-crash: true\n  restart-script: ./start.sh\n  moved-too-quickly-multiplier: 10.0\n  moved-wrongly-threshold: 0.0625\n  filter-creative-items: true\n  bungeecord: false\n  sample-count: 12\n  late-bind: false\n  int-cache-limit: 1024\n  item-dirty-ticks: 20\n  user-cache-size: 1000\n  player-shuffle: 0\n  save-user-cache-on-stop-only: false\nmessages:\n  whitelist: You are not whitelisted on this server!\n  unknown-command: Unknown command. Type \"/help\" for help.\n  server-full: The server is full!\n  outdated-client: Outdated client! Please use {0}\n  outdated-server: Outdated server! I'm still on {0}\n  restart: Server is restarting\nstats:\n  disable-saving: false\n  forced-stats: {}\ncommands:\n  log: true\n  replace-commands:\n  - setblock\n  - summon\n  - testforblock\n  - tellraw\n  spam-exclusions:\n  - /skill\n  silent-commandblock-console: false\n  tab-complete: 0\nadvancements:\n  disable-saving: false\n  disabled:\n  - minecraft:story/disabled\nworld-settings:\n  default:\n    verbose: true\n    merge-radius:\n      item: 2.5\n      exp: 3.0\n    arrow-despawn-rate: 1200\n    wither-spawn-sound-radius: 0\n    nerf-spawner-mobs: false\n    entity-tracking-range:\n      players: 48\n      animals: 48\n      monsters: 48\n      misc: 32\n      other: 64\n    view-distance: 10\n    enable-zombie-pigmen-portal-spawns: true\n    zombie-aggressive-towards-villager: true\n    item-despawn-rate: 6000\n    hanging-tick-frequency: 100\n    growth:\n      cactus-modifier: 100\n      cane-modifier: 100\n      melon-modifier: 100\n      mushroom-modifier: 100\n      pumpkin-modifier: 100\n      sapling-modifier: 100\n      wheat-modifier: 100\n      netherwart-modifier: 100\n      vine-modifier: 100\n      cocoa-modifier: 100\n    entity-activation-range:\n      animals: 32\n      monsters: 28\n      misc: 16\n      tick-inactive-villagers: true\n    random-light-updates: false\n    ticks-per:\n      hopper-transfer: 8\n      hopper-check: 1\n    hopper-amount: 1\n    save-structure-info: true\n    hunger:\n      jump-walk-exhaustion: 0.05\n      jump-sprint-exhaustion: 0.2\n      combat-exhaustion: 0.1\n      regen-exhaustion: 6.0\n      swim-multiplier: 0.01\n      sprint-multiplier: 0.1\n      other-multiplier: 0.0\n    max-tick-time:\n      tile: 50\n      entity: 50\n    squid-spawn-range:\n      min: 45.0\n    max-tnt-per-tick: 100\n    mob-spawn-range: 4\n    dragon-death-sound-radius: 0\n    seed-village: 10387312\n    seed-feature: 14357617\n    seed-monument: 10387313\n    seed-slime: 987234911\n```\n\n#### 在服务端安装模组和插件\n\n在服务端中，有mods和plugins两个文件夹，它们分别是游戏模组和服务端插件。\n\n游戏模组是增强和丰富游戏内容的，而服务端插件是增强服务端功能的。\n\n需要安装的模组，都放在mods文件夹内。\n\n在安装模组时，要看清模组是否需要在服务端安装，不需要在服务端安装的模组不要安装在服务端。（如waila高亮显示等模组）\n\n![](/photo/post-pics/mc-host-server/mc-host-server_3.webp)_服务端需要装\n\n![](/photo/post-pics/mc-host-server/mc-host-server_4.webp)_不要在服务端装\n\n另外在安装模组时，还要留心查看该模组的说明，有些模组需要额外的前置模组，要一起安装（如植物魔法botania需要bauble作为前置模组，二者必须都安装）\n以下是我在服务端安装的模组\n\n![](/photo/post-pics/mc-host-server/mc-host-server_5.webp)\n\n而服务端插件直接放如plugins文件夹即可，可以根据需要去搜索。我曾经安装了[miraimc](https://github.com/DreamVoid/MiraiMC)插件，它是一个能双向同步mc服务器和qq群消息的插件，但由于性能和兼容性问题又把它移除了。目前我只安装了一个luckperm插件，用来管理玩家权限（如单独给玩家tp权限而不给op管理员身份）\n\n#### 设定op、添加白名单\n\n服务端启动完成后，直接在服务端控制台窗口可运行指令（包括游戏内的指令，如 time set）\n\n执行`op <玩家名>`可赋予玩家op\n\n执行`whitelist add <玩家名>`可为玩家添加白名单\n\n注意在控制台窗口输入命令时，都不带`/`\n\n### 配置客户端、制作整合包\n\n客户端即是玩家端，可以选择任意一款启动器，制作整合包发给发给玩家，而我选择的是HMCL这个老牌启动器，版本为3.5.3\n\n下载游戏本体\n![](/photo/post-pics/mc-host-server/mc-host-server_6.webp)\n\n然后把所安装的模组放入游戏目录的mods文件夹\n\n可以使用[litteskin](https://littleskin.cn)，为游戏增加自定义皮肤支持，同时还需要安装customskinloader 模组。\n\n然后启动游戏，在多人游戏中添加搭建的服务器，退出即可。\n\n之后在hmcl中，选择导出整合包，导出时，勾选多人服务列表一起导出。为了以后更新方便，我还构建了服务器自动更新整合包，在hmcl启动器中和mcbbs上均有相关教程。\n参考\n[Nginx 下配置 HMCL 自动更新整合包](https://lo-li.cc/2021/03/11/Nginx%E4%B8%8B%E9%85%8D%E7%BD%AEHMCL%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0%E6%95%B4%E5%90%88%E5%8C%85)\n\n由于构建步骤相对繁琐，我也会另写一篇文章记录。\n\n把制作好的整合包发给玩家后，若使用的是云主机，就可以直接开始联机游戏了。但我用的是自己的主机，其他非内网玩家是无法访问我的服务器的，所以还需要进行端口映射和ddns配置（或内网穿透）\n\n### 使外部网络可访问服务器\n\n我的路由器支持花生壳的ddns，所以我采用了端口映射+ddns的方法。\n\n在路由器管理页面，进行如下配置映射端口（默认端口为25565，可在服务端配置文件server.properties中更改）\n\n![](/photo/post-pics/mc-host-server/mc-host-server_7.webp)\n\n然后登陆花生壳ddns账号，这样外部网络便可以访问局域网中的mc服务器了。\n\n若路由器没有内置任何ddns的支持，还可以在服务器的主机上使用[ddns-go](https://github.com/jeessy2/ddns-go)程序。\n"},{"title":"往事 · 小狗","tags":["记忆"],"categories":"日常","author":"柯罗krau","excerpt":"\n忘了具体是在小学几年级的时候，家里抓回来了两三只小狗。也忘了是从哪里抓回来的，是怎么抓回来的，只依稀记得它们似乎没有妈妈。\n\n它们不到一个月大，身上都是白色的毛，就像当时冬季的雪，惹人可爱又可怜。爸","link":"/posts/memory-dog","content":"\n忘了具体是在小学几年级的时候，家里抓回来了两三只小狗。也忘了是从哪里抓回来的，是怎么抓回来的，只依稀记得它们似乎没有妈妈。\n\n它们不到一个月大，身上都是白色的毛，就像当时冬季的雪，惹人可爱又可怜。爸爸找来一个箱子，垫上了好几层棉花，为它们做成了一个小窝。可是妈妈见了之后，说“它们养不活”。理由是太小了，又没有母狗，天这么冷，它们会冻死。\n\n天真的我不服气，我想我一定能把它们好好养大的，成为活蹦乱跳的小狗。\n\n但是它们真的太柔弱了。那个小窝根本不能让它们暖和起来，蜷缩在箱子里的身体还是几乎冻僵。于是爸爸又用一个瓶子装上热水，垫到了棉花下面。水的热量又让它们有了一些生机，小脑袋又开始扭动起来，寻找母乳。我以为这样子能让它们撑过冬季。\n\n只过了两天，它们短暂的生命终结在了寒冬。\n\n那是我放学回来，迫不及待地去看看它们的状态，它们已经没有了动静，身上冰冷，但还有微弱的呼吸。我慌忙去取热水，想像爸爸做的那样，使它们暖和起来。可是水壶里没有热水。\n\n这时妈妈过来了，看见那几只奄奄一息的小狗，便要埋了它们。“它们还有呼吸呢！”，我抗议起来，但妈妈已经在院子里的老杏树下面为它们掘墓。\n\n我找到给它们喂奶用的奶瓶，抵在它们的嘴边，可是没有任何反应。我清楚的记得那时我一直在小声呼喊“快喝啊，张开嘴啊”，不知道是自言自语还是呼唤这几只狗的生命。\n\n它们终究还是被埋在了覆着白雪的杏树下，带着一丝微弱的呼吸和冻僵的身躯，以及被我的泪水打湿的白毛。"},{"title":"ray-mmd渲染基本流程","tags":["3D","MMD"],"categories":"小技术","author":"柯罗krau","excerpt":"\n![preview](https://pic.downk.cc/item/5f119a0214195aa59417256d.png)\n","link":"/posts/mmdray-basic-rendering","content":"\n![preview](https://pic.downk.cc/item/5f119a0214195aa59417256d.png)\n<!-- more -->\n\n## Download\n\n前往[github](https://github.com/ray-cast/ray-mmd)下载最新版ray mmd\n注意：不仅仅是打包下载code就完事的，还需要去下载各项扩展（详见github仓库下的readme）\n\n![](https://pic.downk.cc/item/5f116ea214195aa5940a510c.jpg)\n\n下载完成后解压ray和各个扩展，把扩展文件分别复制到ray主目录中对应的文件夹中\n\n## 渲染基本流程\n\n载入人物，场景等数据后，就可以开始ray渲染了\n但在这之前，还需要在mmd显示菜单中，关闭地面阴影显示，抗锯齿和各向异性过滤\n![](https://pic.downk.cc/item/5f11705414195aa5940ae29c.jpg)\n*因为ray是自带抗锯齿和阴影的，如果不关则会导致一些难以名状的画面和性能问题*\n\n第一步需要向mmd中丢入ray根目录下的ray.x和ray_controller.pmx，这两个分别是ray环境和ray控制器\n\n![](https://pic.downk.cc/item/5f1171fa14195aa5940b7b3b.jpg)\n\n然后放入ray/skybox目录下的任意一个天空盒，它应该是以.pmx为后缀的文件。\n此处以**Time of day**为例。\n丢入之后在背景>模型描绘顺序中调整人物，场景，和skybox的顺序\n这三个的正确相对顺序应为\n\nskybox\nstage（场景）\nmodel（人物）\n\n![](https://pic.downk.cc/item/5f11739b14195aa5940c0ba1.jpg)\n\n然后在右上角MMEffect中添加渲染\n\n在mian栏中，为场景和人物添加main文件夹内的main.fx（主渲染）\n![](https://pic.downk.cc/item/5f1174ee14195aa5940c6dbe.jpg)\n\n在Envlightmap（环境）栏中，为skybox添加渲染\n![](https://pic.downk.cc/item/5f11767114195aa5940d1714.jpg)\n\n在Fogmap（雾气）栏中，为skybox添加雾气效果渲染\n![](https://pic.downk.cc/item/5f1177b014195aa5940d801d.jpg)\n*用方框框起来的三个均为fogmap对应的渲染，只需要选择一个添加就可以，一般选择Time of fog with godray with cloud caster（名字越长越nb）*\n\n在materials栏中，为skybox渲染正确的材质\n![](https://pic.downk.cc/item/5f119aac14195aa59417535e.jpg)\n\n至此，再稍微调整一下打光和一些参数，就算完成了ray渲染的最基本步骤，现在的画面相较于未渲染的画面已经耐看多了\n\nbefore：\n![](https://pic.downk.cc/item/5f119e2914195aa5941855c6.jpg)\n\nnow：\n![](https://pic.downk.cc/item/5f119d2814195aa594180924.jpg)\n\n但这只是最基本的套用渲染的流程，相较于无渲染也就是从看不了提升为了勉强能看，要想做出真正好康的mmd，仅仅这些是完全不行的\n\n对于接触mmd时间不长的新手来说，没必要去详细了解每个概念，需要的是自己不断尝试，去感受那些渲染功能的具体作用。所以一开始更好的学mmd方法是，什么都不管，跟着做就好了。\n"},{"title":"ray-mmd制作法线贴图","tags":["MMD","3D"],"categories":"小技术","author":"柯罗krau","excerpt":"\n如何使材质贴图更有层次感？\n\n这就需要制作相应的[法线贴图](https://zh.wikipedia.org/wiki/%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE)\n本文以YYB式初音未来为例，制作相应的法线贴图，使用ray渲染的版本为1.5.2\n\n","link":"/posts/mmdray-normal-map","content":"\n如何使材质贴图更有层次感？\n\n这就需要制作相应的[法线贴图](https://zh.wikipedia.org/wiki/%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE)\n本文以YYB式初音未来为例，制作相应的法线贴图，使用ray渲染的版本为1.5.2\n\n<!-- more -->\n\n---\n\n在制作法线贴图之前，首先要在MMD导入相应的模型，并完成ray渲染的基本流程，方便以下的对比操作，以寻找合适的参数。\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20210813091507.png)\n\n在模型的目录中，找到需要制作的贴图，文件夹名一般为`Texture`\n\n然后使用ps导入贴图，选择滤镜>3D>生成法线图\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20210813093103.png)\n\n导出为png格式，文件名应是英文\n\n在`~/ray-mmd-1.5.2/Materials`目录中，找到`material_2.0.fx`、`material_common_2.0.fxsub`两个文件，复制到模型目录中的材质贴图文件夹\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20210813093713.png)\n\n然后重命名`material_2.0.fx`文件为`{你所导出的法线贴图的文件名}.fx`\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20210813094047.png)\n\n打开重命名后的该fx文件，在第28行左右找到`#define NORMAL_MAP_FROM 0`，将0修改为1以启用法线贴图。并更改`#define NORMAL_MAP_FILE \"normal.png\"\n`中的\"normal\"为法线贴图文件名\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20210813094408.png)\n\n然后保存，在mmd中，在`MaterialMap`栏中，展开所修改的模型，找到对应的贴图，为其添加法线贴图效果\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20210813094739.png)\n\n此时可以对照mmd中的效果调整fx文件中的参数，修改参数后保存文件，即可在mmd中预览到效果。\n\n几个参数的作用：\n\n- const float normalMapScale = 1.0;\n法线效果强度，该参数越大，层次感越明显（下图为将该参数设置为5.0的效果）\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20210813095248.png)\n\n- #define SMOOTHNESS_MAP_TYPE 0\n法线效果平滑度，该参数越大，发现效果显示越平滑，同时颗粒感与湿润感也会更强（多用于场景）\n\n---\n\ntips：\n\n1. 如果需要为同一模型的多个材质贴图添加法线贴图效果，只需要为每个法线贴图复制一个`material_2.0.fx`文件，并重命名为对应的文件名，而`material_common_2.0.fxsub`只在材质文件夹中保留一份即可\n2. 场景制作法线贴图与人物模型同理，但参数的调整与人物模型区别较大，需根据不同的需求进行尝试\n"},{"title":"MMD中导出带alpha通道视频的方法","tags":["MMD","3D"],"categories":"小技术","author":"柯罗krau","excerpt":"\n## 前言\n\n 闲来无事在摸MMD，然后看到了这个\n\n [【PV背景配布/动作配布】九尾三妈式初音 - お気に召すまま\n](https://www.bilibili.com/video/BV1r74","link":"/posts/mmdray-output-videos-with-alpha","content":"\n## 前言\n\n 闲来无事在摸MMD，然后看到了这个\n\n [【PV背景配布/动作配布】九尾三妈式初音 - お気に召すまま\n](https://www.bilibili.com/video/BV1r7411u7ST)\n\n感觉这个配布的挺不错，想摸一个。\n但是碰到点问题：60fps的背景是单独的视频，需要通过后期软件把人物和背景的视频叠加起来，这就要一个带有alpha通道（透明）的人物视频，去网上找了一些方法，依旧踩了不少坑。\n\n## 通过一个MME实现\n\n找了很多方法，感觉就这个最简单方便。\n首先去下载这个MME：<https://bowlroll.net/file/27004>\n这个MME可以让你随心所欲的加花里花哨的全局MME，而不会丢失透明通道\n\n下载之后**保持乱码状态解压**\n\n然后在`RewriteAlpha`文件夹中，往MMD里加入这个`RewriteAlpha.x`\n\n在MMD>背景>绘制附件中，把`RewriteAlpha.x`放到最后一位\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200407205316.png)\n\n然后打开MME面板，找到`alphamap`栏，把skybox和stage的渲染关闭（取消勾选），人物模型的渲染开启，并勾选上RewriteAlpha.x的渲染\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200407205639.png)\n\n这样就算完成了，导出的时候将会导出只有人物渲染，且背景是透明通道的视频，也可以先导出一张png看看效果。~~别渲染了半天发现不是透明通道，问就是血泪史~~\n\n![](https://img.asnet.top/i/2020/04/07/yrrxxj.png)\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/alphammd.png)\n"},{"title":"ray-mmd内置天空盒调整参数简介","tags":["MMD","3D"],"categories":"小技术","author":"柯罗krau","excerpt":"\n完成ray渲染的基本流程后，就要开始调各种参数了，本篇介绍ray渲染内置的几个天空盒的参数\n![内置天空盒](https://cdn.jsdelivr.net/gh/voidoath/photo/b","link":"/posts/mmdray-skyboxs","content":"\n完成ray渲染的基本流程后，就要开始调各种参数了，本篇介绍ray渲染内置的几个天空盒的参数\n![内置天空盒](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20210812200556.png)\n\n在`模型操作`栏中，选择导入的天空盒，在表情栏即可进行其相关参数调整。\n\n以下介绍中，把表情四栏按从左到右，从上到下分成 第一栏、第二栏、第三栏、第四栏。\n\n## Helipad GoldenHour\n\n### 第一栏\n\n- Balance\n可以看到该栏中有BalanceR+-/G+-/B+-以及Gray+的调整，它们即对应色调红绿蓝（RGB）三色以及灰色的调整。\n例如，调高BalanceR+栏，画面将偏红色\n\n### 第二栏\n\n- EnvDiffLight\n该参数为天空盒的光源强度，调高该参数，天空盒对模型的影响将会变亮\n- EnvSpecLight\n该参数为漫反射强度，调高该参数，模型漫反射增强\n\n### 第三栏\n\n- Diffuse\n该栏调整漫反射色调（RGB&Gray）\n\n### 第四栏\n\n- Specular\n该栏调整镜面反射色调（与Diffuse同理）\n\n## Sky Hemisphere\n\n该天空盒初始为纯白背景，一般适用于实景合成/唯美风渲染\n\n### 第一栏\n\n- Top\n可以看到该栏中有TopH+/S+/V+-，它们调整该天空盒的顶部色调效果\n\n### 第二栏\n\n- Medium\n与第一栏同理，调整中部色调\n\n### 第三栏\n\n- Bottom\n与上同理，调整底部色调\n\n### 第四栏\n\n- EnvDiffLight\n该参数为天空盒的光源强度，调高该参数，天空盒对模型的影响将会变亮\n- EnvSpecLight\n该参数为漫反射强度，调高该参数，模型漫反射增强\n\n## Sky Night\n\n该天空盒与`Sky Hemisphere`几乎一样，区别是该天空盒带有夜晚的月亮和流星效果\n\n## Time of day\n\n### 第一栏\n\n- SunRadius\n调整太阳半径大小\n\n### 第二栏\n\n- EnvDiffLight\n该参数为天空盒的光源强度，调高该参数，天空盒对模型的影响将会变亮\n- EnvSpecLight\n该参数为漫反射强度，调高该参数，模型漫反射增强\n\n### 第三栏\n\n- MiePhase\n该参数可以影响丁达尔效应的强弱\n- FogRange\n调整雾气距离\n- FogIntensity\n该参数可以影响雾气效果强度\n\n### 第四栏\n\n- Cloud\n云的密度，调高该参数，云将增多\n- CloudSpeed\n云的流动速度\n\n## Time of night\n\n该天空盒具有夜间星空银河与流星效果，参数调整与`Time of day`基本一致。\n区别是该天空盒第四栏的参数为影响星星的效果\n"},{"title":"将旧手机通过Linuxdeploy改造为linux服务器|搭建cloudreve个人网盘|实现离线下载","tags":["linux","DIY"],"categories":"小技术","author":"柯罗krau","excerpt":"\n最近因疫情闲在家，就折腾起了自己的旧手机\n\n","link":"/posts/old-phone-become-server","content":"\n最近因疫情闲在家，就折腾起了自己的旧手机\n\n<!-- more -->\n\n## 准备\n\n1. 一部已经获得root权限的手机 ~~若是ov华等无法获取root的手机，建议拿去换盆~~ ，本文以redmi note7 pro为例，已刷机安卓11类原生\n2. 一台能够使用ssh终端的设备\n\n## 安装linuxdeploy并配置\n\n下载[linuxdeploy](https://github.com/meefik/linuxdeploy/releases)，安装到旧手机\n\n>请确保安装的linuxdeploy版本≥2.0，否则需要首先安装busybox。而2.0以上的linuxdeploy内置了busybox\n\n打开linuxdeploy软件，点击左上角按钮，选择设置，勾选【锁定wi-fi】与【CPU唤醒】，其他选项按需配置，亦可保持默认\n\n回到上一级页面，点击右下角按钮，进行以下配置：\n\n## 配置\n\n### 引导设置\n\n- 【发行版GNU/Linux】 建议选择Debian或centos，它们在linuxdeploy运行的兼容性更好\n- 【架构】一般都选择arm64（Debian）或aarch64（centos），软件也会自动识别适合你的手机的架构，若特殊情况请搜索关键词 ‘{你手机的cpu}+架构’\n- 【发行版GNU/Linux版本】按需选择，一般选择buster或stable\n- 【源地址】建议改为以下地址：<http://mirrors.163.com/debian> ，保持默认亦可\n- 【安装类型】按需设置，建议选择镜像文件，因为它是一个单镜像文件\n- 【安装路径】默认为`${EXTERNAL_STORAGE}/linux.img`，一般保持默认即可\n- 【镜像大小】按需设置，若需搭建网盘服务，建议设置较大大小，可以使文件有足够的空间存储在linux镜像空间内，省去挂载手机存储的麻烦\n- 【文件系统】ext4\n- 【用户名】自行设置，建议设置为 root\n- 【用户密码】自行设置\n- 【特权用户】按需设置，一般保持默认\n- 【本地化】简体中文选择zh_CN.UTF-8，按需设置\n- 【DNS】按需设置，或保持默认\n\n### 初始化\n\n- 【启用】勾选以启用初始化功能\n- 【初始化系统】选择sysv\n- 【初始化设置】视情况设置，或保持默认\n\n### 挂载\n\nSource：手机目录\nTarget：Linux目录\n使用能够查看到真实路径的文件浏览器，复制需要挂载的目录到挂载点列表，填入第一行即可\n\n### SSH\n\n务必勾选启用SSH服务器，SSH设置按需配置\n\n### 声音服务\n\n按需配置\n\n### 图形界面\n\n按需配置\n\n---\n\n配置完成后，返回上一级，点击右上角按钮，点击安装，等待出现`<<< deploy`即安装完成。\n\n点击停止按钮并确定，再点击启动，出现`<<< start`即启动成功\n\n然后即可使用同一局域网下的ssh工具连接\n为了防止旧手机的内网ip地址变更，在路由设置页面进行ip与MAC绑定，并把手机wifi连接中的隐私设置相关选项改为 使用设备MAC\n\n连接后，使用以下命令安装常用工具\n\n`apt install wget vim curl zip -y`\n\n附：\n卸载命令\n`sudo apt-get --purge remove`\nxshell工具家庭/学校版下载连接\n<https://www.xshell.com/zh/free-for-home-school/>\n\n## 安装并配置cloudreve\n\n项目发行地址：[cloudreve](https://github.com/cloudreve/Cloudreve/releases)\n截止到撰写本文（2022.01），最新版本为3.4.2\n\n执行以下命令\n\n切换到用户目录\n\n`cd /opt`\n\n创建文件夹并切换\n\n`mkdir cloudreve&&cd cloudreve`\n\n下载cloudreve\n\n`wget https://github.com/cloudreve/Cloudreve/releases/download/3.4.2/cloudreve_3.4.2_linux_arm64.tar.gz`\n\n根据需求自行选择下载的版本并替换wget后的链接\n\n解压\n`tar -zxvf cloudreve_3.4.2_linux_arm64.tar.gz`\n赋予权限\n`chmod +x ./cloudreve`\n启动\n`./cloudreve`\n\n在终端中会给出初始管理员账号与密码，使用该账号登录<http://{服务器内网ip}:{port(default> is 5212)}\n若无法访问，考虑配置防火墙开放端口\n\n进入cloudreve后，点击右上角头像，进入管理面板，即可进行相关设置，具体参见[cloudreve官方文档](https://docs.cloudreve.org/)\n\n需要注意的是，在配置使用本机存储策略的用户组时，若存储目录在镜像空间内，要确保【初始容量】小于【镜像大小】，否则会无法上传任何文件\n\n## 通过aria2实现离线下载\n\ncloudreve内置了依赖于aria2的离线下载功能，因此需先进行aria2的配置\n\n### 安装并配置aria2\n\n安装\n`apt install aria2 -y`\n下载由[P3TERX](https://github.com/P3TERX)提供的aria2配置文件（亦可选择其他配置或参考[aria2官方文档](https://aria2.github.io/)自行创建）\n\n```shell\ncd\nwget https://github.com/P3TERX/aria2.conf/archive/master.zip\nunzip master.zip\n```\n\n将解压出的文件夹重命名为.aria2\n`mv aria2.conf-master .aria2`\n修改aria2配置文件\n`cd .aria2&&vim aria2.conf`\n[P3TERX](https://github.com/P3TERX)的配置文件包含了中文注释，根据注释按需修改即可，一般需要改动的是**下载目录**、**RPC密钥**与**BT监听端口**，其他保持默认即可\n\n配置修改完成后，在.aria2目录内，执行`./tracker.sh`即可更新tracker\n若更新失败，可进行手动更新，参考以下tracker列表\n<https://trackerslist.com/all_aria2.txt>\n将列表内容复制到`aria2.conf`中的`bt-tracker`参数后即可\n\n创建aria2.session文件\n`touch aria2.session`\n\n测试aria2能否成功启动\n`aria2c --conf-path=/root/.aria2/aria2.conf`\n第一次启动需要指定配置文件，日后启动只需使用`aria2c`即可\n\n若启动成功，关闭即可，接下来进行进程保护配置，方便后续操作\n\n### 守护cloudreve与aria2进程\n\ncloudreve与aria2运行后，若关闭ssh终端，二者也会随之停止运行，因此需要进行进程守护，本文是使用 `supervisor`\n\n安装\n\n```shell\napt install python-setuptools -y\napt install supervisor -y\n```\n\n#### 保护cloudreve进程\n\n为cloudreve创建配置并打开配置文件\n`sudo vim /etc/supervisor/conf.d/cloudreve.conf`\n\n将以下内容按需修改后，写入cloudreve的supervisor配置文件，具体参见[supervisor官方文档](http://supervisord.org/configuration.html)\n\n```ini\n[program:cloudreve]\ndirectory=/opt/cloudreve\ncommand=/opt/cloudreve/cloudreve\nautostart=true\nautorestart=true\nstderr_logfile=/var/log/supervisor/cloudreve.err\nstdout_logfile=/var/log/supervisor/cloudreve.log\nenvironment=CODENATION_ENV=prod\n```\n\n以上内容备注：\n程序目录=/opt/cloudreve\n运行命令(绝对路径)=/opt/cloudreve/cloudreve\n自启动=true\n自动重启=true\n错误日志保存路径=\n其他日志保存路径=\n环境=\n\n#### 保护aria2进程\n\n与上同理，但为保证叙述清楚以及按需查阅，分别具体叙述\n为aria2创建配置并打开配置文件\n`sudo vim /etc/supervisor/conf.d/aria2.conf`\n将以下内容按需修改后，写入aria2的supervisor配置文件，具体参见[supervisor官方文档](http://supervisord.org/configuration.html)\n\n```ini\n[program:aria2]\ndirectory=/root/.aria2\ncommand=aria2c --conf-path=/root/.aria2/aria2.conf\nautostart=true\nautorestart=true\nstderr_logfile=/var/log/supervisor/aria2.err\nstdout_logfile=/var/log/supervisor/aria2.log\nenvironment=CODENATION_ENV=prod\n```\n\n以上内容备注：\n程序目录=/root/.aria2\n运行命令(绝对路径)=aria2c --conf-path=/root/.aria2/aria2.conf\n自启动=true\n自动重启=true\n错误日志保存路径=\n其他日志保存路径=\n环境=\n\n---\n启动supervisor\n`supervisord -c /etc/supervisor/supervisord.conf`\n至此便完成了进程守护配置\n如需管理supervisor内进程，参考以下指令：\n\n```shell\nsudo supervisorctl start cloudreve #启动    \nsudo supervisorctl stop cloudreve #停止    \nsudo supervisorctl status cloudreve #状态\n```\n\n附.网页管理supervisor进程配置：\n在supervisor配置文件中（/etc/supervisor/supervisord.conf），添加以下内容\n\n```ini\n[inet_http_server]\nport=127.0.0.1:8888\nusername=\npassword=\n```\n\n其中port、username、password参数可自行设置，若需外部访问，可将port设置为0.0.0.0:8888\n\n### 配置开机自启动\n\n若在linuxdeploy中，初始化系统选择了sysv，则无需额外配置即可自启动supervisor及其中的程序\n若使用run-parts初始化，需额外配置，自行查询不再赘述\n\n## 配置cloudreve离线下载功能\n\n登录cloudreve管理页面，选择 离线下载节点 ，修改 主机（本机） 节点\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20220125103835.png)\n\n1. 启用离线下载\n2. 参考配置\n3. RPC服务地址，由于cloudreve与aria2运行在同一台服务器（旧手机）上，故填写127.0.0.1:{prot}\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20220125103937.png)\n4. RPC令牌，与 Aria2 配置文件中rpc-secret保持一致\n5. 临时下载目录，填写绝对路径，并保证cloudreve具有此目录的权限\n6. 额外参数配置，一般保持默认\n\n完成配置后，点击下一步，修改杂项信息，再点击下一步，即可保存该节点配置\n\n然后点击用户组，编辑用户组配置，允许进行离线下载\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20220125104705.png)\n\n---\n至此，所有配置完成，可在同一局域网下，打开cloudreve页面测试是否成功实现了个人云盘与离线下载功能\n"},{"title":"在vscode里直接粘贴图片——pasteimage","tags":["vscode","博客","安利"],"categories":"小技术","author":"柯罗krau","excerpt":"\n## 前言\n\n使用vscode写博客，要想便捷快速地在文章中插入图片，比较常见的一个做法是通过picgo+图床实现快捷键上传图片，并生成markdown格式的链接。图床常常是利用jsdelivr加速github仓库的方式搭建。\n我原本也一直是这样做的，但自从jsdelivr在国内不可用之后，（再者，jsdelivr的使用规范也不允许作为图床使用）我换用了另一种方案，即本文所写，通过vs的pasteimage插件直接把图片粘贴在文章内，并保存在博客目录内。\n\n","link":"/posts/pasteimage-in-vs","content":"\n## 前言\n\n使用vscode写博客，要想便捷快速地在文章中插入图片，比较常见的一个做法是通过picgo+图床实现快捷键上传图片，并生成markdown格式的链接。图床常常是利用jsdelivr加速github仓库的方式搭建。\n我原本也一直是这样做的，但自从jsdelivr在国内不可用之后，（再者，jsdelivr的使用规范也不允许作为图床使用）我换用了另一种方案，即本文所写，通过vs的pasteimage插件直接把图片粘贴在文章内，并保存在博客目录内。\n\n<!-- more -->\n\n## 效果展示\n\n为了突出这个插件的好用，特把效果展示提到使用教程前。\n\n首先，截张图，或者复制一张图片\n\n![](/photo/post-pics/pasteimage-in-vs/pasteimage-in-vs_2022-07-07-09-31-48.webp)\n\n然后在vscode内，使用快捷键ctrl+alt+v（可自定义）粘贴这张图片\n\n![](/photo/post-pics/pasteimage-in-vs/pasteimage-in-vs_2022-07-07-09-32-56.webp)\n\n这样就完成了，粘贴到文章内的图片会保存在你设置的目录下，粘贴图片实际上是粘贴的图片路径。图片文件以{文章标题_时间}的格式命名，十分有条理。\n\nvscode内的实际效果↓↓↓\n\n![](/photo/post-pics/pasteimage-in-vs/pasteimage-in-vs_2022-07-07-09-35-12.webp)\n\n图片文件名↓↓↓\n\n![](/photo/post-pics/pasteimage-in-vs/pasteimage-in-vs_2022-07-07-09-37-18.webp)\n\n## 使用\n\n### 先设情景\n\n你使用vscode写博客，你的博客由hexo驱动，你的博客的根目录文件夹名是`hexo-blog-raw`，你想把粘贴的图片以`文章标题_时间.png`的格式命名，并保存在`hexo-blog-raw/source/photo`目录下\n\n### 教程\n\n首先，在vscode的扩展商店中，搜索 paste image并安装\n\n![](/photo/post-pics/pasteimage-in-vs/pasteimage-in-vs_2022-07-07-09-38-09.webp)\n\n然后，在博客根目录下，新建.vscode文件夹，用于存放vscode的工作区配置（即局部设置）\n\n在.vscode文件夹内，新建settings.json文件，并写入以下内容并保存。（是的，配置我都帮你写好了）\n\n```json\n{\n    \"pasteImage.namePrefix\": \"${currentFileNameWithoutExt}_\",\n    \"pasteImage.path\": \"${projectRoot}/source/photo\",\n    \"pasteImage.basePath\": \"${projectRoot}/source\",\n    \"pasteImage.forceUnixStyleSeparator\": true,\n    \"pasteImage.prefix\": \"../\"\n}\n```\n\n![](/photo/post-pics/pasteimage-in-vs/pasteimage-in-vs_2022-07-07-09-48-46.webp)\n\n这样就完成了。\n按照如上配置后，所有配置是只在hexo-blog-raw工作区生效的，即只有在用vscode写博客文章时，以上配置才生效。\n\n使用时，用vscode打开博客文章，用快捷键ctrl+alt+v即可插入图片到文章内。\n\n更多的自定义配置，可参考[pasteimage官方文档](https://marketplace.visualstudio.com/items?itemName=mushan.vscode-paste-image)\n"},{"title":"Python3——列表、元组、字典、条件、循环、输入、函数","tags":["Python","代码"],"categories":"小技术","author":"柯罗krau","excerpt":"\n## 前言\n\n我接触python时间已经不短了，但学习中一直是零零散散，先有想法，再去学习对应的知识（比如爬虫），所以知识掌握得很不成系统。近来准备把python系统性地学一遍，于是有了此文，既作为自己学习的备忘笔记，也希望能帮助其他具有一点基础的人快速入门python。\n\n在GitHub上我还建了个仓库：[Py-learn](https://github.com/krau/py-learn)，在那里有代码源文件。\n\n","link":"/posts/py3-quick-basic","content":"\n## 前言\n\n我接触python时间已经不短了，但学习中一直是零零散散，先有想法，再去学习对应的知识（比如爬虫），所以知识掌握得很不成系统。近来准备把python系统性地学一遍，于是有了此文，既作为自己学习的备忘笔记，也希望能帮助其他具有一点基础的人快速入门python。\n\n在GitHub上我还建了个仓库：[Py-learn](https://github.com/krau/py-learn)，在那里有代码源文件。\n\n<!-- more -->\n\n本文旨在帮助有一定基础的朋友快速入门，因此环境搭建、编辑器选择等准备工作，以及变量和简单数据类型的介绍不在撰写范围内。\n\n## 列表\n\n### 列表基础\n\n```py\n#创建列表\nfriends = ['ah','leao','zhang','wang']\nprint(friends)\n\n#访问列表元素\nprint(friends[0])#索引从0开始\nprint(friends[-1])#反向索引从-1开始\n\n#修改列表元素\nfriends[0] = 'ahchan'\n\n#添加与删除列表元素\nfriends.append('zhou')#在末尾添加\nfriends.insert(1,'cos0')#在指定索引位置添加\n\ndel friends[1]#使用del删除指定位置的元素\npopped_friends = friends.pop(1)#使用pop”弹出“指定位置的元素\nprint(friends)\nprint(popped_friends)\n\nfriends.remove('zhou')#根据值删除元素\n\n#组织列表\nfriends.sort()#按首字母排序,永久性的\nprint(friends)\nfriends.sort(reverse=True)#可以传入reverse参数使其逆序\nprint(friends)\n\nprint(sorted(friends))#临时按首字母排序\n\nfriends.reverse()#reverse只是反转列表元素的排列顺序\nprint(friends)\n\nprint(len(friends))#使用len()确定列表有多少元素\n```\n\n### 操作列表\n\n```py\nmembers = ['krau','ah','hanmiao']\n#for循环遍历列表\nfor member in members: #for循环将把members中的元素依次与member关联，并都执行下面的操作\n    print(member)\n    print(f'{member.title()},welcome to yuzunion!')#title()将首字母大写\n\n\n#range()生成数字序列\nfor i in range(1,10):\n    print(i)\n#这个循环将会依次打印1-9，因为range是在10停止的，不包括10\n\n#使用range()创建数字列表\nnums_list_1to10 = list(range(1,10))\nprint(nums_list_1to10)\n\n#range()指定步长（公差）\nnums_list_1to10_2 = list(range(1,10,2))#第三个数字指定了步长，即每次加2\nprint(nums_list_1to10_2)\n\n#for与range结合，可以生成各种数列。如下是整数1~10的平方\nnums_list_1to100 = []\nfor num in range(1,11):\n    nums_list_1to100.append(num**2)#**表示乘方运算\nprint(nums_list_1to100)\n\n#数字列表简单统计运算，以上面的nums_list_1to100为例\nprint(min(nums_list_1to100))#最小值\nprint(max(nums_list_1to100))#最大值\nprint(sum(nums_list_1to100))#求和\n\n#列表解析，一种一行代码生成列表的方法（其实就是合并起来写）\nlist_analysis = [value**2 for value in range(1,11)]\nprint(list_analysis)\n#这种语法的使用方法是\n# 列表名 = [表达式 for 变量 in 数列]\n\n#切片，圈定列表某一部分\nphones = ['pixel3','mix4','k20p','pixel2','honor8']\nprint(phones[0:3])#输出包含索引为0，1，2的元素的’子列表‘\nprint(phones[:3])#不指定第一个索引会自动从0开始\nprint(phones[1:])#不指定第二个索引会自动到最后\nprint(phones[:])#都不指定就是从头到尾，可利用此创建列表的副本\nphones_copy = phones[:]\nprint(phones_copy)\n#这和直接把phones赋值给phones_copy是不一样的，若直接赋值，实际上只是给同一个列表关联了两个变量名字，当修改列表时，这两个变量都会同步修改\n#例如，给phones添加一个元素\nphones.append('readmi')\n#然后看看phones和phones_copy这两个列表现在是什么样的\nprint('phones列表',phones)\nprint('phones_copy列表',phones_copy)\n#但如果直接赋值将是下面的效果\nmy_phones = phones\nphones.append('oppo')\nprint(phones)\nprint('可以看到即使是对phones进行修改，my_phones也将输出和phones一样的列表',my_phones)\n\n\n#遍历切片\nfor phone in phones[0:3]:\n    print(phone.title())\n\n\n#元组，不能变的列表\n#创建元组，使用圆括号\ndimensions = (10,20)\nprint(dimensions[0])\nprint(dimensions[1])\n\n#元组中的数据是不能被修改的，如果尝试修改将会报错，以下被注释的代码将会报错\n# dimensions[0] = 20\n#但是可以重新定义元组来修改元组的值\nl = 20\nw = 10\ndimensions = (l,w)#重新定义元组是合法的\nprint(dimensions)\n#但即使改变元组中存储的变量的值，元组也不会改变\nl = 500\nw = 200\nprint(dimensions)#可以看到元组还是没变\n\n#如果需要创建只有一个元素的元组，也需要带上逗号，因为元组使用逗号来标识\nonlyonetuple = (1,)\n\n#遍历元组，和遍历列表没有什么区别\n```\n\n## 条件语句——if\n\n```py\n#判断两个值是否相等，用==（两个等号），相等时返回True，否则返回False\nwife = 'Miku'\nprint(wife =='Miku')\n# == 判断是大小写敏感的\nprint(wife == 'miku')#将会输出False\n#如果不希望大小写影响判断，可以在判断时都转换为小写\nprint(wife.lower()=='miku')#lower()不会直接修改变量的值，只是读取变量的值并将其小写再进行后续操作\n#若要都大写可使用.upper()方法\n\n#判断是否不相等，使用!=。!常常是表示‘非’的\nprint(wife != 'Miku')\n\n#判断多条件\n#and 和，都为True时返回True\nage_0 = 16\nage_1 = 14\nprint(age_0 > 15 and age_1 <=15)\n#or 或，至少有一个真就返回真\nprint(age_0 == 15 or age_1 > 12)\n\n#in检查特定值是否在列表中，如果在，返回True\nwaifus = ['miku','ayanami','sakira']\nprint('sakira' in waifus)\n#not in检查特定值是否不在列表中，如果不在，将返回Ture\nprint('miku' not in waifus)\n\n#布尔表达式，如下\nMiku_is_my_wife = True\nKrau_love_miku = True\n\n#if-else语句\nif 'miku' in waifus:\n    print('miku is my wife')\nelse:\n    print('miku is also my wife')\n#if-elif-else语句，判断多种条件之一\nif wife == waifus[0]:\n    print(f'{waifus[0]} is my wife!'.title())#此处f'{}'可以在字符串中输出变量的值\nelif wife == waifus[1]:\n    print(f'{waifus[1]} is my wife!'.title())\nelif wife == waifus[2]:\n    print(f'{waifus[2]} is my wife!'.title())#elif可以是多个\nelse:\n    print('you are all my wife'.title())\n#else是可以省略不写的，如果省略，程序会在所有条件都不符合时不进行任何操作\n#if-elif-else结构一旦遇到为真的条件时将会执行对应的代码块，之后跳过整个结构，即使之后还有为真的条件\n#如果你不想让它这样，那不妨多写几个if\n```\n\n## 字典\n\n```py\n#创建字典，使用花括号{}\nhuman_1 = {'color':'yellow','height':175}# 用 : 关联两个值，即键值对\nprint(human_1['color'])\nprint(human_1['height'])#通过 键 查找 值 ，就是“字典”的含义\n\n#向字典中添加键值对\nhuman_1['weight'] = 65 #直接 字典[新键]=值，即可把新的键值对添加到字典末尾\nprint(human_1)\n#修改字典中的值也是类似的\nhuman_1['height'] = 180\n\n#字典可以包含任意数量的键值对，包括空字典\nhuman_2 = {}\n\n#删除键值对\n#与列表类似，可使用del\ndel human_1['color']\nprint(human_1)\n\n#字典的格式可以是多行，这会让代码更加美观，尤其是字典内容很多的时候\nhuman_2 = {\n    'height':177,\n    'weight':68,\n    'age':18,\n    'gender':'male',\n}\n\n#使用get()访问字典，避免引发错误\n#当要访问的键值对在字典中不存在时，使用方括号访问便会引发错误。\n#可以使用get()，使之返回一个默认值，避免错误\nprint(human_2.get('color','不存在该值'))\n#当color在字典中不存在时，将会输出“不存在该值”，如果不给出get()的第二个参数，将会返回None\n#遍历字典\n#遍历键值对\nfor key,value in human_2.items(): #item()方法用于返回一个键值对列表\n    print(key)\n    print(value)#可以看到，字典中的每个键和值分别 依次赋给了key和value，当然这两个变量是可以随意命名的\n\n#遍历所有键，使用keys()方法\nfor key in human_2.keys():\n    print(key)\n#实际上，默认遍历时便是只遍历所有键，但最好加上keys方法，便于阅读\n#keys()方法返回的是一个包含所有键的列表，正如题item()方法返回的是一个包含所有键值对的列表\n\n#遍历所有值，使用values()方法\nfor value in human_2.values():\n    print(value)\n\n#使用特定顺序遍历列表\n#比如可以使用sorted()方法，按照字母顺序遍历\nfor key in sorted(human_2.keys()):\n    print(key)\n\n\n#当字典中的值出现重复时候，可以使用集合剔除重复项\nhumangender = {\n    'krau':'me',\n    'ah':'he',\n    'xiaolv':'she',\n    'hanmiao':'he',\n}\n#可以看到这个字典中两个值都是he，可以使用set()方法创建一个集合，集合中的元素都是独一无二的\nfor gender in set(humangender.values()):\n    print(gender)\n\n#集合，也使用花括号创建，但存储的不是键值对\nlangs = {'c','py','go'}\nprint(langs)\n\n\n#嵌套\n#在列表中嵌套字典\nhumans = [human_1,human_2]\nprint(humans)\n#同样的，可以在字典中嵌套列表，在字典中嵌套字典......\n```\n\n## 用户输入与while循环\n\n```py\n#用户输入，使用inpu()函数\n\nname = input('请输入你的名字： ')\nprint(f'hello {name}')\n\n#判断一个数是奇数还是偶数\nnum = int(input('请输入一个数：　'))#int()用于将字符串转化为整数\nif num % 2 == 0: #%是求模运算，即返回两个数相除的余数\n    print(f'{num}是偶数')\nelse:\n    print(f'{num}是奇数')\n\n#while循环\n#示例，使用while循环让用户控制程序何时结束\nprint('我是复读机，输入quit以退出程序')\nmsg = ''\nwhile msg != 'quit':\n    msg = input('请输入：')\n    if msg != 'quit':\n        print(msg)\n    else:\n        pass\n\n#使用标志，清晰地控制程序运行\nprint('我是复读机二号')\nmsg = ''\nstatus0 = True #这里的status0是为了方便控制循环运行的，便被称为标志\nwhile status0:\n    msg = input('请输入： ')\n    if msg == 'quit':\n        status0 = False\n    else:\n        print(msg)\n\n#使用break退出循环\nprint('我是复读机三号')\nmsg = ''\nwhile True:\n    msg = input('请您输入： ')\n    if msg == 'quit':\n        break\n    else:\n        print(msg)\n\n#使用continue从头开始循环\n#输出所有偶数\nnum0 = 0\nwhile num0 < 10:\n    num0 += 1\n    if num0 % 2 != 0:\n        continue #与break不同的是，它会使循环返回第一行重新执行（从num0+=1）\n    print(num0)\n```\n\n## 函数基础\n\n```py\n#定义函数，使用def，最简单的一个例子如下\ndef hello():\n    #输出问候语\n    print('Hello!')\n\nhello()\n\n#向函数传递参数\ndef hello(username):\n    print(f'Hello,{username.title()}!')\n#在这里，username被称为形参，而下面传入的’krau’就称为实参\nhello('krau')\n\n\n#传递实参\n#位置实参，按实参的顺序传递给形参\ndef human_info(name,height,weight,gender):\n    #显示一个人的信息\n    print(f'''\nMy name is {name.title()}\nMy height is {height},and weight is {weight}\nIm a {gender}''')\n\nhuman_info('krau','178','65','male')\n#可以看到实参按照顺序依次传递给了形参\n\n#关键字实参，按照名称传递实参\nhuman_info(height='178',name='krau',gender='male',weight='65')\n\n\n#给参数确定默认值\ndef pet_info(pet_name,pet_animal='cat'):\n    #显示宠物信息\n    print(f'{pet_name.title()} is my pet , it is a {pet_animal}')\n\n#若不给出pet_animal，则会使用默认值cat\npet_info('ah')\n#也可以给默认值为空字符串，即''，这样做的话，这个参数将变成可选的\n\n\n#返回值，函数处理数据并返回的值\n#让函数返回值，使用return\ndef name_format(first_name,last_name):\n    #返回格式化好的姓名\n    full_name = f'{first_name} {last_name}'\n    return full_name.title()\n\nprint(name_format('acher','krau'))\n#这里只是一个示例，所以未免有些脱裤子放屁\n\n#函数可以返回任意类型的值，比如返回字典\ndef build_human(name,age):\n    person = {'name':name,'age':age}\n    return person\nme = build_human('krau',18)\nprint(me)\n\n\n#传递列表\ndef yuzu_hello(names):\n    for name in names:\n        print(f'Hello,{name.title()}!')\n\nmembers = ['krau','ah','hanmiao']\nyuzu_hello(members)\n\n#当需要处理一个列表，但不想让函数对列表产生影响时，可以传入列表的副本\nyuzu_hello(members[:])\n\n\n#传递任意数量的实参，不需首先指定多少形参\ndef do_math1(*derivatives):\n    #什么都导不出来\n    for derivative in derivatives:\n        print(f'{derivative} 导不出来')\n\ndo_math1('lnx','2x','ex')\n#可以看到，*derivatives创建了一个名为derivatives的元组，传入的实参都存入其中\n\n'''\n如果要让函数接受不同类型的实参，必须在函数定义中将接纳任意 数量实参的形参放在最后。\nPython先匹配位置实参和关键字实参， 再将余下的实参都收集到最后一个形参中。\n'''\ndef do_math2(diffculity,*integrals):\n    #什么都积不回去\n    for integral in integrals:\n        print(f'{integral}积不回去，因为它的难度是{diffculity}')\n\n#Python先匹配位置实参和关键字实参， 再将余下的实参都收集到最后一个形参中。\ndo_math2('easy','fx','gx','hx')\n\n#使用任意数量的关键字实参\n#有时候，需要接受任意数量的实参，但预先不知道传递给函数的会是什么样的信息。\n#可以使用字典中的键值对解决这一问题\ndef build_profile(first,last,**user_info):\n    '''创建一个包含用户所有信息的字典'''\n    user_info['first_name'] = first\n    user_info['last_name'] = last\n    return user_info\n\nkrau_info = build_profile('acher','krau',age=18,gender='male')\nprint(krau_info)\n#可以看到**user_info使python创建了一个名为user_info的字典，age和gender都存入了其中\n\n'''\n注意 你经常会看到形参名**kwargs \n它常常用于收集任意数量的关键字实参。\n'''\n```\n\n## 模块\n\n将函数存储在独立文件中，称其为模块。\n要创建一个模块，首先创建.py文件，在.py中仅编写函数，这便是一个模块。\n然后在同级目录下的其他代码中，便可以使用import导入这个模块。\n例如，我们创建一个greet.py文件，在文件中编写以下内容。\n\n```py\ndef hello(name):\n    print(f'Hello {name}!')\n\ndef nohello(name):\n    print(f'Not good {name}')\n```\n\n然后，我们在同级目录下编写另一个.py文件\n\n```py\nimport greet\ngreet.hello('krau')\n```\n\nPython读取这个文件时，代码行import greet让Python打开文件 greet.py，并将其中的所有函数都复制到这个程序中。\n你看不到复制的代码，因为在这个程序即将运行时，Python在幕后复制了这些代码。\n你只需知道，在现在这个文件中，可使用greet.py中定义的所有函数。\n使用模块中的函数时，要指定模块名greet和函数名hello，并使用点分割\n即 模块名.函数名()\n\n上面的方法是导入了模块中的所有函数，如果不需要全部导入，可以使用下面的语句\nfrom 模块名 import 函数名\n\n如果要导入函数的名称可能与程序中现有的名称冲突，或者函数的名称太长，可指定简短而独一无二的别名\n类似于外号。要给函数取这种特殊外号，需要在导入它时指定。\nimport 模块名 as 模块外号\nfrom 模块名 import 函数名 as 函数外号\n\n## 函数编写指南（规范）\n\n编写函数需要牢记几个细节：\n\n1. 给函数指定**描述性名称**，只在其中使用小写字母和下划线。——模块命名也需要遵循此约定。\n\n2. 每个函数都应包含简要地阐述其功能的**注释**，该注释应紧跟在函数定义后面，并采用文档字符串格式。\n\n3. 给形参指定默认值时，等号两边**不要**有空格。——关键字实参也应遵循此约定。\n\n4. PEP8建议代码行的长度不要超过79字符，这样编辑器窗口适中就能看到整行代码。如果形参定义的长度超过了79个字符，可在函数定义中输入左括号后按回车键，并在下一行按两次Tab键，从而将形参列表和只缩进一层的函数体区分开。\n\n5. 如果程序或模块包含多个函数，可使用两个空行将相邻的函数分开，这样便于阅读和查看函数的开始和结束的地方。\n\n6. 所有的import语句都应放在文件**开头**，唯一例外情形是，在文件开头使用了注释来描述整个程序。\n"},{"title":"使用Python写一个Telegram bot吧|Telegram bot教程","tags":["Python","telegram","bot","代码"],"categories":"小技术","author":"柯罗krau","excerpt":"\n::: warning\n本文内容已过时, 敬请期待后续更新\n:::\n\n## 前言\n\n~~为了激发群友们水群的积极性，~~ 为了学习和应用 python 知识，我最近在开发一个 telegram 的 bot，所以写这篇文章以记录和分享\n\n在这篇文章中，将使用 [Python-Telegram-Bot](https://docs.python-telegram-bot.org) 最新版库，基于 Python 的新版异步特性与 Telegram 友好开放的 API，开发一个兼顾实用性和趣味的 bot ，并使用 Docker 在任何地方部署 bot\n\nDemo: [kmua-bot](https://github.com/krau/kmua-bot)\n\n本文不是从零开始的教程，阅读本文前，你需要具有一点点(真的很少一点)的 python 或其他语言编程的基础。\n\n","link":"/posts/tg-bot-dev-note-kmua","content":"\n::: warning\n本文内容已过时, 敬请期待后续更新\n:::\n\n## 前言\n\n~~为了激发群友们水群的积极性，~~ 为了学习和应用 python 知识，我最近在开发一个 telegram 的 bot，所以写这篇文章以记录和分享\n\n在这篇文章中，将使用 [Python-Telegram-Bot](https://docs.python-telegram-bot.org) 最新版库，基于 Python 的新版异步特性与 Telegram 友好开放的 API，开发一个兼顾实用性和趣味的 bot ，并使用 Docker 在任何地方部署 bot\n\nDemo: [kmua-bot](https://github.com/krau/kmua-bot)\n\n本文不是从零开始的教程，阅读本文前，你需要具有一点点(真的很少一点)的 python 或其他语言编程的基础。\n\n<!-- more -->\n\n## 准备\n\n### 环境\n\n使用你喜欢的工具创建虚拟环境，并安装以下 Python 库\n\n```yaml\nPyYAML\npython-telegram-bot\npypinyin\nparsel\nplaywright\n```\n\n- PyYAML: [yaml](https://zh.wikipedia.org/wiki/YAML) 配置文件相关包\n- python-telegram-bot: 一个对 Telegram bot api 封装的 python 库，注意版本，默认安装的是 13.14 ，要手动指定版本安装最新开发版本（截止写稿是 20.0a6 ），以支持异步特性。\n\n> 更新: 2023-02-21: python-telegram-bot 已经默认安装最新版本了，不需要手动指定版本了\n\n- pypinyin: 汉语拼音相关\n- parsel: 数据解析\n~~- pyppeteer: 浏览器爬虫包，[puppeteer](https://github.com/puppeteer/puppeteer) 的 python 移植（问我为啥不用更好的 [playwright-python](https://github.com/microsoft/playwright-python) ？被简中互联网上的文章坑了，以后会迁移过去。）~~\n- playwright: 浏览器爬虫\n\n> 更新: 2023-03-06: 用 playwright 重构\n\n### bot 申请\n\n私聊 [@BotFather](https://t.me/BotFather)。发送 `/newbot`，根据提示一步步创建，记得妥善保存最后的 **API Token**。\n\n### 获取你的 id\n\n每个 tg 用户都有一串标识数字，即为 **user_id**，可以私聊 [@userinfobot](https://t.me/userinfobot) 来获取它\n\n---\n\n## 基础\n\n### 开始:响应/start\n\n在项目文件夹内，新建 `bot.py`，开始编写 bot 最基础的功能，让其响应 /start 命令\n\n首先，导入包（先不要管它们都是什么鬼东西）\n\n```python\n# Update:从Telegram获取更新\nfrom telegram import Update\n#ApplicationBuilder:简单立即为构建 bot 对象\n#ContextTypes:上下文类型\n#CommandHandler:命令处理器\nfrom telegram.ext import ApplicationBuilder, ContextTypes, CommandHandler\n```\n\n然后，写一个异步函数 start()，当收到 /start 命令时，要调用它。\n\n```python\nasync def start(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    '''响应start命令'''\n    text = '你好~我是一个bot'\n    await context.bot.send_message(chat_id=update.effective_chat.id,text=text)\n```\n\n这个函数接受两个参数 `update` 和 `context`，形参冒号后是类型注解。这两个参数 `CommandHandler` 会传递给它。\n\n`context.bot.send_message()` 方法即为让 bot 发送消息，它能接受的参数其实很多，但是往往只需要 `chat_id` ，和 `text` 就够了，它们分别表示 要发送消息给的用户或群组 id ，要发送的文本。\n\n而 `update.effective_chat.id` 即为当前有效对话的 id ，在哪里发消息给 bot ，它就指向哪里的 id。\n\n> 你注意到 这个函数使用了 async/await 语法，这是 python 新版的语法糖，详见 官方文档 [asyncio](https://docs.python.org/3/library/asyncio.html)\n\n现在，添加一个处理器(handler)\n\n```python\nstart_handler = CommandHandler('start', start)\n```\n\n`CommandHandler` 类可以实现当收到某个命令时，调用某个函数（命令和函数名可以不一样），我们将其实例化为了 `start_handler` ，并且将命令名字 'start' 和对应要回调的函数名 start 传递给它\n\n然后，启动bot\n\n```python\n# 构建 bot\nTOEKN='你 bot 的 api token'\napplication = ApplicationBuilder().token(TOKEN).build()\n# 注册 handler\napplication.add_handler(start_handler)\n# run!\napplication.run_polling()\n```\n\n最后，就可以使用 `python bot.py` 启动你的 bot ，对 bot 发送 /start ，它应该就会回复你 ”你好~我是一个bot”。\n使用 Ctrl + C 结束程序运行。\n\n到这里，其实你已经了解到了最基本的 telegram bot 编写规则，即：\n\n1. 编写回调函数。上面的例子中即为 `start` 这个函数。\n2. 决定调用回调函数的规则。上述例子中，即为收到 `/start` 命令时，调用 `start` 函数\n3. 实例化 `handler` ,注册给 `application` 示例。上述例子中，即为 `application.add_handler(start_handler)`\n\n如果你的系统无法访问 Telegram 的服务器，可以设置代理\n\n全局代理,整个程序都走代理:\n\n```python\nos.environ['http_proxy'] = '代理地址'\nos.environ['https_proxy'] = '代理地址'\n```\n\n若想仅为 telegram bot api 设置代理,则需要改动一下构建 bot 部分的代码:\n\nhttp(s)代理:\n\n```python\nproxy_url = 'http://USERNAME:PASSWORD@PROXY_HOST:PROXY_PORT'  # can also be a https proxy\napplication = ApplicationBuilder().token(\"TOKEN\").proxy_url(proxy_url).get_updates_proxy_url(proxy_url).build()\n```\n\nsocks5代理,需要安装 `python-telegram-bot[socks]`,然后:\n\n```python\nproxy_url = \"socks5://user:pass@host:port\"\napplication = ApplicationBuilder().token(\"TOKEN\").proxy_url(proxy_url).get_updates_proxy_url(proxy_url).build()\n```\n\n接下来，写一些更有趣的功能，使用更复杂一些的规则来调用这些功能。\n\n### 授予群成员头衔\n\n让群成员可以通过 bot 自助获得一个头衔吧，比如，群友可以在群里使用 `/p@botname 好人` 来给自己加上 “好人” 的头衔。\n\n当然，前提是 bot 自己要是管理员，并且权限全开。\n\n要实现这个功能，可以这样写:\n\n```python\nasync def set_right(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    '''设置成员权限和头衔'''\n    chat_id = update.effective_chat.id\n    user_id = update.effective_user.id\n    bot_username_len = len(update._bot.name)\n    custom_title = update.effective_message.text[3+bot_username_len:]\n    if not custom_title:\n        custom_title = update.effective_user.username\n    try:\n        await context.bot.promote_chat_member(chat_id=chat_id, user_id=user_id, can_manage_chat=True)\n        await context.bot.set_chat_administrator_custom_title(chat_id=chat_id, user_id=user_id, custom_title=custom_title)\n        text = f'好,你现在是{custom_title}啦'\n        await context.bot.send_message(chat_id=chat_id, reply_to_message_id=update.effective_message.id, text=text)\n    except:\n        await context.bot.send_message(chat_id=chat_id, text='不行!!')\n```\n\n然后，添加这个功能的handler:\n\n```python\nset_right_handler = CommandHandler('p', set_right)\napplication.add_handler(set_right_handler)\n```\n\n注意handler的添加应该在 `application.run_polling()` 之前，也就是说 `application.run_polling()` 才是真正开始运行 bot\n\n简单解释一下 `set_right` 这个函数:\n\n首先，设置了调用这个函数时的 `chat_id` 和 `user_id` 为当前聊天和当前用户\n\n然后用 `len(update._bot.name)` 获取 bot 自己用户名的长度，用于下面的切片选取用户想要的头衔\n\n而 `custom_title = update.effective_message.text[3+bot_username_len:]` 即获取用户想要的头衔，存储在 `custom_title` 中，下面的 if not 的作用是，如果用户没有发送他想要的头衔，那么默认头衔为他的用户名\n\n由于只有管理员才有头衔，所以我们使用 promote_chat_member() 方法设置成员权限，将其的 can_manage_chat 权限设置为 True 。注意，即使这样设置了，用户实则是有名无权的状态，只有一个管理员的名头，实际上没有任何权限。\n> 要想赋予权限，你可以向 promote_chat_member() 方法中继续添加参数，如 can_pin_messages=True 可置顶消息\n\n然后就可以使用 set_chat_administrator_custom_title() 方法设置成员头衔了，如果成功了，会继续执行接下来的语句，将结果反馈给用户。\n\n### 响应未知命令\n\n如果 bot 只能回应设置好的命令就太无趣了，所以再编写一个当收到未知命令时的执行功能\n比如，想要让 bot 回应未知命令说 “我不会这个哦~”，可以这样写\n\n```python\nasync def unknown(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    '''响应未知命令'''\n    logger.debug('调用:unknown')\n    text = \"我不会这个哦~\"\n    await context.bot.send_message(chat_id=update.effective_chat.id, text=text)\n```\n\n然后，添加它的 `handler`。这时候可能就出现问题：\n前面的两个功能都是回应一个特定的命令，在这里，我们希望它回应除已经设定的命令外的其他所有命令，该怎么做？\n\n这就需要用到 `filters` ，并且要**设置功能的优先级**\n你需要先导入它\n\n`from telegram.ext import filters`\n\n然后可以这样写:\n\n```python\nunknown_handler = MessageHandler(filters.COMMAND, unknown)\n```\n\n`filters` 即过滤器，而 `filters.COMMAND` 即为所有命令。而设置优先级其实非常简单，**添加 `handler` 的顺序越靠后，对应功能的优先级越低**\n\n也就是说，我们需要在其他命令类 `handler` 之后，添加 `unknown_handler`\n\n```python\napplication.add_handler(start_handler)\napplication.add_handler(set_right_handler)\napplication.add_handler(unkonw_handler)\n\napplication.run_polling()\n```\n\n### 简单的关键词回复\n\nbot 最常见的功能之一就是根据关键词回复特定内容，比如，当对 bot 说早安之类的话时，让 bot 对此做出回应。下面来实现这这一功能\n由于命令和普通消息是两种不同的消息类，处理它们的方法是不一样的，针对非命令消息，要使用 `MessageHandler`:\n`from telegram.ext import MessageHandler`\n\n首先还是要编写这个功能执行的函数。\n\n```python\nimport random\nasync def ohayo(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    texts = ['早上好呀','我的小鱼你醒了，还记得清晨吗','哦哈哟~']\n    await context.bot.send_message(chat_id=update.effective_chat.id, text=random.choice(text))\n```\n\n由于只回复一个固定的消息过于单调，所以我们使用 `random` 库来从一个列表中随机选择一个回复\n\n实际上，这个函数仍然只是简单的发送消息，而何时调用这个函数，并不是这个函数本身要做的事，而是由接下来我们要编写的 `MessageHandler` 中的 `filters` 决定的:\n\n```python\nfilter_ohayo = filters.Regex('早安|早上好|哦哈哟|ohayo')\nohayo_handler = MessageHandler(filter_ohayo, ohayo)\n```\n\n`filters.Regex()` 即为使用正则表达式过滤，我们使用 `'早安|早上好|哦哈哟|ohayo'` 这个表达式，很容易理解何时会调用 `ohayo` 这个函数\n\n记得添加它的 `handler`\n\n```python\napplication.add_handler(ohayo_handler)\n```\n\n---\n\n## 进阶\n\n### 定制日志系统\n\n在上面写的一些小功能中,我们没有让程序在控制台或者文件里输出任何信息,只有当报错的时候python会输出一些traceback,这在以后排查故障的时候是极其不便的(毕竟谁都不能保证自己的程序不出bug,或是遇到自己没有考虑到的情况).所以有必要加上一个简单的日志系统.\n\n在项目下新建一个 `logger.py` 文件,用来定制日志系统.\n\n比如,我们想要根据日志等级让日志输出到两份文件,一份是 normal , 包括 INFO 以上的日志,另一份是 debug , 包括 DEBUG 以上的日志,而 INFO 以上的日志还同时输出到控制台,那么可以这样:\n\n```python\nimport logging\nimport os\nfrom logging import handlers\n\n\nclass Logger:\n    def __init__(self, name: str, show: bool, save: bool = True, debug: bool = False) -> None:\n        \"\"\"\n        日志系统\n\n        :param name: 日志系统实例名\n        :param show: 是否显示在控制台\n        :param save: 是否保存到文件, defaults to True\n        :param debug: debug模式, defaults to False\n        \"\"\"\n        # 日志文件路径\n        normal_log_path = f'logs/normal.log'\n        debug_log_path = f'logs/debug.log'\n        if not os.path.exists('./logs'):\n            os.mkdir('./logs')\n        self.logger = logging.getLogger(name)\n        # 设置日志等级和格式\n        self.logger.setLevel(logging.DEBUG)\n        self.formatter = logging.Formatter(\n            '%(asctime)s - %(name)s - %(levelname)s: - %(message)s',\n            datefmt='%Y-%m-%d %H:%M:%S'\n        )\n        # 设置相关 handler\n        if not self.logger.handlers:\n            if show:\n                # 控制台 handler\n                sh = logging.StreamHandler()\n                if debug:\n                    sh.setLevel(logging.DEBUG)\n                else:\n                    sh.setLevel(logging.INFO)\n                sh.setFormatter(self.formatter)\n                self.logger.addHandler(sh)\n            if save:\n                # 保存到文件的 handler\n                fh_debug = handlers.TimedRotatingFileHandler(\n                    filename=debug_log_path,\n                    when=\"D\",\n                    interval=1,\n                    backupCount=3,\n                    encoding='utf-8'\n                ) # 自动日志切割\n                fh_debug.setLevel(logging.DEBUG)\n                fh_debug.setFormatter(self.formatter)\n                fh = handlers.TimedRotatingFileHandler(\n                    filename=normal_log_path,\n                    when=\"D\",\n                    interval=1,\n                    backupCount=3,\n                    encoding='utf-8'\n                )\n                fh.setLevel(logging.INFO)\n                fh.setFormatter(self.formatter)\n                self.logger.addHandler(fh)\n                self.logger.addHandler(fh_debug)\n\n    def debug(self, message):\n        self.logger.debug(message)\n\n    def info(self, message):\n        self.logger.info(message)\n\n    def warn(self, message):\n        self.logger.warning(message)\n\n    def error(self, message):\n        self.logger.error(message)\n\n    def critical(self, message):\n        self.logger.critical(message)\n```\n\n然后在 `bot.py` 里导入并实例化它\n\n```python\nfrom logger import Logger\nlogger = Logger(name='bot', show=True)\n```\n\n之后就可以在任意地方使用日志记录并输出一些信息,比如在 `start()` 函数里:\n\n```python\nasync def start(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    '''响应start命令'''\n    logger.info(f'收到来自{update.effective_chat.username}的/start指令')\n    text = '你好~我是一个bot'\n    await context.bot.send_message(chat_id=update.effective_chat.id,text=text)\n```\n\n在其他任意你觉得需要日志的地方都可以使用.\n\n### 使用 yml 文件配置\n\n把配置直接写进代码里也太不优雅了些,而且对于其他普通用户来说,还可能会因为写错等原因直接破坏程序,所以需要把配置都搬到文件里. yml 是常见的配置文件格式,也比较简单.\n\n后面我们还可能会需要很多小工具,所以新建一个 `utils.py`,把各种辅助的方法都放里面.\n\n导入yaml库,os库和我们的日志系统\n\n```python\nimport yaml\nimport os\nfrom logger import Logger\n```\n\n然后\n\n```python\nclass Utils:\n    '''该类用于设置一些辅助的方法'''\n\n    def __init__(self) -> None:\n        logger.debug('实例化Utils')\n        pass\n\n    def read_config(self,config_name: str) -> dict:\n        '''读取配置'''\n        config_path = os.path.abspath(os.path.join(os.getcwd(), config_name))\n        with open(config_path, 'r', encoding='utf-8') as f:\n            config = yaml.load(f, Loader=yaml.FullLoader)\n        logger.debug(f'已载入配置{config_name}')\n        return config\n```\n\n然后就可以在yml中写配置,比如 `config.yml`:\n\n```yml\n# bot的token,必填\ntoken: ''\n\n#全局代理设置，如不需设置请留空\nproxy: ''\n```\n\n需要读取这些配置时,先导入上面写的 `utils` 模块并实例化 Utils 类,然后调用 `read_config` 方法即可:\n\n```python\nfrom utils import Utils\nutils = Utils\nconfig = utils.read_config('config.yml')\n```\n\n这里得到的 config 变量储存了我们的配置,它是一个字典.比如要在代理设置里使用它,只需要这样:\n\n```python\nif config['proxy']:\n    os.environ['http_proxy'] = config['proxy']\n    os.environ['https_proxy'] = config['proxy']\n```\n\n还有构建 bot 时:\n\n```python\nTOKEN=config['token']\napplication = ApplicationBuilder().token(TOKEN).build()\n```\n\n> 其实这种方法也是不太优雅的,因为可能会多次读取配置文件,更好的方法是把配置写成一个模块,然后导入它们(单例模式).\n\n### 使用 json 存取词库\n\n关键词回复是 bot 很常见的功能,这时候就会用到词库.\n\n新建 `data/words` 文件夹,用来存储我们的数据.下面是一个简单的词库 `ohayo.json` 示例(早上问候场景)\n\n```json\n[\n    \"我的小鱼你醒了，还认识早晨吗\",\n    \"昨夜你曾经说，愿夜幕永不开启\",\n    \"我的小鱼你睡醒了吗，还记得夜晚吗\",\n    \"早晨你曾说过，愿黎明曙光永不落下\",\n    \"早上好哦~\",\n    \"哦哈哟喵~\",\n    \"众生皆小饼干，你是最甜的那一块~\",\n    \"今天也是新的一天~\",\n    \"你醒啦？(歪头)\",\n    \"啊呜~你已经起床了嘛(打哈欠)\"\n]\n```\n\n写一个比较通用的方法,用来反序列化json词库文件.把这个方法写进上面我们创建过的 `Utils` 类里即可.\n\n```python\n    def load_words(self, words: str):\n        '''读取并加载词库'''\n        words_path = os.path.join(\n            os.getcwd(), 'data', 'words', f'{words}.json')\n        try:\n            with open(words_path, 'r',encoding='utf-8') as f:\n                the_words_json = json.load(f)\n            logger.debug(f'已载入词库：{words_path}')\n            return the_words_json\n        except Exception as e:\n            logger.error(f'载入词库出错：{words_path}, {e}')\n            return {'Exception': 'except'}\n```\n\n这个方法接受一个词库文件名(不带后缀),然后从 `data/words` 读取对应的词库,并返回为 python 数据结构\n\n这时候代码量可能已经比较多了,为了方便组织和管理,我把除了 `bot.py` 的其他 py 文件统一放到了 `src` 文件夹下.\n\n然后创建一个用于从词库中取句子的类 `Getwords`(因为词库也可能不止一种,为了之后方便扩展所以单独写一个类)\n\n在 src/words.py 中:\n\n```python\nimport random\nfrom .utils import Utils\nfrom .logger import Logger\n\n# 实例化类\nlogger = Logger(name='words',show=True)\nutils = Utils()\n\n# 读取 ohayo.json 这个词库\nohayo_words = utils.load_words('ohayo')\n\nclass GetWords():\n    def __init__(self):\n        \"\"\"\n        该类用于提取消息特定文本，或是返回特定文本\n        \"\"\"\n        logger.debug('实例化GetWords')\n        self.ohayo = ohayo_words\n\n    def get_ohayo(self) -> str:\n        '''返回早安问候句子'''\n        word =  random.choice(self.ohayo)\n        logger.debug(f'获取到早安:{word}')\n        return word\n```\n\n然后修改 `bot.py` 中的早安问候功能:\n\n```python\n# 导入 Getwords 类\nfrom src.words import GetWords\n\n# 实例化\ngetWords = GetWords()\n\nasync def ohayo(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    text=getWords.get_ohayo()\n    await context.bot.send_message(chat_id=update.effective_chat.id, text=text)\n```\n\n再次强调一下,何时触发响应的功能应该交给过滤器去做,我们这里的 `ohayo()` 函数只需要关心功能触发后应该做什么就可以了.\n\n### 使用 docker 部署 bot\n\npython 程序的环境管理很烦人,用docker来跑再合适不过.\n\n#### 本地构建\n\n如果要在本地构建 docker 镜像,参考下面的 `Dockerfile` 文件\n\n```Dockerfile\nFROM python:3.9\nCOPY . /app\nWORKDIR /app\nRUN pip install -r requirements.txt\nENTRYPOINT [ \"python\",\"/app/bot.py\" ]\n```\n\n将 Dockerfile 文件放到合适的目录(项目根目录即可),然后执行\n\n`docker build -t bot .`\n\n注意后面有一个 .\n\n> 关于 docker 构建镜像的更多帮助,可以参阅 [docker 从入门到实践](https://yeasy.gitbook.io/docker_practice/image/build#gou-jian-jing-xiang)\n\n然后使用 `docker run -d bot` 启动容器,运行 bot\n\n#### 使用 GitHub action 自动构建\n\ngithub action 可以构建 docker 镜像并发布到 ghcr,方便在其他地方部署 docker 容器.你依然需要在项目中写好 `Dockerfile`\n\n在项目中新建 `.github/workflows/build-docker.yml`,参考以下配置\n\n```yml\nname: Build and publish docker container\n\non:\n  workflow_dispatch:\n    \n\njobs:\n  publish:\n    name: Publish container image\n    runs-on: ubuntu-20.04\n    env:\n      TZ: Asia/Shanghai\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3\n\n      - name: OCI meta\n        id: meta\n        uses: docker/metadata-action@v4.1.1\n        with:\n          images: ghcr.io/${{ github.repository }}\n          tags: |\n            type=edge,branch=main\n            type=ref,event=branch\n            type=semver,pattern={{version}}\n            type=semver,pattern={{major}}.{{minor}}\n            type=semver,pattern={{major}}\n            type=sha\n      - name: Set up Docker Buildx\n        uses: docker/setup-buildx-action@v2\n        \n      - name: Set up QEMU\n        uses: docker/setup-qemu-action@v2\n\n      - name: Login to GHCR\n        uses: docker/login-action@v2\n        with:\n          registry: ghcr.io\n          username: ${{ github.repository_owner }}\n          password: ${{ secrets.GITHUB_TOKEN }}\n\n      - name: Build and push\n        uses: docker/build-push-action@v3\n        with:\n          context: .\n          push: true\n          tags: ${{ steps.meta.outputs.tags }}\n          labels: ${{ steps.meta.outputs.labels }}\n          platforms: linux/amd64,linux/arm64\n          cache-from: type=gha\n          cache-to: type=gha,mode=max\n```\n\n然后可以使用 `docker pull` 的方法运行,或者使用 docker compose:\n\n新建 `docker-compose.yml`,参考以下内容\n\n```yml\nversion: \"3\"\nservices:\n  kmua:\n    image: ghcr.io/krau/kmua-bot:main\n    container_name: kmua-main\n    init: true\n    volumes:\n      - ./data:/kmua/data\n      - ./logs:/kmua/logs\n      - ./config.yml:/kmua/config.yml\n    environment:\n      - TZ=Asia/Shanghai\n```\n\n注意根据自己需要更改\n\n然后就可以使用 `docker compose up -d` 启动容器\n\n---\n\n## 附加\n\n### 使用playwright查询mc模组信息并记录\n\nplaywright 是一个浏览器自动化工具包,如果你了解过 selenium 那么你一定知道它是什么.但是 playwright 是异步的\n\n我们想要实现这样的功能: 当 bot 收到包含 [mcmod](https://www.mcmod.cn) 页面链接的消息时,去主动打开链接,收集模组信息并截图,然后发送模组信息给用户.并且持久化保存这些信息,当再次收到同样的链接时,直接从已保存的数据中获取并返回给用户.\n\n新建 `src/mcmod.py`. 以下是一个例子,它获取了模组的名称并且截图网页,保存这些数据\n\n```python\nimport re\nimport os\nimport json\nfrom playwright.async_api import async_playwright\nfrom src.logger import Logger\n\nlogger = Logger(name='McMod', show=True)\n\n\nclass McMod:\n    def __init__(self, width: int = 1280, height: int = 1080) -> None:\n        \"\"\"\n        参数设定\n\n        :param width: 页面宽度, defaults to 1280\n        :param height: 页面高度, defaults to 1080\n        \"\"\"\n        logger.debug('实例化McMod')\n        self.args = ['--headless', '--no-sandbox',\n                     '--disable-gpu', '--hide-scrollbars']\n        self.options = {'args': self.args, 'defaultViewport': {\n            'width': width, 'height': height},'dumpio':True}\n\n    async def screenshot(self, mod_url: str, width: int = 1280, height: int = 720, close: bool = True) -> dict:\n        \"\"\"\n        获取网页截屏\n\n        :param url: 网址\n        :param width: 页面宽度, defaults to 1280\n        :param height: 页面高度, defaults to 720\n        :param close: 完成后是否关闭网页, defaults to True\n        :return: 字典{'file_name':截图文件名,'cn_name':中文名,\n                        'en_name':英文名,'full_name':格式化后的全名,'mod_url':模组链接}\n        \"\"\"\n        try:\n            async with async_playwright() as p:\n                browser = await p.chromium.launch()\n                page = await browser.new_page()\n                await page.set_viewport_size({'width': width, 'height': height})\n                await page.goto(mod_url)\n                await page.wait_for_selector('.class-title')\n                class_title = await page.query_selector('.class-title')\n                try:\n                    h4 = await class_title.query_selector('h4')\n                    en_name = await h4.get_property('innerText')\n                    en_name = await en_name.json_value()\n                    try:\n                        h3 = await class_title.query_selector('h3')\n                        cn_name = await h3.get_property('innerText')\n                        cn_name = await cn_name.json_value()\n                    except:\n                        cn_name = ''\n                except:\n                    en_name = ''\n                    cn_name = ''\n                file_name = re.sub(r'[^a-zA-Z]', '', en_name) + '.png'  # 以英文模组名(去除非法字符)保存截屏文件\n                full_name = f'{cn_name} {en_name}'  # 为了少开一次浏览器，干脆把模组名也顺便获取并返回\n                if not os.path.exists(f'./data/pics/{file_name}'):\n                    await page.screenshot(path=f'./data/pics/{file_name}')\n                if close:\n                    await page.close()\n                    await browser.close()\n                record_flag = self.mod_data_record(mod_cn_name=cn_name,mod_en_name=en_name,mod_file_name=file_name,mod_full_name=full_name,mod_url=mod_url)\n                if record_flag:\n                    data_dict = self.mod_data_read(mod_url=mod_url)\n                    return data_dict\n                else:\n                    logger.error(f'未能记录模组 {mod_url}')\n                    return {}\n        except Exception as e:\n            logger.error(f'获取截屏 {mod_url} 失败!')\n            logger.error(f'错误:{e}')\n            if close:\n                await page.close()\n                await browser.close()\n            return {}\n\n    async def get_mod_name(self, url: str, lang: str = 'full', close: bool = True) -> str:\n        \"\"\"\n        获取模组名\n\n        :param url: mcmod的模组页面\n        :param lang: 要获取的模组名语言, defaults to 'full'\n        :param close: 完成后是否关闭网页, defaults to True\n        :return:\n        \"\"\"\n        try:\n            async with async_playwright() as p:\n                browser = await p.chromium.launch()\n                page = await browser.new_page()\n                await page.goto(url)\n                await page.wait_for_selector('.class-title')\n                class_title = await page.query_selector('.class-title')\n                try:\n                    h4 = await class_title.query_selector('h4')\n                    en_name = await h4.get_property('innerText')\n                    en_name = await en_name.json_value()\n                    try:\n                        h3 = await class_title.query_selector('h3')\n                        cn_name = await h3.get_property('innerText')\n                        cn_name = await cn_name.json_value()\n                    except:\n                        cn_name = ''\n                except:\n                    en_name = ''\n                    cn_name = ''\n                full_nm = f'{cn_name} {en_name}'\n                if close:\n                    await page.close()\n                    await browser.close()\n                if lang == 'full':\n                    return full_nm\n                elif lang == 'cn':\n                    return cn_name\n                elif lang == 'en':\n                    return en_name\n                elif lang == 'dict':\n                    name_dict = {'cn_name':cn_name,'en_name':en_name,'full_name':full_nm}\n                    return name_dict\n                else:\n                    logger.debug(f'lang不能为{lang}')\n                    return ''\n        except Exception as e:\n            logger.error(f'获取模组名称 {url} 失败!')\n            logger.error(f'错误:{e}')\n            return ''\n\n    def mod_data_record(self, mod_file_name: str,mod_full_name: str, mod_url: str, mod_cn_name: str='', mod_en_name: str='',  mod_pic_path: str = '') ->bool:\n        \"\"\"\n        以json文件存储模组的信息,变量名定义与其他函数中一致\n\n        :param mod_file_name: 模组去除非法字符(包括空格)的英文全名+后缀名\n        :param mod_full_name: 格式化后的全名, ex: 植物魔法|Botania\n        :param mod_url: 模组链接\n        :param mod_cn_name: 模组中文名, defaults to ''\n        :param mod_en_name: 模组英文名, defaults to ''\n        :param mod_pic_path: 模组页面截图路径, defaults to ''\n        :return: 记录成功返回True,否则False\n        \"\"\"\n        logger.debug('调用:McMod.mod_data_record')\n        try:\n            logger.debug(f'记录模组数据:{mod_cn_name}')\n            mods_data_path = './data/mods_data.json'\n            if not os.path.exists(mods_data_path):\n                with open(mods_data_path, 'w',encoding='utf-8') as f:\n                    json.dump({}, f,ensure_ascii=False)\n                logger.debug(f'未找到数据文件路径,已新建')\n            if not mod_pic_path:\n                mod_pic_path = f'./data/pics/{mod_file_name}'\n                logger.debug(f'未传入pic_path,使用默认:{mod_pic_path}')\n            mod_data = {mod_url: {'file_name': mod_file_name, 'cn_name': mod_cn_name,\n                                        'en_name': mod_en_name, 'full_name': mod_full_name, 'mod_url': mod_url, 'pic_path': mod_pic_path}}\n            logger.debug(f'模组数据:{mod_data}')\n            with open(mods_data_path,'r',encoding='utf-8') as f:\n                data_content = json.load(f)\n            data_content.update(mod_data)\n            with open(mods_data_path,'w',encoding='utf-8') as f:\n                json.dump(data_content,f,indent=4,ensure_ascii=False)\n            logger.info(f'已记录模组数据:{mod_data}')\n            return True\n        except Exception as e:\n            logger.error(f'记录模组数据 {mod_url} 错误!')\n            logger.error(f'错误:{e}')\n            return False\n\n    def mod_data_read(self,mod_url:str) -> dict:\n        try:\n            logger.debug(f'读取模组数据:{mod_url}')\n            mods_data_path = './data/mods_data.json'\n            with open(mods_data_path,'r',encoding='utf-8') as f:\n                data = json.load(f)\n            if mod_url in data:\n                full_name = data[mod_url].get('full_name')\n                logger.info(f'该模组数据已记录:{full_name}')\n                return data[mod_url]\n            else:\n                logger.debug('该模组数据未记录')\n                return False\n        except Exception as e:\n            logger.error(f'读取模组数据 {mod_url} 错误!')\n            logger.error(f'错误:{e}')\n            return False\n```\n\n然后在 `bot.py` 中添加这一功能:\n\n```python\nasync def get_mcmod(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    '''自动获取mcmod上的模组信息'''\n    mod_urls = getWords.get_mcmod_url(text=update.effective_message.text)\n    for mod_url in mod_urls:\n        data_dict = mcmod.mod_data_read(mod_url=mod_url)\n        if data_dict:\n            await send_mod_data(update=update, context=context, data_dict=data_dict)\n            continue\n        try:\n            data_dict = await mcmod.screenshot(mod_url=mod_url)\n        except Exception as e:\n            text = f'无法获取模组信息：{e}'\n            await context.bot.send_message(chat_id=update.effective_chat.id, text=text)\n            continue\n        if not data_dict:\n            text = f'无法找到模组信息：{mod_url}'\n            await context.bot.send_message(chat_id=update.effective_chat.id, text=text)\n            continue\n        await send_mod_data(update=update, context=context, data_dict=data_dict)\n\n\nasync def send_mod_data(update:Update, context:ContextTypes.DEFAULT_TYPE, data_dict:dict):\n    '''发送模组数据'''\n    try:\n        file = data_dict['file_name']\n        mod_url = data_dict['mod_url']\n        full_name = data_dict['full_name']\n        async with aiofiles.open(f'./data/pics/{file}', 'rb') as f:\n            photo = await f.read()\n    except FileNotFoundError:\n        text = f'无法找到截图文件：{file}'\n        await context.bot.send_message(chat_id=update.effective_chat.id, text=text)\n        return\n\n    text = f'找到了这个模组~\\n<b><a href=\"{mod_url}\">{full_name}</a></b>'\n    await context.bot.send_photo(chat_id=update.effective_chat.id, photo=photo, caption=text, parse_mode='HTML')\n```\n\n我们还需要一个从消息中提取链接的函数,在 `words.py` 中:\n\n```python\n    def get_mcmod_url(self, text: str) -> list[str]:\n        '''返回句中的mcmod页面链接列表'''\n        mod_nums = re.findall(r\"www\\.mcmod\\.cn/class/([0-9]+)\", text)\n        urls = [f\"https://www.mcmod.cn/class/{x}\" for x in mod_nums]\n        if urls:\n            logger.info(f'获取到mcmod链接{urls}')\n            return urls\n        else:\n            logger.info('无mcmod链接')\n            return []\n```\n\n这个函数返回一个列表,包含了消息中包含的所有 mcmod 模组页面的链接\n\n然后,还需要一个用于触发该功能的过滤器:\n\n```python\nfilter_mcmod = filters.Regex(r\"www.mcmod.cn/class\")\n```\n\n最后添加它的 handler 即可:\n\n```python\nget_mcmod_handler = MessageHandler(filter_mcmod, get_mcmod)\napplication.add_handler(get_mcmod_handler)\n```\n"},{"title":"使用ShareX和Markdown Image自动压缩截图为WebP格式并一键插入Markdown文档","tags":[],"categories":["小技术"],"author":"柯罗krau","excerpt":"\n之前我曾安利过 [PasteImage](http://localhost:4859/posts/pasteimage-in-vs) 这个插件，用 VSCode 写博客/文档的时候，用它可以很快捷地在md文档中插入图片。\n\n受某个友人影响，我也开始尝试 ~~拥抱 webp~~了，近期的文章内的图片都已经压缩成了 webp 格式。但是 PasteImage 却不支持 webp 格式，于是我又想办法整出了今天这个解决方案，实现完全自动化的 压缩+插入图片。\n\n","link":"/posts/use-sharex-and-mdimage-for-efficiency","content":"\n之前我曾安利过 [PasteImage](http://localhost:4859/posts/pasteimage-in-vs) 这个插件，用 VSCode 写博客/文档的时候，用它可以很快捷地在md文档中插入图片。\n\n受某个友人影响，我也开始尝试 ~~拥抱 webp~~了，近期的文章内的图片都已经压缩成了 webp 格式。但是 PasteImage 却不支持 webp 格式，于是我又想办法整出了今天这个解决方案，实现完全自动化的 压缩+插入图片。\n\n<!-- more -->\n\n## 配置 ShareX\n\n[sharex](https://getsharex.com/) 是一个强大的截屏、录屏、分享软件，开源免费，支持高度自定义的自动化，\n\n然后还要安装 [ffmpeg](https://ffmpeg.org/) ，它在本文的作用是通过命令调用来压缩图片。如果你没了解过它的话不妨去搜索一下，也是一个十分强大的工具。\n\n然后在 sharex 的动作设置中，添加一个动作\n\n![图 2](/photo/post-pics/use-sharex-and-mdimage-for-efficiency/use-sharex-and-mdimage-for-efficiency_01-16-19-19-40.webp)\n\n- 名称: 随意\n- 文件路径: ffmpeg 的安装路径，要指定到 ffmpeg 可执行文件\n- 参数: `-i \"$input\" -q 75 \"$output\"`  其中 -q 75 是以75%质量压缩\n- 输出文件扩展名: webp\n- 扩展名筛选: png\n\n勾上下面的 隐藏窗口 和 删除输入文件\n\n![图 3](/photo/post-pics/use-sharex-and-mdimage-for-efficiency/use-sharex-and-mdimage-for-efficiency_01-16-19-24-22.webp)\n然后在截图后的任务里选中这些项(添加图像特效可视情况自行添加)\n\n![图 4](/photo/post-pics/use-sharex-and-mdimage-for-efficiency/use-sharex-and-mdimage-for-efficiency_01-16-19-26-14.webp)\n\n## 配置 Markdown Image\n\n[Markdown Image](https://marketplace.visualstudio.com/items?itemName=hancel.markdown-image) 是一个 VSCode 插件，支持将剪贴板中的图片保存在指定路径下(或指定图床中)，并自动生成 markdown 格式的引用。\n\n我的博客的文章图片是按照 `/public/photo/post-pics/文章名/文章名_时间` 的格式和路径保存在本地的，所以按照下面这样配置\n\n```json\n\"markdown-image.base.fileNameFormat\": \"${mdname}/${mdname}_${MM}-${DD}-${HH}-${mm}-${ss}\",\n\"markdown-image.local.path\": \"../../public/photo/post-pics/\",\n\"markdown-image.local.referencePath\": \"/photo/post-pics/${mdname}/\",\n```\n\n更详细的配置，参照 [Markdown Image 的官方文档](https://github.com/imlinhanchao/vsc-markdown-image/blob/HEAD/README.zh-cn.md)\n\n这样就完成啦。现在使用 sharex 截屏时会自动调用 ffmpeg 将文件压缩为 webp 格式并保存在剪贴板中，然后在 VSCode 中使用 `Alt + Shift + V` 粘贴即可。\n"},{"title":"【白话文】如何加入一个zerotier网络|当腐竹因为移动不给ipv4公网而要求玩家用zerotier组网时...","tags":["网络","zerotier"],"categories":"小技术","author":"柯罗krau","excerpt":"\n最近把自家宽带从联通转战移动，然而移动不给公网ipv4，导致我mc服的铸币玩家们无法连接服务器，于是决定用zerotier组建网络，一举多得.\n此文写给小白，只用白话文介绍如何加入一个zerotier网络。\n\n","link":"/posts/zerotier-client","content":"\n最近把自家宽带从联通转战移动，然而移动不给公网ipv4，导致我mc服的铸币玩家们无法连接服务器，于是决定用zerotier组建网络，一举多得.\n此文写给小白，只用白话文介绍如何加入一个zerotier网络。\n\n<!-- more -->\n\n## 注册zerotier账号\n\n点击打开[zerotier官网](zerotier.com)\n\n然后点击右上角sign up\n![1](/photo/post-pics/zerotier-client/zerotier-client_2022-08-21-09-53-59.webp)\n\n注册一个账号\n![2](/photo/post-pics/zerotier-client/zerotier-client_2022-08-21-09-55-43.webp)\n\n然后zerotier官方会给你的邮箱发送一封验证邮件，点击邮件中链接即可注册成功\n![3](/photo/post-pics/zerotier-client/zerotier-client_2022-08-21-09-57-15.webp)\n\n接下来下载zerotier软件\n\n## 下载安装和配置zerotier\n\n打开[官网的下载页面](https://www.zerotier.com/download/)\n\n点击windows即可下载\n![4](/photo/post-pics/zerotier-client/zerotier-client_2022-08-21-09-59-02.webp)\n\n下载完后双击运行，自动完成安装\n\n安装完成后，点击状态栏图标，点击join new network\n![5](/photo/post-pics/zerotier-client/zerotier-client_2022-08-21-10-01-09.webp)\n\n然后填入要加入的网络id，点击join即可\n"}]
