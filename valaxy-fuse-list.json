[{"title":"为 valaxy 博客 yun 主题添加 artitalk 说说页面","tags":["博客"],"categories":["小技术"],"author":"Krau","excerpt":"\n## Artitalk\n\n[Artitalk](https://artitalk.js.org/) 是一个基于 Leancloud 的简单说说 js，具体参见官方文档。\n\n我成功将它接入了我的博客，","link":"/posts/add-artitalk-for-valaxy-yun","content":"\n## Artitalk\n\n[Artitalk](https://artitalk.js.org/) 是一个基于 Leancloud 的简单说说 js，具体参见官方文档。\n\n我成功将它接入了我的博客，[点这里看看](https://krau.top/about)。下面简单介绍一下接入方法。\n\n> 由于构建上的一些问题，我把它暂时移除了\n\n## 注册并配置 Leancloud\n\n这一步与官方文档完全相同，[点击查看](https://artitalk.js.org/doc.html#%F0%9F%8C%88-leancloud-%E7%9A%84%E7%9B%B8%E5%85%B3%E5%87%86%E5%A4%87)\n\n## 配置 valaxy\n\n在博客根目录下，新建 index.heml，写入以下内容\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0\">\n    <link rel=\"icon\" href=\"favicon.ico\">\n    <title><%= htmlWebpackPlugin.options.title %></title>\n  </head>\n  <body>\n    <noscript>\n      <strong>We're sorry but <%= htmlWebpackPlugin.options.title %> doesn't work properly without JavaScript enabled. Please enable it to continue.</strong>\n    </noscript>\n    <div id=\"app\"></div>\n      <script src=\"https://cdn.jsdelivr.net/npm/artitalk\"></script>\n  </body>\n</html>\n```\n\n然后在 /components/ 目录下，新建 Artitalk.vue ，写入以下内容\n\n```vue\n<template>\n  <div id=\"artitalk_main\" />\n</template>\n\n<script>\nexport default {\n  mounted() {\n    function addScript(url) {\n      var s = document.createElement(\"script\");\n      s.id = \"at\";\n      url.indexOf(\"appId\") == -1 ? (s.src = url) : (s.innerHTML = url);\n      document.head.appendChild(s);\n    }\n    addScript(`\n      new Artitalk({\n          appId: '你的appid',\n          appKey: '你的key',\n          shuoPla: '',\n          bgImg: 'https://cdn.jsdelivr.net/gh/drew233/cdn/20200409110727.webp',\n          atEmoji: {\n              huaji: 'https://cdn.jsdelivr.net/gh/moezx/cdn@3.1.9/img/Sakura/images/smilies/icon_huaji.gif',\n              baiyan: 'https://cdn.jsdelivr.net/gh/Artitalk/Artitalk-emoji/baiyan.png',\n              bishi: 'https://cdn.jsdelivr.net/gh/Artitalk/Artitalk-emoji/bishi.png',\n              bizui: 'https://cdn.jsdelivr.net/gh/Artitalk/Artitalk-emoji/bizui.png',\n              chan: 'https://cdn.jsdelivr.net/gh/Artitalk/Artitalk-emoji/chan.png'          \n          },\n      })\n    `);\n  },\n  destroyed() {\n    document\n      .querySelectorAll(\"#at\")\n      .forEach(element => element.parentNode.removeChild(element));\n    delete window.AV;\n  }\n};\n</script>\n```\n\n这样就可以啦。在你想要显示说说的页面(.md文件)里，写上`<Artitalk />` 就可以显示了。\n\n## 问题\n\n目前 Artitalk 只支持以 Leancloud 作为数据库，并且 cdn 用的还是 jsdeliver，速度感人。我提了 issue 希望能支持更多部署方式，不过看起来作者已经失踪有一段时间了...\n\n可惜我不会 js，只能等大佬实现啦。~~现在又不是不能用~~\n"},{"title":"ArchLinux on Y9000P2022十分好用,就是有点难用","tags":["Linux"],"categories":["日常"],"author":"Krau","excerpt":"\n受不了啦，给笔记本装上 Arch 折磨自己！\n\n","link":"/posts/archlinux-on-y9kp22-1","content":"\n受不了啦，给笔记本装上 Arch 折磨自己！\n\n<!-- more -->\n\n## 起因\n\n突然想安装 Arch 的理由：\n\n1. 酷！不觉得这很酷吗，做为一个理科生我觉得用一个完全手动安装的Linux发行版真的太酷了，很符合我对带黑客的想象！\n2. 自由！不同于乌班图、opensuse、centos这些具有实体维护者（商业公司）的发行版，Arch是由社区驱动的，属于自由阵营！不会受到各种奇怪法律的管辖！\n3. 简洁！Arch连安装的gui图形界面都没有，需要什么都要自己手动安装，最后的系统组件和应用将会不多也不少，符合自己的需求。\n4. 软件丰富！绝大多数软件已经有其他人帮你打包好了，安装就是一条命令解决！\n5. 不想用win了！但是不想用乌班图，太臃肿了！也不想用debian，太土了！\n6. 编不动了\n\n电脑是拯救者Y9000P2022款，配置：\n\n- CPU：I7 12700H\n- GPU：RTX3060M\n\n## 关于如何安装\n\n很简单，查 [Archlinux官方wiki](https://wiki.archlinux.org/) 就可以了。嫌官方的不够友好的话可以看这个：[ArchLinux简明指南](https://arch.icekylin.online/)\n\n## 遇到的问题\n\n### Nvidia显卡驱动\n\nSoNvidiaFUCKYOU!\n折腾了很长时间，这n卡的驱动就是装不上，最后是重装了系统，然后安装开源版驱动解决了：\n\n`sudo pacman -S nvidia-open`\n\n安装之后的处理和wiki里是一样的，好像比较新的型号的显卡（30系）都是要安装这个驱动。\n\n这个开源版并不是社区的那个逆向出来的开源版，而是nvidia官方给的，性能是没有太大问题的\n\n### Nvidia对wayland的兼容性\n\nSoNvidiaFUCKYOU!\n\nn卡+linux桌面=shit!N卡用户建议暂时不要用wayland，老老实实Xorg，兼容性比wayland好太多了。\n\n### 多显示器无法正常使用\n\n简单来说这还是N卡的锅，各种折腾尝试有可能会解决，玄学就是了。\n\n我能正常使用多显示器的情景有两个：\n\n1. BIOS设置混合模式，安装 `optimus-manager` 开核显模式。\n2. BIOS开独显直连，把nvidia驱动写进早加载，不要安装 `optimus-manager`。\n\n另外这两种模式都是Xorg，nvidia对wayland真的没啥兼容性，会出现一堆奇怪问题。\n\n### 蓝牙耳机无法连接\n\n安装这个就可以了\n\n`sudo pacman -S bluez bluez-utils pulseaudio-bluetooth`\n\n## 体验\n\n太好用啦！所有软件都用pacman或者yay直接安装，并且能纳入滚动升级中。\n\n### 聊天通讯\n\nTelegram：字体有问题，安装了几个中文字体之后正常了，体验和win是一样的，tg官方对于linux平台也是下了精力的。实在不行还能用web端。\n\nQQ：你没事吧？跟张小龙学会了登个号还得手机扫码？口区。而且登录的时候还会提示安全风险，难绷，不愧是腾讯。\n\n### 浏览器\n\n火狐，很不错。但是缩放有时候会出问题，打开的时候界面突然很小或者很大...应该是我多显示器的原因。\n\n然后还试了试 brave，只能说好像没多好用，而且一股子去中心化web3区块链虚拟币的味道。\n\n### 游戏\n\n出乎意料的流畅啊！谁说的linux打游戏是ppt的，体验和win没感知上的差距。当然可能是我不玩什么3a大作（实际上来说我几乎不玩游戏了），玩了 muse dash 这个音游试了下，体验真的和win没什么区别。\n\n### 开发与运维\n\n终端软件用的是 Termius（学生包白嫖的不用白不用），IDE还是vscode。\n\n好用！\n\n---\n\n快来加入Arch邪教吧！\n\n顺便，Arch的图标真的是太好看啦！\n\n![图片.png](https://s2.loli.net/2023/02/20/C2uoFdGhVQZrwvb.png)\n"},{"title":"蝴蝶","tags":["日记"],"categories":"日常","author":"Krau","excerpt":"\n晚自习，教室里飞来一只蝴蝶。\n\n","link":"/posts/dairy-butterfly","content":"\n晚自习，教室里飞来一只蝴蝶。\n\n<!-- more -->\n\n黑色的翅膀点缀着几点橙色，灵动地在教室里飞着。从前排飞到后排，又墙角飞到中央，从过道飞到讲台，在教室里转着圈。不知道是不是吊扇的风太大的缘故，它忽上忽下地翻旋。\n\n本来没有人在意这只班级的不速之客，但它就这样一直盘旋了十分钟多，以至于连后排备课的老师的注意力都被它吸引了，当老师站起来想送它出门时，却又找不到了它。\n\n过了一会，还是不见它的身影，我望向座边窗户想要放松一下眼睛，正巧看到它落在了那里。我对邻桌说，你看这只蝴蝶怎么停在我们这里不走了。“关你什么事”，换来的是一句漫不经心的回复。\n\n下课了，四周的人也都注意到了这只黑蝴蝶，于是同组的同学说起了自己以前抓蝴蝶的事。\n\n坐在我前面的同学拿起笔，对着这只蝴蝶准备下杀手。我的心里咯噔一下。但旁边的几个人拦住了他，过了一会，那位同学又想去扎死它，我慌忙站了起来，抢先他一步，去抓那只蝴蝶的翅膀，于是它飞走了。\n\n它又开始在教室里盘旋，但这次飞的更高了一些，我揪紧了心，但我害怕的事情还是发生了：高速旋转的吊扇打到了它，它被击落在地。\n\n班里的人都注意到了，没有多想什么，我起身去捡起拿只蝴蝶的尸体。所幸的是那不是尸体，吊扇没有击中要害，也没有把翅膀打为残翅的，它还能勉强地扑动翅膀，但飞不了多高了。\n\n我把它放在了我的桌子上，听到了周围的嘁声。我又轻轻抓住了它，向教室门走去。\n\n到了教室外面，我放开了手，它又开始在走廊里盘旋，但过了一会不见了。\n\n这个时候，上课了，我回到了教室。同学都开始问我那只蝴蝶怎么样了，“放飞了”，我说。"},{"title":"diary-2021-12-16","tags":["日记"],"categories":"日常","author":"Krau","excerpt":"\n昨晚下午考试数学的时候开始头晕腰酸，我还以为是靠窗太阳晒+久坐导致的。晚上也吃不下去饭。一直到晚自习还是这样，挺到最后一节找来了温度计量了体温，39℃。\n\n然后去找老师请假，一边写着请假条，一边听着","link":"/posts/diary-2021-12-16","content":"\n昨晚下午考试数学的时候开始头晕腰酸，我还以为是靠窗太阳晒+久坐导致的。晚上也吃不下去饭。一直到晚自习还是这样，挺到最后一节找来了温度计量了体温，39℃。\n\n然后去找老师请假，一边写着请假条，一边听着老师和另一位同学家长的电话：“如果明天还是不舒服就别来考试了，身体健康最重要。”\n\n于是我犹豫着把请假区间写到了15日晚上。\n\n交给老师签字。\n\n“明天不来考试了是吧”\n\n我：“多写点，怕万一来不了”\n\n“哼，多写点。\n\n你就不能少写点，真要是撑不住了打电话再请。\n\n干什么事都要少点骄气，你就是骄气太大。\n\n家长不舍得让你吃苦，你也就没吃过苦。”\n\n说完给我签好了字。\n\n我昏昏沉沉地走出办公室，到门卫室给我妈打电话，在门卫室等了三十分钟左右。\n\n在路上，对我妈说了老师的话，但没提那句 “家长就不舍得让你吃苦……”，我妈则语重心长的告诉我这是因为考试很重要。\n\n已经是临近十点，街边的卫生所都关门了，去医院怕被隔离，就去了一个有交情的医生家里。\n\n打了一针，开了三四天的药。回家下了两包泡面，吃完药就睡了。\n\n半夜出了一身冷汗，我妈来给我送了杯水。早上七点多才醒来，已经退烧了。\n\n八点半开考，从老家八点多出门，路上我看着时间已经不够了，但我妈坚持让我去考试，因为考试很重要。\n\n等我进班的时候，物理考试已经开考十几分钟了。把物理和下一场的生物都胡乱做完。中午我妈接我回家吃饭，下午英语考试又是开考了才进班。\n\n考完六场，晚上学校又加练了一套理综题。\n\n这一天是怎么过去的我浑然不知，只记得唯分数至上，唯考试为重的他们。\n\n今晚放学，我妈打电话问我，明天要不要休息，我冷笑。\n\n“考试都不让我休息，还谈什么明天呢”\n\n“就是因为考试很重要，才不能休息”"},{"title":"FastAPI dependency injection system","tags":["Python","代码","FastAPi"],"categories":["小技术"],"author":"Krau","excerpt":"\n## 什么是「依赖注入」 {lang=\"zh-CN\"}\n## What is \"Dependency Injection\" {lang=\"en\"}\n\n::: zh-CN\n\n>编程中的「依赖注入」是声明代码（本文中为路径操作函数 ）运行所需的，或要使用的「依赖」的一种方式。\n>\n>然后，由系统（本文中为 FastAPI）负责执行任意需要的逻辑，为代码提供这些依赖（「注入」依赖项）。\n>\n>依赖注入常用于以下场景：\n>\n>- 共享业务逻辑（复用相同的代码逻辑）\n>- 共享数据库连接\n>- 实现安全、验证、角色权限等……\n>\n>上述场景均可以使用依赖注入，将代码重复最小化。\n:::\n\n\n::: en\n\n>\"Dependency Injection\" means, in programming, that there is a way for your code (in this case, your path operation functions) to declare things that it requires to work and use: \"dependencies\".\n>\n>And then, that system (in this case FastAPI) will take care of doing whatever is needed to provide your code with those needed dependencies (\"inject\" the dependencies).\n>\n>This is very useful when you need to:\n>\n>- Have shared logic (the same code logic again and again).\n>- Share database connections.\n>- Enforce security, authentication, role requirements, etc.\n>- And many other things...\n>\n>All these, while minimizing code repetition.\n:::\n\n","link":"/posts/fastapi-dependency-injection","content":"\n## 什么是「依赖注入」 {lang=\"zh-CN\"}\n## What is \"Dependency Injection\" {lang=\"en\"}\n\n::: zh-CN\n\n>编程中的「依赖注入」是声明代码（本文中为路径操作函数 ）运行所需的，或要使用的「依赖」的一种方式。\n>\n>然后，由系统（本文中为 FastAPI）负责执行任意需要的逻辑，为代码提供这些依赖（「注入」依赖项）。\n>\n>依赖注入常用于以下场景：\n>\n>- 共享业务逻辑（复用相同的代码逻辑）\n>- 共享数据库连接\n>- 实现安全、验证、角色权限等……\n>\n>上述场景均可以使用依赖注入，将代码重复最小化。\n:::\n\n\n::: en\n\n>\"Dependency Injection\" means, in programming, that there is a way for your code (in this case, your path operation functions) to declare things that it requires to work and use: \"dependencies\".\n>\n>And then, that system (in this case FastAPI) will take care of doing whatever is needed to provide your code with those needed dependencies (\"inject\" the dependencies).\n>\n>This is very useful when you need to:\n>\n>- Have shared logic (the same code logic again and again).\n>- Share database connections.\n>- Enforce security, authentication, role requirements, etc.\n>- And many other things...\n>\n>All these, while minimizing code repetition.\n:::\n\n<!-- more -->\n\n## 示例 {lang=\"zh-CN\"}\n## Examples {lang=\"en\"}\n\n### 函数作为依赖 {lang=\"zh-CN\"}\n### Function as dependence {lang=\"en\"}\n\n::: zh-CN\n\n```python\nfrom fastapi import FastAPI, Depends\n\napp = FastAPI()\n\nasync def common_parameters(q: str | None = None, page: int = 1, limit: int = 10):\n    return {\"q\": q, \"page\": page, \"limit\": limit}\n\n@app.get(\"/dependency\")\nasync def dependency(commons: dict = Depends(common_parameters)):\n    return commons\n```\n\n`common_parameters` 函数定义了一组通用的查询参数`（q,page,limit）`，该函数接受这些参数并返回一个字典，该字典包含这些参数及其值。这些参数之间可以通过逗号进行分隔，表示它们是可选参数，并且有默认值。\n\n`@app.get(\"/dependency\")` 的路由装饰器绑定了一个API路由，这个路由接受一个名为 `commons` 的参数，这个参数需要调用 `common_parameters` 函数的返回值。Depends可以让我们把一个函数当做参数来传递到另一个函数，这里的 `Depends(common_parameters)` 表示该API路由需要调用 `common_parameters` 来获取查询参数。\n\n当请求到达API路由时，**FastAPI将调用 `common_parameters` 函数，将返回的字典作为 `commons` 参数的值注入到 `dependency` 函数中**，然后执行处理请求的逻辑并返回响应。因此，**`dependency` 的 `commons` 参数包含所有通用查询参数的值**，实现了依赖注入的功能。\n\n也就是说,通过依赖注入,我们使得一个代码块(函数)中可以调用另一个代码块,并访问其中的变量或属性\n\n::: tip\n实际上,这里是实现了类似类的继承的功能,由于 FastAPI 是以函数式编程为主,所以才有了依赖注入系统,来实现类的一些功能.\n\n在上面的例子中，`common_parameters` 可以看作是一个公共的基类（类似于父类），它定义了一组通用的查询参数。同时，`@app.get(\"/dependency\")` 中的函数可以看作是派生类（类似于子类），它需要使用通用查询参数来处理请求。\n\n当调用dependency函数时，`Depends` 会自动调用 `common_parameters` 函数，获取查询参数，然后将其注入到 `dependency` 函数中，类似于子类调用父类的构造函数获取公共配置，并继承其行为的方式。\n\n虽然Depends和依赖注入并不是类的继承，但它们可以实现类似的效果，使代码更加清晰和易于维护。\n:::\n\n::: en\nThe function common_parameters defines a set of common query parameters (q, page, limit) and accepts these parameters as input, then returns a dictionary containing these parameters and their values. These parameters can be separated by commas to indicate they are optional and have default values.\n\nThe API route decorator @app.get(\"/dependency\") binds an API route that accepts a parameter named commons, which needs to call the common_parameters function to get the query parameters. Depends allows us to pass a function as a parameter to another function. Here, the Depends(common_parameters) indicates that this API route needs to call common_parameters to get the query parameters.\n\nWhen a request arrives at the API route, FastAPI will call the common_parameters function and inject the returned dictionary as the value of the commons parameter into the dependency function. Then, it executes the logic to handle the request and returns the response. Therefore, the commons parameter of the dependency function contains the values of all the common query parameters, achieving the functionality of dependency injection.\n\n::: tip\nIn fact, here we are implementing a function similar to class inheritance. Since FastAPI is mainly based on functional programming, it has the dependency injection system to implement some functionality similar to class inheritance.\n\nIn the example above, common_parameters can be seen as a common base class (similar to a parent class) that defines a set of common query parameters. At the same time, the function in @app.get(\"/dependency\") can be seen as a derived class (similar to a child class) which needs to use the common query parameters to handle requests.\n\nWhen calling the dependency function, Depends automatically calls common_parameters to get the query parameters and injects them into the dependency function, similar to calling the parent class constructor to get common configurations and inherit its behavior.\n\nAlthough Depends and dependency injection are not inheritance of classes, they can achieve similar effects, making the code more clear and easy to maintain.\n:::\n\n### 类作为依赖 {lang=\"zh-CN\"}\n### Class as dependence {lang=\"en\"}\n\n::: zh-CN\n\n```python\nfake_item_db = [{\"item\": \"foo\"}, {\"item\": \"qwq\"}, {\"item\": \"awa\"}]\n\nclass CommonQueryParams:\n    def __init__(self, q: str | None = None, page: int = 1, limit: int = 100) -> None:\n        self.q = q\n        self.page = page\n        self.limit = limit\n\n\n@app.get(\"/classes_as_dependencies\")\nasync def class_as_dependencies(commons=Depends(CommonQueryParams)):\n    resp = {}\n    if commons.q:\n        resp.update({\"q\": commons.q})\n    items = fake_item_db[commons.page:commons.limit]\n    resp.update({\"items\": items})\n    return resp\n# 下面这两种写法也可以将类作为依赖\n# async def class_as_dependencies(commons:CommonQueryParams=Depends(CommonQueryParams))\n# async def class_as_dependencies(commons:CommonQueryParams=Depends())\n```\n\n当用户访问 `/classes_as_dependencies` 时，`CommonQueryParams` 依赖项会注入为 `commons` 参数。该端点然后检查请求中是否有指定搜索查询，并在有指定查询时使用它来更新 resp 字典。然后它根据 page 和 limit 参数从 fake_item_db 数据库检索项目，并返回一份带有搜索查询内容（如果有的话）和检索到的项目的响应。\n:::\n\n::: en\n\n```python\nfake_item_db = [{\"item\": \"foo\"}, {\"item\": \"qwq\"}, {\"item\": \"awa\"}]\n\nclass CommonQueryParams:\n    def __init__(self, q: str | None = None, page: int = 1, limit: int = 100) -> None:\n        self.q = q\n        self.page = page\n        self.limit = limit\n\n\n@app.get(\"/classes_as_dependencies\")\nasync def class_as_dependencies(commons=Depends(CommonQueryParams)):\n    resp = {}\n    if commons.q:\n        resp.update({\"q\": commons.q})\n    items = fake_item_db[commons.page:commons.limit]\n    resp.update({\"items\": items})\n    return resp\n```\n\nWhen a user accesses the /classes_as_dependencies endpoint, the CommonQueryParams dependency is injected as the commons parameter. The endpoint then checks if there is a search query specified in the request and updates the resp dictionary with the query if there is one. It then retrieves items from the fake_item_db database based on the page and limit parameters, and returns a response with the search query (if any) and the retrieved items.\n:::\n\n### 嵌套依赖 {lang=\"zh-CN\"}\n### nested dependencies {lang='en'}\n\n::: zh-CN\n依赖之间可以嵌套,**一个依赖可以依赖于另一个依赖**,即称为子依赖\n:::\n\n### 路径装饰器依赖与全局依赖 {lang=\"zh-CN\"}\n### Path decorator dependencies and global dependencies {lang=\"en\"}\n\n::: zh-CN\n可以为 FastAPI 的路径装饰器传入 dependencies 参数,该参数的值是 Depend() 类列表 ,传入后可以在装饰器下的函数中调用依赖项\n\n也可以在创建 FastAPI 或 APIRouter 实例时导入依赖,同样是传入 dependencies 参数,这样的依赖在整个应用下都可以调用\n:::\n\n::: en\nYou can pass the \"dependencies\" parameter to the path decorator of FastAPI, and the value of this parameter is a \"Depend()\" class list. After passing it, the dependencies can be called in the function under the decorator.\n\nYou can also import dependencies when creating FastAPI or APIRouter instances by passing the \"dependencies\" parameter. Such dependencies can be called throughout the entire application.\n:::"},{"title":"简单汇总下那些推过的galgame（持续更新）","tags":["ACG","galgame"],"categories":["日常"],"author":"Krau","excerpt":"\n","link":"/posts/gal-collection","content":"\n<!-- more -->\n\n## 个人 galgame 整理&安利\n\n就按照我能回想起来的先后顺序排序吧（，而且也懒得分类什么的，都混着列出来得了（\n反正我玩的不算多←是真话\n\n---\n\n### 将所有的歌献给未来的你\n\n![](https://i.loli.net/2021/06/02/FEuSNprv2xtG3LH.png)\n\n> 未来のキミと、すべての歌に―是Supplement Time在2008年04月04日[1]发售的初音同人游戏。是Supplement Time出品的初音系列的同人游戏的第一部。其后续作有鈴が歌う、未来の音色―和未来の歌と、つながるヒトミ。\n详见[萌娘百科](https://zh.moegirl.org/zh-hans/%E5%B0%86%E6%89%80%E6%9C%89%E7%9A%84%E6%AD%8C%E7%8C%AE%E4%BA%8E%E6%9C%AA%E6%9D%A5%E7%9A%84%E4%BD%A0)\n\n应该是我玩的第一款gal？？不太确定了，反正玩的挺早的\n\n算是比较日常但是又有些波折的剧情，总之就是在大街上捡回家了只miku然后发生的种种......\n\n### nekopara\n\n![](https://pic.downk.cc/item/5f04083814195aa5946cd80d.jpg)\n>《猫娘乐园》（日语：ネコぱら；英语：NEKOPARA）是由NEKO WORKs发行的Galgame。\n详见萌娘百科[猫娘乐园](https://zh.moegirl.org/zh-hans/%E7%8C%AB%E5%A8%98%E4%B9%90%E5%9B%AD#)\n  \n经典的猫系gal，~~听说打个补丁会更有趣~~\n\n### 美少女万华镜\n\n不配图了这个emmmm\n>《美少女万华镜》美少女万拔镜（日语：美少女万華鏡）是日本游戏品牌ωstar制作并发售的纯爱系超自然官能AVG系列作品。 详见萌娘百科[美少女万华镜](https://zh.moegirl.org/zh-hans/%E7%BE%8E%E5%B0%91%E5%A5%B3%E4%B8%87%E5%8D%8E%E9%95%9C#)\n\n### 哥哥，早上起床之前都要抱紧我哦\n\n![](https://pic.downk.cc/item/5f0409ee14195aa5946d78e2.jpg)\n>《哥哥，早上起床之前都要抱紧我哦！》是由Tinkle Position制作的一部Galgame。 [萌娘百科详情](https://zh.moegirl.org/zh-hans/%E5%93%A5%E5%93%A5%EF%BC%8C%E6%97%A9%E4%B8%8A%E8%B5%B7%E5%BA%8A%E4%B9%8B%E5%89%8D%E9%83%BD%E8%A6%81%E6%8A%B1%E7%B4%A7%E6%88%91%E5%93%A6%EF%BC%81)\n\n~~国欠妹系列~~\n\n### 缘之空\n\n![](https://pic.downk.cc/item/5f040afe14195aa5946dd903.jpg)\n>《缘之空》（ヨスガノソラ，Yosuga no Sora）是Sphere于2008年12月5日发售的恋爱文字冒险游戏，也是Sphere的处女作。亦有漫画、动画、Fandisk、广播剧等衍生作品。[萌娘百科：缘之空](https://zh.moegirl.org/zh-hans/%E7%BC%98%E4%B9%8B%E7%A9%BA#)\n\n国欠妹*2\n对应的续作还有一部『悠之空』\n\n### 双子洛丽塔后宫\n\n   ![](https://pic.downk.cc/item/5f040b9114195aa5946e11b6.jpg)\n\n   不说什么~\n\n### 東津萌米-穗姬\n\n![](https://i.loli.net/2020/07/07/ygVwB4o3i19zxXm.jpg)_找不到更高清的图了_\n> 穗姬是原产于台湾屏东县东港镇的杂交稻米品种“高雄145”以及该稻米所产的大米“东津萌米”的萌娘化形象，也登场于游戏《东津萌米-穗姬》中。 [萌娘百科：穗姬](https://zh.moegirl.org/zh-hans/%E7%A9%97%E5%A7%AC#)\n\n国产游戏，更偏向于养成系的（种大米），姑且也算是galgame吧\n~~万物皆可萌~~\n\n### 家有仙妻～无名小猫又与神Tuber～\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200707140100.png)\n\n猫系galgame*2\n\n萌百没收录这个......明明挺~~社保~~的\n\n### 恋爱少女人格崩坏\n\n![](https://pic.downk.cc/item/5f154ec714195aa5942c10a6.jpg)\n\n能搞笑又能社保~~（指男主）~~\n\n### 魔女的夜宴\n\n时间：2020.7.17-2020.7.24±\n![](https://cdn.jsdelivr.net/gh/voidoath/photo@master/blog-img/sabbatofwitch.png)\n\n谁敢反对狗头，我就打爆他的宁宁（错乱\n\n### 千恋万花\n\n时间：2020.7.26±-2020.7.28±（只过了从雨线）\n从雨天下第一！\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200804182632.png)\n\n### ATRI -My Dear Moments-\n\n时间：2020.7.29-2020.8.2？\n咕噜咕噜~呸\n![](https://i.loli.net/2020/08/04/kEtr4q3MexlNzvA.png)\n\n### 星光咖啡馆与死神之蝶\n\n时间：2020.8.28-8.31（明月栞那）\n~~星巴克与大扑棱蛾子~~\n![](https://i.loli.net/2020/09/11/eRyb7AahWzgdKkD.png)\n\n### RIDDLEJOKER\n\n时间：2020.9.7-9.16（在原七海）\n能推睡着的一gal......但感觉还不戳，（七海天下第一）\n![图片.png](https://i.loli.net/2021/06/02/VC8r7GvWoeUTm4M.png)\n\n### 想要传达给你的爱恋\n\n时间：5.24-5.30\n苟利星奏生死以，岂因新岛避趋之\n![](https://i.loli.net/2021/06/02/2zX4i3DFrco7Lhs.png)\n\n### 异想魅惑\n\n时间:2021.6.4（云）\n\n# 异想魅惑\n\n探索解密式的剧情玩法+色气可爱的唯一女主魅魔设定\n虽然te确实很感人，但其他五条结局也很绝望和惊悚\n![](https://i.loli.net/2021/06/04/Bir1Gpe7KzbDxT5.png)\n\n### 诱惑自大洛丽塔\n\n时间：2021年\n![](https://i.loli.net/2021/06/04/LQpf9eHyVNYbaCM.png)\n\n### 九次九日九重色\n\n时间：2021.6.5\n![](https://i.loli.net/2021/06/06/tZD7gOkq6lzo1WR.png)\n喵都太可爱了\n\n### 天色天歌天籁音\n\n时间：2021.6.6\n国欠我一个天妹\n![](https://i.loli.net/2021/06/06/4Med61olIyfZv5t.png)\n\n### 春色春恋春熙风\n\n时间：2021.6.7\n\n### 雪色雪花雪余痕\n\n时间：2021.6.7-6.8\n\n### 9-nine- 新章\n\n时间：2021.6.8\n\n### 牵绊闪耀的恋之伊吕波\n\n时间：2021.8.25-8.29\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20210829224332.png)\n\n发椿啦发椿啦，当然椿恋歌也会推的啦，这里就只写一个好了\n\n### 星空列车与白的旅行\n\n时间：2021.9\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/000_title.png)\n这是一部“童话”\n\n### 巧可甜恋\n\n时间：2021.9\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20211001193405.png)\n剧情是真的短，但她真的太可爱了太刑了\n\n### 糖调！-sugarfull tempering-\n\n时间：2021.9\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/Sugarful_cover.jpg)\n冰织天下第一！\n"},{"title":"Go 的 gRPC 和 Protocol Buffers---Quick Start","tags":["代码","Go","gRPC","Protobuf"],"categories":"小技术","author":"Krau","excerpt":"\n## Protocol Buffers\n\nProtocol Buffers (Protobuf) 是一种语言无关、平台无关、可扩展的序列化结构化数据的方法, 可以像 XML, json 等一样用于程序间数据通信. 而相较于上列二者, Protobuf 有更高的效率.\n\n使用 Protobuf 需要在 `.proto` 文件中定义数据结构, 并安装其编译器来生成对应语言的模型. 本文以 Go 为例.\n\n","link":"/posts/grpc-and-protobuf-in-go-start","content":"\n## Protocol Buffers\n\nProtocol Buffers (Protobuf) 是一种语言无关、平台无关、可扩展的序列化结构化数据的方法, 可以像 XML, json 等一样用于程序间数据通信. 而相较于上列二者, Protobuf 有更高的效率.\n\n使用 Protobuf 需要在 `.proto` 文件中定义数据结构, 并安装其编译器来生成对应语言的模型. 本文以 Go 为例.\n\n<!-- more -->\n### 安装\n\n::: tip\n本文环境:\n\n- Debian 12 amd64\n- Go 1.21.3\n- Protoc 24.4\n:::\n\n安装 Protobuf 编译器最简单的方法是在 [Github Release](https://github.com/protocolbuffers/protobuf/releases) 页面下载对应平台的二进制文件, 并加入 `PATH` 环境变量.\n\n```bash\nwget https://github.com/protocolbuffers/protobuf/releases/download/v24.4/protoc-24.4-linux-x86_64.zip\nmkdir protoc && unzip protoc-24.4-linux-x86_64.zip -d protoc\nexport PATH=$PATH:/path/to/protoc/bin # 将此行加入终端配置文件中\n```\n\n为了在 Go 中使用 Protobuf 和默认使用 Protobuf 的 gRPC, 还需要安装 `protoc-gen-go` 和 `protoc-gen-go-grpc`\n\n```bash\ngo install google.golang.org/protobuf/cmd/protoc-gen-go@latest\ngo install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest\nexport PATH=\"$PATH:$(go env GOPATH)/bin\" # 把 GOBIN 加入 PATH\n```\n\n### 语法和规范\n\nProtobuf 的主要语法很简单也很 Go, 下例:\n\n```proto\nsyntax = \"proto3\"; // 指定版本\n\noption go_package = \"example/proto\"; // 指定 Go 代码生成的包名\n\npackage artwork; // 包名, 用于区分不同的 proto 文件. 注意此包名并不是 Go 中的包名\n\n// 定义消息类型\nmessage ArtworkInfo {\n    uint64 artworkID = 1; \n    string title = 2;\n    SourceName source = 3; // 引用枚举类型\n    repeated string tags = 4; // repeated 表示为数组\n    bool r18 = 5;\n    repeated PictureInfo pictures = 6; // 引用嵌套消息类型\n\n    // 定义枚举类型\n    enum SourceName {\n        Pixiv = 0;\n        Twitter = 1;\n        // ...\n    }\n\n    // 定义嵌套消息类型\n    message PictureInfo {\n        uint64 pictureID = 1;\n        uint64 width = 2;\n        uint64 height = 3;\n    }\n}\n```\n\n可以看到 Proto 的消息定义和 Go 的结构体定义很像, 简要总结:\n\n- 消息类型定义: `message` 关键字 + 消息名, 在大括号内定义字段\n- 字段定义: 字段类型, 字段名, 编号. 编号是不可省略且在同一消息定义下不可重复的. 可以理解成字段的唯一ID.\n\n在规范上, Protobuf 有如下约定:\n\n- 包名应为小写, 且使用和目录结构一致的点分法, 如 `example.package`\n- 使用驼峰命名法命名消息类型和服务, 如 `ExampleMessage`, `ExampleService`\n- 使用蛇形命名法命名字段, 如 `example_field`\n- 使用双斜杠注释, 如 `// 注释内容`\n\n关于 Protobuf 的数据类型和各语言中的对应, 可以参考 [官方文档#scalar](https://developers.google.com/protocol-buffers/docs/proto3#scalar)\n\n### 编译生成 Go 代码\n\n在 `.proto` 文件所在目录下执行:\n\n```bash\nprotoc --go_out=. example.proto\n```\n\nprotoc 会在当前目录下生成 `proto/example.pb.go` 文件, 其中包含了 `example.proto` 中定义的消息类型, 并且提供了一些方便的方法.\n\n由 protoc 生成的文件不应直接修改, 如需更改, 应修改 `.proto` 文件后重新编译生成.\n\nProtobuf 常与 gRPC 结合使用, 作为服务之间远程调用的数据传输格式.\n\n## gRPC\n\n[gRPC](https://grpc.io/) 是一个基于 HTTP/2 的\"高性能、开源和通用的 [RPC](https://zh.wikipedia.org/wiki/远程过程调用) 框架\". gRPC 默认使用 Protobuf 作为接口定义语言和数据传输格式.\n\ngRPC、 Protobuf 和 Go 都是由 Google 开发的, ~~这三者结合使用具有套装效果.~~\n\n### 安装\n\n在项目目录下执行:\n\n```bash\ngo get -u google.golang.org/grpc\n```\n\n### 定义 gRPC 服务和方法\n\n定义一个服务, 并指定其可以被远程调用的方法, 以及方法的参数和返回值类型. 这即是 gRPc 定义服务的思想.\n\n在上文的 `example.proto` 中定义一个服务:\n\n```proto\nsyntax = \"proto3\"; // 指定版本\n\noption go_package = \"example/proto\"; // 指定 Go 代码生成的包名\n\npackage artwork; // 包名, 用于区分不同的 proto 文件. 注意此包名并不是 Go 中的包名\n\n// 定义消息类型\nmessage ArtworkInfo {\n    uint64 artworkID = 1; \n    string title = 2;\n    SourceName source = 3; // 引用枚举类型\n    repeated string tags = 4; // repeated 表示为数组\n    bool r18 = 5;\n    repeated PictureInfo pictures = 6; // 引用嵌套消息类型\n\n    // 定义枚举类型\n    enum SourceName {\n        Pixiv = 0;\n        Twitter = 1;\n        // ...\n    }\n\n    // 定义嵌套消息类型\n    message PictureInfo {\n        uint64 pictureID = 1;\n        uint64 width = 2;\n        uint64 height = 3;\n    }\n}\n\nmessage GetArtworkInfoRequest { // [!code ++]\n    uint64 artworkID = 1; // [!code ++]\n} // [!code ++]\n\n// 定义服务 // [!code ++]\nservice ArtworkService { // [!code ++]\n    // 定义方法 // [!code ++]\n    rpc GetArtworkInfo (GetArtworkInfoRequest) returns (ArtworkInfo);// [!code ++]\n} // [!code ++]\n```\n\n#### gRPC 方法\n\ngRPC 有四种方法类型:\n\n1. 一元方法\n2. 服务端流式方法\n3. 客户端流式方法\n4. 双向流式方法\n\n##### 一元方法\n\n一元方法是最简单常用的方法. 客户端将请求消息作为参数发送给服务, 服务返回一个响应消息. 一元方法调用完成.\n\n在实际代码中, 一元方法的调用就像是调用一个普通的函数.\n\n上文的 `GetArtworkInfo` 方法就是一个一元方法.\n\n##### 服务端流式方法\n\n服务端流式方法是指客户端发送一个请求消息, 服务端返回一个流式响应消息. 客户端从返回的流中读取响应消息, 直到没有消息为止.\n\n定义流式方法, 需要在参数或返回值前加上 `stream` 关键字.\n\n例如, 定义一个 `GetArtworkInfoList` 方法, 用于获取多个作品的信息:\n\n```proto\nsyntax = \"proto3\"; // 指定版本\n\noption go_package = \"example/proto\"; // 指定 Go 代码生成的包名\n\npackage artwork; // 包名, 用于区分不同的 proto 文件. 注意此包名并不是 Go 中的包名\n\n// 定义消息类型\nmessage ArtworkInfo {\n    uint64 artworkID = 1; \n    string title = 2;\n    SourceName source = 3; // 引用枚举类型\n    repeated string tags = 4; // repeated 表示为数组\n    bool r18 = 5;\n    repeated PictureInfo pictures = 6; // 引用嵌套消息类型\n\n    // 定义枚举类型\n    enum SourceName {\n        Pixiv = 0;\n        Twitter = 1;\n        // ...\n    }\n\n    // 定义嵌套消息类型\n    message PictureInfo {\n        uint64 pictureID = 1;\n        uint64 width = 2;\n        uint64 height = 3;\n    }\n}\n\nmessage GetArtworkInfoRequest {\n    uint64 artworkID = 1;\n}\n\n// 定义服务\nservice ArtworkService {\n    // 定义方法\n    rpc GetArtworkInfo (GetArtworkInfoRequest) returns (ArtworkInfo);\n    rpc GetArtworkInfoList (GetArtworkInfoRequest) returns (stream ArtworkInfo); // 定义流式方法 //[!code ++]\n}\n```\n\n##### 客户端流式方法\n\n与服务端流式方法相反, 客户端向数据流中写入并发送一系列消息, 服务端从流中读取这些消息, 直到没有消息为止, 然后返回一个响应消息.\n\n在方法参数前加上 `stream` 关键字即可定义客户端流式方法.\n\n##### 双向流式方法\n\n双向流式方法是指客户端和服务端都可以通过一个读写数据流来发送一系列消息. 这两个流独立运行, 因此客户端和服务端可以以任意顺序读写: 例如, 服务端可以在写入响应前等待接收所有客户端消息, 或者可以先读取一个消息, 然后再写入一个消息, 或者读取或写入多个消息, 甚至可以同时读写.\n\n在方法参数和返回值前加上 `stream` 关键字即可定义双向流式方法.\n\n### 生成 Go 代码\n\n上文所述的内容都还是在 `proto` 文件中完成, 要想在 Go 中使用, 还需要生成 Go 代码.\n\n在项目目录下执行:\n\n```bash\nprotoc --go_out=. --go-grpc_out=. example.proto\n```\n\nprotoc 会在当前目录下生成 `proto/example.pb.go` 和 `proto/example_grpc.pb.go` 两个文件, 前者包含了 `example.proto` 中定义的消息类型, 后者包含了 `example.proto` 中定义的服务和方法.\n\n### 服务端实现\n\n实现上文定义的 `ArtworkService` 服务, 需要做两部分工作:\n\n1. 实现 `ArtworkService` 服务中定义的所有方法. 即实现 `example_grpc.pb.go` 中的 `ArtworkServiceServer` 接口.\n2. 运行一个 gRPC 服务器, 监听来自客户端的请求并返回响应.\n\n#### 实现服务方法\n\n打开 `example_grpc.pb.go` 文件, 可以看到 `ArtworkServiceServer` 接口的定义:\n\n```go\n// ArtworkServiceServer is the server API for ArtworkService service.\n// All implementations must embed UnimplementedArtworkServiceServer\n// for forward compatibility\ntype ArtworkServiceServer interface {\n GetArtworkInfo(context.Context, *GetArtworkInfoRequest) (*ArtworkInfo, error)\n GetArtworkInfoList(*GetArtworkInfoRequest, ArtworkService_GetArtworkInfoListServer) error\n mustEmbedUnimplementedArtworkServiceServer()\n}\n```\n\n在项目中导入 `example/proto` 包, 并实现 `ArtworkServiceServer` 接口:\n\n```go\npackage main\n\nimport (\n    \"context\"\n    \"log\"\n    \"net\"\n\n    \"example/proto\"\n    \"google.golang.org/grpc\"\n)\n\ntype ArtworkServiceServer struct {\n    proto.UnimplementedArtworkServiceServer // 为了实现向前兼容, 需要嵌入此结构体\n}\n\nfunc (s *ArtworkServiceServer) GetArtworkInfo(ctx context.Context, req *proto.GetArtworkInfoRequest) (*proto.ArtworkInfo, error) {\n    // 实现\n    return &proto.ArtworkInfo{}, nil\n}\n\nfunc (s *ArtworkServiceServer) GetArtworkInfoList(req *proto.GetArtworkInfoRequest, stream proto.ArtworkService_GetArtworkInfoListServer) error {\n    // 实现\n    for i := 0; i < 10; i++ {\n        err := stream.Send(&proto.ArtworkInfo{})\n        if err != nil {\n            return err\n        }\n    }\n    return nil\n}\n\nvar server = &ArtworkServiceServer{}\n\nfunc main() {\n}\n```\n\n可以看到, 流式方法和一元方法的区别在于, 流式方法的参数或返回值是一个流, 需要向流中写入或读取消息.\n\n```go {4}\nfunc (s *ArtworkServiceServer) GetArtworkInfoList(req *proto.GetArtworkInfoRequest, stream proto.ArtworkService_GetArtworkInfoListServer) error {\n    // 实现\n    for i := 0; i < 10; i++ {\n        err := stream.Send(&proto.ArtworkInfo{})\n        if err != nil {\n            return err\n        }\n    }\n    return nil\n}\n```\n\n#### 运行 gRPC 服务器\n\n在 `main` 函数中, 创建一个 gRPC 服务器, 并注册 `ArtworkServiceServer`:\n\n```go\nfunc main() {\n    lis, err := net.Listen(\"tcp\", \":8080\")\n    if err != nil {\n        log.Fatalf(\"failed to listen: %v\", err)\n    }\n    s := grpc.NewServer()\n    proto.RegisterArtworkServiceServer(s, server)\n    if err := s.Serve(lis); err != nil {\n        log.Fatalf(\"failed to serve: %v\", err)\n    }\n}\n```\n\n::: warning\n此处没有使用任何安全措施\n:::\n\n### 客户端调用\n\n在客户端调用 gRPC 服务, 只需要初始化连接, 并创建客户端, 然后直接调用定义的方法.\n\n```go\npackage main\n\nimport (\n    \"context\"\n    \"log\"\n\n    \"example/proto\"\n    \"google.golang.org/grpc\"\n    \"google.golang.org/grpc/credentials/insecure\"\n)\n\nfunc main() {\n    conn, err := grpc.Dial(\"localhost:8080\", grpc.WithTransportCredentials(insecure.NewCredentials()))\n    if err != nil {\n        log.Fatalf(\"did not connect: %v\", err)\n    }\n    defer conn.Close()\n    client := proto.NewArtworkServiceClient(conn)\n    resp, err := client.GetArtworkInfo(context.Background(), &proto.GetArtworkInfoRequest{ArtworkID: 1})\n    if err != nil {\n        log.Fatalf(\"could not get artwork info: %v\", err)\n    }\n    log.Println(resp)\n}\n```\n\n而对于流式方法, 客户端需要从流中读取响应消息, 直到没有消息为止.\n\n```go {24-28}\npackage main\n\nimport (\n    \"context\"\n    \"log\"\n    \"io\"\n\n    \"example/proto\"\n    \"google.golang.org/grpc\"\n    \"google.golang.org/grpc/credentials/insecure\"\n)\n\nfunc main() {\n    conn, err := grpc.Dial(\"localhost:8080\", grpc.WithTransportCredentials(insecure.NewCredentials()))\n    if err != nil {\n        log.Fatalf(\"did not connect: %v\", err)\n    }\n    defer conn.Close()\n    client := proto.NewArtworkServiceClient(conn)\n    stream, err := client.GetArtworkInfoList(context.Background(), &proto.GetArtworkInfoRequest{ArtworkID: 1})\n    if err != nil {\n        log.Fatalf(\"could not get artwork info: %v\", err)\n    }\n    for {\n        resp, err := stream.Recv()\n        if err == io.EOF { // 判断是否已结束\n            break\n        }\n        if err != nil {\n            log.Fatalf(\"could not get artwork info: %v\", err)\n        }\n        log.Println(resp)\n    }\n}\n```\n\n## 参考\n\n- [gRPC Docs](https://grpc.io/docs/)\n- [Protocol Buffers Docs](https://protobuf.dev/programming-guides/proto3/)\n"},{"title":"Go 的 gRPC 和 Protocol Buffers---TLS 认证","tags":["代码","Go","gRPC","Protobuf"],"categories":"小技术","author":"Krau","excerpt":"\n## 前言\n\n为了保证 gRPC 服务不被第三方监听和调用, 防止通信被篡改或伪造, 需要对 gRPC 服务添加身份验证机制.\n\n目前 gRPC 内置了三种身份验证机制:\n\n- **SSL/TLS**: gRPC 集成了 SSL/TLS, 提倡使用 SSL/TLS 对服务器进行身份验证, 并对客户端与服务器之间交换的所有数据进行加密。同时可选让客户端提供用于相互验证的证书.\n- **基于 Token 的身份验证**: gRPC 提供了一种可将基于元数据的凭证附加到请求和响应中的机制. 这种机制必须与 SSL/TLS 同时使用, 以提供完整的身份验证和加密通信.\n- **ATLS**: Google 自家的双向身份验证和传输安全系统, 通常也用于在 Google 家的平台上构建服务时.\n\n本文介绍 gRPC 中的 SSL/TLS.\n\n","link":"/posts/grpc-and-protobuf-in-go-tls","content":"\n## 前言\n\n为了保证 gRPC 服务不被第三方监听和调用, 防止通信被篡改或伪造, 需要对 gRPC 服务添加身份验证机制.\n\n目前 gRPC 内置了三种身份验证机制:\n\n- **SSL/TLS**: gRPC 集成了 SSL/TLS, 提倡使用 SSL/TLS 对服务器进行身份验证, 并对客户端与服务器之间交换的所有数据进行加密。同时可选让客户端提供用于相互验证的证书.\n- **基于 Token 的身份验证**: gRPC 提供了一种可将基于元数据的凭证附加到请求和响应中的机制. 这种机制必须与 SSL/TLS 同时使用, 以提供完整的身份验证和加密通信.\n- **ATLS**: Google 自家的双向身份验证和传输安全系统, 通常也用于在 Google 家的平台上构建服务时.\n\n本文介绍 gRPC 中的 SSL/TLS.\n\n<!-- more -->\n\n::: tip\n本文环境\n- Debian 12 amd64\n- Go 1.21.3\n:::\n\n## SAN, CA 和证书\n\n使用 TLS 就需要证书. 在 Go 1.15 版本之后废弃了 `CommonName`, 而是要使用 `Subject Alternative Name` (SAN) 来验证证书的有效性. 因此如果按照以前的方法生成证书, 大概率会导致下面的错误:\n\n> `rpc error: code = Unavailable desc = connection error: desc = \"transport: authentication handshake failed: x509: certificate relies on legacy Common Name field, use SANs or temporarily enable Common Name matching with GODEBUG=x509ignoreCN=0\"`\n\n\nSAN 是 x509 定义中的一个扩展, 用于指定证书的使用范围. 使用了 SAN 扩展的证书, 可以在证书中指定多个域名或 IP 地址, 从而可以在一个证书中同时包含多个域名或 IP 地址.\n\nCA (Certificate Authority), 即证书颁发机构, 用于管理和签发证书. 作用是检查证书持有者的合法性, 并颁发证书, 防止证书被伪造.\n\nCA 自己也需要有证书, 称为根证书, 用于签发其他证书. 一般情况下, 根证书是自签名的, 即自己给自己签发证书. 根证书是信任链的起点, 有了根证书之后 CA 才能给其他人签发证书.\n\n因此, 要想在 gRPC 中使用 TLS, 需要准备三组证书:\n\n- CA 根证书\n- 服务端证书\n- 客户端证书\n\n## 生成证书\n### 生成 CA 证书\n\n在任意目录下创建 `ca.conf` 文件:\n\n```ini\n[ req ]\ndefault_bits       = 4096\ndistinguished_name = moe\n\n[ moe ]\ncountryName                 = GB\ncountryName_default         = BeiJing\nstateOrProvinceName         = State or Province Name (full name)\nstateOrProvinceName_default = BeiJing\nlocalityName                = Locality Name (eg, city)\nlocalityName_default        = NanJing\norganizationName            = Organization Name (eg, company)\norganizationName_default    = Kompany\ncommonName                  = krau.top\ncommonName_max              = 64\ncommonName_default          = krau.top\n```\n\n执行下面的命令生成 CA 私钥:\n\n```bash\nopenssl genrsa -out ca.key 4096\n```\n\n然后生成 CA 证书:\n\n```bash\nopenssl req -new -x509 -days 3650 -key ca.key -out ca.crt -config ca.conf\n```\n\n根据提示输入各种信息, 最后会生成 `ca.crt` 文件.\n\n### 生成服务端证书\n\n新建 `server.conf`:\n\n```ini\n[ req ]\ndefault_bits       = 2048\ndistinguished_name = moe\n\n[ moe ]\ncountryName                 = Country Name (2 letter code)\ncountryName_default         = CN\nstateOrProvinceName         = State or Province Name (full name)\nstateOrProvinceName_default = JiangSu\nlocalityName                = Locality Name (eg, city)\nlocalityName_default        = NanJing\norganizationName            = Organization Name (eg, company)\norganizationName_default    = ovocom\ncommonName                  = CommonName (e.g. server FQDN or YOUR name)\ncommonName_max              = 64\ncommonName_default          = localhost # 此值应该包含在 [alt_names] 中\n[ req_ext ]\nsubjectAltName = @alt_names\n[alt_names]\nDNS.1   = localhost\nIP      = 127.0.0.1\n```\n\n::: warning\n`commonName_default` 的值应该包含在 `[alt_names]` 中, 并且在连接时, 客户端的值需要与其匹配.\n:::\n\n生成私钥:\n\n```bash\nopenssl genrsa -out server.key 2048\n```\n\n生成 csr:\n\n```bash\nopenssl req -new -key server.key -out server.csr -config server.conf\n```\n\n请求 CA 签发证书:\n\n```bash\nopenssl x509 -req -days 3650 -in server.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out server.crt -extensions req_ext -extfile server.conf\n```\n\n### 生成客户端证书\n\n客户端不需要配置文件, 直接生成私钥:\n\n```bash\nopenssl genrsa -out client.key 2048\n```\n\n生成 csr:\n\n```bash\nopenssl req -new -key client.key -out client.csr\n```\n\n请求 CA 签发证书:\n\n```bash\nopenssl x509 -req -days 3650 -in client.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out client.crt\n```\n\n现在已经准备好证书了. 服务端需要 `server.crt` 和 `server.key`, 客户端需要 `client.crt` 和 `client.key`. 此外, 两者都需要 `ca.crt`.\n\n## 实现\n### 服务端\n\n关注高亮行\n\n```go {17,23-24,29,33-38}\npackage main\n\nimport (\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n\t\"net\"\n\t\"os\"\n    \"fmt\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials\"\n    \"example/proto\"\n)\n\nfunc main() {\n\n\tpair, err := tls.LoadX509KeyPair(\"./server.crt\", \"./server.key\")\n\tif err != nil {\n\t\tfmt.Printf(\"Failed to load certificates: %s\", err)\n\t\treturn\n\t}\n\n\tcertPool := x509.NewCertPool()\n\tca, err := os.ReadFile(\"./ca.crt\") // 读取根证书\n\tif err != nil {\n\t\tfmt.Printf(\"Failed to read ca certificate: %s\", err)\n\t\treturn\n\t}\n\tif ok := certPool.AppendCertsFromPEM(ca); !ok {\n\t\tfmt.Println(\"Failed to append ca certificate\")\n\t\treturn\n\t}\n\tcreds := credentials.NewTLS(&tls.Config{\n\t\tCertificates: []tls.Certificate{pair},\n\t\tClientAuth:   tls.RequireAndVerifyClientCert,\n\t\tClientCAs:    certPool,\n\t})\n\ts := grpc.NewServer(grpc.Creds(creds))\n\n\tproto.RegisterArtworkServiceServer(s, &server{})\n\tlis, err := net.Listen(\"tcp\", \":39010\")\n    if err != nil {\n        fmt.Printf(\"Failed to listen: %s\", err)\n        return\n    }\n\tif err := s.Serve(lis); err != nil {\n\t\tfmt.Printf(\"Failed to serve: %s\", err)\n\t\treturn\n\t}\n}\n```\n\n### 客户端\n\n关注高亮行\n\n```go {15,20-21,26,30-35}\npackage main\n\nimport (\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n\t\"os\"\n\n\t\"example/proto\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials\"\n)\n\n\nfunc main() {\n\tpair, err := tls.LoadX509KeyPair(\"./client.crt\", \"./client.key\")\n\tif err != nil {\n\t\tfmt.Printf(\"Failed to load certificates: %s\", err)\n\t\treturn\n\t}\n\tcertPool := x509.NewCertPool()\n\tca, err := os.ReadFile(\"./ca.crt\")\n\tif err != nil {\n        fmt.Printf(\"Failed to read ca certificate: %s\", err)\n\t\treturn\n\t}\n\tif ok := certPool.AppendCertsFromPEM(ca); !ok {\n\t\tfmt.Println(\"Failed to append ca certificate\")  \n\t\treturn\n\t}\n\tcred := credentials.NewTLS(&tls.Config{\n\t\tCertificates: []tls.Certificate{pair},\n\t\tServerName:   \"localhost\", // 服务端生成证书时的 commonName\n\t\tRootCAs:      certPool,\n\t})\n\tconn, err := grpc.Dial(\"127.0.0.1:39010\", grpc.WithTransportCredentials(cred))\n\tif err != nil {\n\t\tfmt.Printf(\"Failed to dial: %s\", err)\n\t\treturn\n\t}\n\tdefer conn.Close()\n    client := proto.NewArtworkServiceClient(conn)\n    // ...\n}\n```\n\n## 参考\n\n- [gRPC Authentication](https://grpc.io/docs/guides/auth/)"},{"title":"使用官方脚本一键安装docker|安装docker-compose","tags":["linux","docker"],"categories":"小技术","author":"Krau","excerpt":"\n## 安装docker\n\ndocker官方提供了傻瓜式安装脚本，为你做好所有工作，免去了手动安装的繁琐。\n\n本文实测系统环境：debian11\n\n执行以下命令\n\n::: tip 2023-03-07\n\n不知道从什么时候开始官方脚本已经默认也安装了 `docker compose`, 不需要后面的手动安装了, 因此已删除多余的内容\n\n也就是说, 只需要执行下面的一键脚本\n\n注意是 `docker compose` 而不是 `docker-compose`. 执行命令时候也没有这个杠\n\n:::\n\n```shell\ncurl -fsSL https://get.docker.com | bash -s docker\n```\n\n可在此命令后附带`--mirror`参数设置镜像源，以提高国内服务器下载docker的速度\n\n如使用阿里云镜像:\n\n```shell\ncurl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun\n```\n\n","link":"/posts/install-docker-one-key","content":"\n## 安装docker\n\ndocker官方提供了傻瓜式安装脚本，为你做好所有工作，免去了手动安装的繁琐。\n\n本文实测系统环境：debian11\n\n执行以下命令\n\n::: tip 2023-03-07\n\n不知道从什么时候开始官方脚本已经默认也安装了 `docker compose`, 不需要后面的手动安装了, 因此已删除多余的内容\n\n也就是说, 只需要执行下面的一键脚本\n\n注意是 `docker compose` 而不是 `docker-compose`. 执行命令时候也没有这个杠\n\n:::\n\n```shell\ncurl -fsSL https://get.docker.com | bash -s docker\n```\n\n可在此命令后附带`--mirror`参数设置镜像源，以提高国内服务器下载docker的速度\n\n如使用阿里云镜像:\n\n```shell\ncurl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun\n```\n\n<!-- more -->"},{"title":"使用conda安装和管理python多版本环境","tags":["Python"],"categories":"小技术","author":"Krau","excerpt":"\n~~感觉不如编译安装~~\n\n","link":"/posts/manage-python-version-by-conda","content":"\n~~感觉不如编译安装~~\n\n<!-- more -->\n\n## conda\n\nconda 是一个 python 的环境管理器, 它包含在 [Anaconda](https://www.anaconda.com/) 内, Anaconda 是专注于数据分析的Python发行版本.\n\n即使你没有数据分析\\科学计算的需求, 也可以使用 conda 这个强大的工具来管理 python 环境\n\n如果你不想安装这么大一个东西, 可以看我上次发的使用 [venv + 编译安装的方式管理python环境](./install-manage-python-version-on-linux.md)\n\n## 安装\n\n去[Anaconda官网](https://www.anaconda.com/products/distribution#Downloads)下载\n\n或者你可以选择 [Miniconda](https://docs.conda.io/en/latest/miniconda.html)\n\n```shell\nwget https://repo.anaconda.com/archive/Anaconda3-2023.03-Linux-x86_64.sh\n```\n\n下载完成后, 执行 `bash Anaconda3-2023.03-Linux-x86_64.sh` 即可开始安装\n\n安装完成后, 重启终端, 即可使用 conda\n\n## 使用\n\n更新\n\n```shell\nconda update --all \n```\n\n创建虚拟环境\n\n```shell\nconda create -n <name> python=<version>\n```\n\n-n 后是虚拟环境的名字, python=version 指定要使用的 python 版本\n\n激活环境\n\n```shell\nconda activate <name>\n```\n\n退出虚拟环境\n\n```shell\nconda deactivate\n```\n\n删除虚拟环境\n\n```shell\nconda env remove <name>\n```\n\n列出虚拟环境\n\n```shell\nconda env list\n```\n\n列出当前环境的包\n\n```shell\nconda list\n```\n\n安装包, 和 pip 一样\n\n```shell\nconda install <package>\n```\n"},{"title":"往事 · 小狗","tags":["记忆"],"categories":"日常","author":"Krau","excerpt":"\n忘了具体是在小学几年级的时候，家里抓回来了两三只小狗。也忘了是从哪里抓回来的，是怎么抓回来的，只依稀记得它们似乎没有妈妈。\n\n它们不到一个月大，身上都是白色的毛，就像当时冬季的雪，惹人可爱又可怜。爸","link":"/posts/memory-dog","content":"\n忘了具体是在小学几年级的时候，家里抓回来了两三只小狗。也忘了是从哪里抓回来的，是怎么抓回来的，只依稀记得它们似乎没有妈妈。\n\n它们不到一个月大，身上都是白色的毛，就像当时冬季的雪，惹人可爱又可怜。爸爸找来一个箱子，垫上了好几层棉花，为它们做成了一个小窝。可是妈妈见了之后，说“它们养不活”。理由是太小了，又没有母狗，天这么冷，它们会冻死。\n\n天真的我不服气，我想我一定能把它们好好养大的，成为活蹦乱跳的小狗。\n\n但是它们真的太柔弱了。那个小窝根本不能让它们暖和起来，蜷缩在箱子里的身体还是几乎冻僵。于是爸爸又用一个瓶子装上热水，垫到了棉花下面。水的热量又让它们有了一些生机，小脑袋又开始扭动起来，寻找母乳。我以为这样子能让它们撑过冬季。\n\n只过了两天，它们短暂的生命终结在了寒冬。\n\n那是我放学回来，迫不及待地去看看它们的状态，它们已经没有了动静，身上冰冷，但还有微弱的呼吸。我慌忙去取热水，想像爸爸做的那样，使它们暖和起来。可是水壶里没有热水。\n\n这时妈妈过来了，看见那几只奄奄一息的小狗，便要埋了它们。“它们还有呼吸呢！”，我抗议起来，但妈妈已经在院子里的老杏树下面为它们掘墓。\n\n我找到给它们喂奶用的奶瓶，抵在它们的嘴边，可是没有任何反应。我清楚的记得那时我一直在小声呼喊“快喝啊，张开嘴啊”，不知道是自言自语还是呼唤这几只狗的生命。\n\n它们终究还是被埋在了覆着白雪的杏树下，带着一丝微弱的呼吸和冻僵的身躯，以及被我的泪水打湿的白毛。"},{"title":"ray-mmd渲染基本流程","tags":["3D","MMD"],"categories":"小技术","author":"Krau","excerpt":"\n![preview](https://pic.downk.cc/item/5f119a0214195aa59417256d.png)\n","link":"/posts/mmdray-basic-rendering","content":"\n![preview](https://pic.downk.cc/item/5f119a0214195aa59417256d.png)\n<!-- more -->\n\n## Download\n\n前往[github](https://github.com/ray-cast/ray-mmd)下载最新版ray mmd\n注意：不仅仅是打包下载code就完事的，还需要去下载各项扩展（详见github仓库下的readme）\n\n![](https://pic.downk.cc/item/5f116ea214195aa5940a510c.jpg)\n\n下载完成后解压ray和各个扩展，把扩展文件分别复制到ray主目录中对应的文件夹中\n\n## 渲染基本流程\n\n载入人物，场景等数据后，就可以开始ray渲染了\n但在这之前，还需要在mmd显示菜单中，关闭地面阴影显示，抗锯齿和各向异性过滤\n![](https://pic.downk.cc/item/5f11705414195aa5940ae29c.jpg)\n*因为ray是自带抗锯齿和阴影的，如果不关则会导致一些难以名状的画面和性能问题*\n\n第一步需要向mmd中丢入ray根目录下的ray.x和ray_controller.pmx，这两个分别是ray环境和ray控制器\n\n![](https://pic.downk.cc/item/5f1171fa14195aa5940b7b3b.jpg)\n\n然后放入ray/skybox目录下的任意一个天空盒，它应该是以.pmx为后缀的文件。\n此处以**Time of day**为例。\n丢入之后在背景>模型描绘顺序中调整人物，场景，和skybox的顺序\n这三个的正确相对顺序应为\n\nskybox\nstage（场景）\nmodel（人物）\n\n![](https://pic.downk.cc/item/5f11739b14195aa5940c0ba1.jpg)\n\n然后在右上角MMEffect中添加渲染\n\n在mian栏中，为场景和人物添加 main 文件夹内的 main.fx（主渲染）\n\n![](https://pic.downk.cc/item/5f1174ee14195aa5940c6dbe.jpg)\n\n在Envlightmap（环境）栏中，为 skybox 添加渲染\n\n![](https://pic.downk.cc/item/5f11767114195aa5940d1714.jpg)\n\n在Fogmap（雾气）栏中，为 skybox 添加雾气效果渲染\n\n![](https://pic.downk.cc/item/5f1177b014195aa5940d801d.jpg)\n\n用方框框起来的三个均为 fogmap 对应的渲染，只需要选择一个添加就可以，一般选择 Time of fog with godray with cloud caster（名字越长越nb）\n\n在materials栏中，为skybox渲染正确的材质\n![](https://pic.downk.cc/item/5f119aac14195aa59417535e.jpg)\n\n至此，再稍微调整一下打光和一些参数，就算完成了ray渲染的最基本步骤，现在的画面相较于未渲染的画面已经耐看多了\n\nbefore：\n![](https://pic.downk.cc/item/5f119e2914195aa5941855c6.jpg)\n\nnow：\n![](https://pic.downk.cc/item/5f119d2814195aa594180924.jpg)\n\n但这只是最基本的套用渲染的流程，相较于无渲染也就是从看不了提升为了勉强能看，要想做出真正好康的mmd，仅仅这些是完全不行的\n\n对于接触mmd时间不长的新手来说，没必要去详细了解每个概念，需要的是自己不断尝试，去感受那些渲染功能的具体作用。所以一开始更好的学mmd方法是，什么都不管，跟着做就好了。\n"},{"title":"ray-mmd制作法线贴图","tags":["MMD","3D"],"categories":"小技术","author":"Krau","excerpt":"\n如何使材质贴图更有层次感？\n\n这就需要制作相应的[法线贴图](https://zh.wikipedia.org/wiki/%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE)\n\n本文以YYB式初音未来为例，制作相应的法线贴图，使用ray渲染的版本为1.5.2\n\n","link":"/posts/mmdray-normal-map","content":"\n如何使材质贴图更有层次感？\n\n这就需要制作相应的[法线贴图](https://zh.wikipedia.org/wiki/%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE)\n\n本文以YYB式初音未来为例，制作相应的法线贴图，使用ray渲染的版本为1.5.2\n\n<!-- more -->\n\n---\n\n在制作法线贴图之前，首先要在MMD导入相应的模型，并完成ray渲染的基本流程，方便以下的对比操作，以寻找合适的参数。\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20210813091507.png)\n\n在模型的目录中，找到需要制作的贴图，文件夹名一般为`Texture`\n\n然后使用ps导入贴图，选择滤镜>3D>生成法线图\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20210813093103.png)\n\n导出为png格式，文件名应是英文\n\n在`~/ray-mmd-1.5.2/Materials`目录中，找到`material_2.0.fx`、`material_common_2.0.fxsub`两个文件，复制到模型目录中的材质贴图文件夹\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20210813093713.png)\n\n然后重命名`material_2.0.fx`文件为`{你所导出的法线贴图的文件名}.fx`\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20210813094047.png)\n\n打开重命名后的该fx文件，在第28行左右找到`#define NORMAL_MAP_FROM 0`，将0修改为1以启用法线贴图。并更改`#define NORMAL_MAP_FILE \"normal.png\"\n`中的\"normal\"为法线贴图文件名\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20210813094408.png)\n\n然后保存，在mmd中，在`MaterialMap`栏中，展开所修改的模型，找到对应的贴图，为其添加法线贴图效果\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20210813094739.png)\n\n此时可以对照mmd中的效果调整fx文件中的参数，修改参数后保存文件，即可在mmd中预览到效果。\n\n几个参数的作用：\n\n- const float normalMapScale = 1.0;\n法线效果强度，该参数越大，层次感越明显（下图为将该参数设置为5.0的效果）\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20210813095248.png)\n\n- #define SMOOTHNESS_MAP_TYPE 0\n法线效果平滑度，该参数越大，发现效果显示越平滑，同时颗粒感与湿润感也会更强（多用于场景）\n\n---\n\ntips：\n\n1. 如果需要为同一模型的多个材质贴图添加法线贴图效果，只需要为每个法线贴图复制一个`material_2.0.fx`文件，并重命名为对应的文件名，而`material_common_2.0.fxsub`只在材质文件夹中保留一份即可\n2. 场景制作法线贴图与人物模型同理，但参数的调整与人物模型区别较大，需根据不同的需求进行尝试\n"},{"title":"MMD中导出带alpha通道视频的方法","tags":["MMD","3D"],"categories":"小技术","author":"Krau","excerpt":"\n## 前言\n\n 闲来无事在摸MMD，然后看到了这个\n\n [【PV背景配布/动作配布】九尾三妈式初音 - お気に召すまま\n](https://www.bilibili.com/video/BV1r74","link":"/posts/mmdray-output-videos-with-alpha","content":"\n## 前言\n\n 闲来无事在摸MMD，然后看到了这个\n\n [【PV背景配布/动作配布】九尾三妈式初音 - お気に召すまま\n](https://www.bilibili.com/video/BV1r7411u7ST)\n\n感觉这个配布的挺不错，想摸一个。\n\n但是碰到点问题：60fps的背景是单独的视频，需要通过后期软件把人物和背景的视频叠加起来，这就要一个带有alpha通道（透明）的人物视频，去网上找了一些方法，依旧踩了不少坑。\n\n## RewriteAlpha\n\n找了很多方法，感觉就这个最简单方便。\n\n首先去下载这个MME：https://bowlroll.net/file/27004\n\n这个MME可以让你随心所欲的加花里花哨的全局MME，而不会丢失透明通道\n\n下载之后**保持乱码状态解压**\n\n然后在 `RewriteAlpha` 文件夹中，往MMD里加入这个 `RewriteAlpha.x`\n\n在MMD>背景>绘制附件中，把`RewriteAlpha.x`放到最后一位\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200407205316.png)\n\n然后打开MME面板，找到`alphamap`栏，把skybox和stage的渲染关闭（取消勾选），人物模型的渲染开启，并勾选上RewriteAlpha.x的渲染\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20200407205639.png)\n\n这样就算完成了，导出的时候将会导出只有人物渲染，且背景是透明通道的视频，也可以先导出一张png看看效果。~~别渲染了半天发现不是透明通道，别问我怎么知道的~~\n\n![](https://img.asnet.top/i/2020/04/07/yrrxxj.png)\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/alphammd.png)\n"},{"title":"ray-mmd内置天空盒调整参数简介","tags":["MMD","3D"],"categories":"小技术","author":"Krau","excerpt":"\n完成ray渲染的基本流程后，就要开始调各种参数了，本篇介绍ray渲染内置的几个天空盒的参数\n![内置天空盒](https://cdn.jsdelivr.net/gh/voidoath/photo/b","link":"/posts/mmdray-skyboxs","content":"\n完成ray渲染的基本流程后，就要开始调各种参数了，本篇介绍ray渲染内置的几个天空盒的参数\n![内置天空盒](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20210812200556.png)\n\n在`模型操作`栏中，选择导入的天空盒，在表情栏即可进行其相关参数调整。\n\n以下介绍中，把表情四栏按从左到右，从上到下分成 第一栏、第二栏、第三栏、第四栏。\n\n## Helipad GoldenHour\n\n### 第一栏\n\n- Balance\n可以看到该栏中有BalanceR+-/G+-/B+-以及Gray+的调整，它们即对应色调红绿蓝（RGB）三色以及灰色的调整。\n例如，调高BalanceR+栏，画面将偏红色\n\n### 第二栏\n\n- EnvDiffLight\n该参数为天空盒的光源强度，调高该参数，天空盒对模型的影响将会变亮\n- EnvSpecLight\n该参数为漫反射强度，调高该参数，模型漫反射增强\n\n### 第三栏\n\n- Diffuse\n该栏调整漫反射色调（RGB&Gray）\n\n### 第四栏\n\n- Specular\n该栏调整镜面反射色调（与Diffuse同理）\n\n## Sky Hemisphere\n\n该天空盒初始为纯白背景，一般适用于实景合成/唯美风渲染\n\n### 第一栏\n\n- Top\n可以看到该栏中有TopH+/S+/V+-，它们调整该天空盒的顶部色调效果\n\n### 第二栏\n\n- Medium\n与第一栏同理，调整中部色调\n\n### 第三栏\n\n- Bottom\n与上同理，调整底部色调\n\n### 第四栏\n\n- EnvDiffLight\n该参数为天空盒的光源强度，调高该参数，天空盒对模型的影响将会变亮\n- EnvSpecLight\n该参数为漫反射强度，调高该参数，模型漫反射增强\n\n## Sky Night\n\n该天空盒与`Sky Hemisphere`几乎一样，区别是该天空盒带有夜晚的月亮和流星效果\n\n## Time of day\n\n### 第一栏\n\n- SunRadius\n调整太阳半径大小\n\n### 第二栏\n\n- EnvDiffLight\n该参数为天空盒的光源强度，调高该参数，天空盒对模型的影响将会变亮\n- EnvSpecLight\n该参数为漫反射强度，调高该参数，模型漫反射增强\n\n### 第三栏\n\n- MiePhase\n该参数可以影响丁达尔效应的强弱\n- FogRange\n调整雾气距离\n- FogIntensity\n该参数可以影响雾气效果强度\n\n### 第四栏\n\n- Cloud\n云的密度，调高该参数，云将增多\n- CloudSpeed\n云的流动速度\n\n## Time of night\n\n该天空盒具有夜间星空银河与流星效果，参数调整与`Time of day`基本一致。\n区别是该天空盒第四栏的参数为影响星星的效果\n"},{"title":"将旧手机通过Linuxdeploy改造为linux服务器搭建cloudreve个人网盘实现离线下载","tags":["linux","DIY"],"categories":"小技术","author":"Krau","excerpt":"\n最近因疫情闲在家，就折腾起了自己的旧手机\n\n","link":"/posts/old-phone-become-server","content":"\n最近因疫情闲在家，就折腾起了自己的旧手机\n\n<!-- more -->\n\n## 准备\n\n1. 一部已经获得root权限的手机 ~~若是ov华等无法获取root的手机，建议拿去换剪刀~~ ，本文以 redmi note7 pro 为例，已刷机安卓11类原生\n2. 一台能够使用ssh终端的设备\n\n## 安装linuxdeploy并配置\n\n下载 [linuxdeploy](https://github.com/meefik/linuxdeploy/releases)，安装到旧手机\n\n>请确保安装的linuxdeploy版本≥2.0，否则需要首先安装busybox。而2.0以上的linuxdeploy内置了busybox\n\n打开linuxdeploy软件，点击左上角按钮，选择设置，勾选【锁定wi-fi】与【CPU唤醒】，其他选项按需配置，亦可保持默认\n\n回到上一级页面，点击右下角按钮，进行以下配置：\n\n## 配置\n\n### 引导设置\n\n- 【发行版GNU/Linux】 建议选择Debian或centos，它们在linuxdeploy运行的兼容性更好\n- 【架构】一般都选择arm64（Debian）或aarch64（centos），软件也会自动识别适合你的手机的架构，若特殊情况请搜索关键词 ‘{你手机的cpu}+架构’\n- 【发行版GNU/Linux版本】按需选择，一般选择buster或stable\n- 【源地址】建议改为国内源：<http://mirrors.163.com/debian> ，保持默认亦可\n- 【安装类型】按需设置，建议选择镜像文件，因为它是一个单镜像文件\n- 【安装路径】默认为`${EXTERNAL_STORAGE}/linux.img`，一般保持默认即可\n- 【镜像大小】按需设置，若需搭建网盘服务，建议设置较大大小，可以使文件有足够的空间存储在linux镜像空间内，省去挂载手机存储的麻烦\n- 【文件系统】ext4\n- 【用户名】自行设置，建议设置为 root\n- 【用户密码】自行设置\n- 【特权用户】按需设置，一般保持默认\n- 【本地化】简体中文选择zh_CN.UTF-8，按需设置\n- 【DNS】按需设置，或保持默认\n\n### 初始化\n\n- 【启用】勾选以启用初始化功能\n- 【初始化系统】选择sysv\n- 【初始化设置】视情况设置，或保持默认\n\n### 挂载\n\nSource：手机目录\nTarget：Linux目录\n使用能够查看到真实路径的文件浏览器，复制需要挂载的目录到挂载点列表，填入第一行即可\n\n### SSH\n\n务必勾选启用SSH服务器，SSH设置按需配置\n\n### 声音服务\n\n按需配置\n\n### 图形界面\n\n按需配置\n\n---\n\n配置完成后，返回上一级，点击右上角按钮，点击安装，等待出现`<<< deploy`即安装完成。\n\n点击停止按钮并确定，再点击启动，出现`<<< start`即启动成功\n\n然后即可使用同一局域网下的ssh工具连接\n\n为了防止旧手机的内网ip地址变更，在路由设置页面进行ip与MAC绑定，并把手机wifi连接中的隐私设置相关选项改为 使用设备MAC\n\n连接后，安装常用工具\n\n`apt install wget vim curl zip -y`\n\n附：\nxshell工具家庭/学校版下载连接\n<https://www.xshell.com/zh/free-for-home-school/>\n\n## 安装并配置cloudreve\n\n项目发行地址：[cloudreve](https://github.com/cloudreve/Cloudreve/releases)\n\n截止到撰写本文（2022.01），最新版本为3.4.2\n\n执行以下命令\n\n切换到用户目录\n\n`cd /opt`\n\n创建文件夹并切换\n\n`mkdir cloudreve&&cd cloudreve`\n\n下载cloudreve\n\n`wget https://github.com/cloudreve/Cloudreve/releases/download/3.4.2/cloudreve_3.4.2_linux_arm64.tar.gz`\n\n根据需求自行选择下载的版本并替换wget后的链接\n\n解压\n\n`tar -zxvf cloudreve_3.4.2_linux_arm64.tar.gz`\n\n赋予权限\n\n`chmod +x ./cloudreve`\n\n启动\n\n`./cloudreve`\n\n在终端中会给出初始管理员账号与密码，使用该账号登录\n\n若无法访问，查看防火墙是否开放端口\n\n进入cloudreve后，点击右上角头像，进入管理面板，即可进行相关设置，具体参见[cloudreve官方文档](https://docs.cloudreve.org/)\n\n需要注意的是，在配置使用本机存储策略的用户组时，若存储目录在镜像空间内，要确保【初始容量】小于【镜像大小】，否则会无法上传任何文件\n\n## 通过aria2实现离线下载\n\ncloudreve内置了依赖于aria2的离线下载功能，因此需先进行aria2的配置\n\n### 安装并配置aria2\n\n安装\n\n`apt install aria2 -y`\n\n下载由[P3TERX](https://github.com/P3TERX)提供的aria2配置文件（亦可选择其他配置或参考[aria2官方文档](https://aria2.github.io/)自行创建）\n\n```shell\ncd\nwget https://github.com/P3TERX/aria2.conf/archive/master.zip\nunzip master.zip\n```\n\n将解压出的文件夹重命名为.aria2\n\n`mv aria2.conf-master .aria2`\n\n修改aria2配置文件\n\n`cd .aria2&&vim aria2.conf`\n\n[P3TERX](https://github.com/P3TERX) 的配置文件包含了中文注释，根据注释按需修改即可，一般需要改动的是**下载目录**、**RPC密钥**与**BT监听端口**，其他保持默认即可\n\n配置修改完成后，在.aria2目录内，执行`./tracker.sh`即可更新tracker\n\n若更新失败，可进行手动更新，参考以下tracker列表\n\nhttps://trackerslist.com/all_aria2.txt\n\n将列表内容复制到`aria2.conf`中的`bt-tracker`参数后即可\n\n创建aria2.session文件\n\n`touch aria2.session`\n\n测试aria2能否成功启动\n\n`aria2c --conf-path=/root/.aria2/aria2.conf`\n\n第一次启动需要指定配置文件，日后启动只需使用`aria2c`即可\n\n若启动成功，关闭即可，接下来进行进程保护配置，方便后续操作\n\n### 守护cloudreve与aria2进程\n\ncloudreve与aria2运行后，若关闭ssh终端，二者也会随之停止运行，因此需要进行进程守护，本文是使用 `supervisor`\n\n安装\n\n```shell\napt install python-setuptools -y\napt install supervisor -y\n```\n\n#### cloudreve\n\n为cloudreve创建配置并打开配置文件\n`sudo vim /etc/supervisor/conf.d/cloudreve.conf`\n\n将以下内容按需修改后，写入cloudreve的supervisor配置文件，具体参见[supervisor官方文档](http://supervisord.org/configuration.html)\n\n```ini\n[program:cloudreve]\ndirectory=/opt/cloudreve\ncommand=/opt/cloudreve/cloudreve\nautostart=true\nautorestart=true\nstderr_logfile=/var/log/supervisor/cloudreve.err\nstdout_logfile=/var/log/supervisor/cloudreve.log\nenvironment=CODENATION_ENV=prod\n```\n\n以上内容备注：\n程序目录=/opt/cloudreve\n运行命令(绝对路径)=/opt/cloudreve/cloudreve\n自启动=true\n自动重启=true\n错误日志保存路径=\n其他日志保存路径=\n环境=\n\n#### aria2\n\n与上同理\n\n为aria2创建配置并打开配置文件\n\n`sudo vim /etc/supervisor/conf.d/aria2.conf`\n\n将以下内容按需修改后，写入aria2的supervisor配置文件，具体参见[supervisor官方文档](http://supervisord.org/configuration.html)\n\n```ini\n[program:aria2]\ndirectory=/root/.aria2\ncommand=aria2c --conf-path=/root/.aria2/aria2.conf\nautostart=true\nautorestart=true\nstderr_logfile=/var/log/supervisor/aria2.err\nstdout_logfile=/var/log/supervisor/aria2.log\nenvironment=CODENATION_ENV=prod\n```\n\n以上内容备注：\n程序目录=/root/.aria2\n运行命令(绝对路径)=aria2c --conf-path=/root/.aria2/aria2.conf\n自启动=true\n自动重启=true\n错误日志保存路径=\n其他日志保存路径=\n环境=\n\n---\n\n启动supervisor\n\n`supervisord -c /etc/supervisor/supervisord.conf`\n\n至此便完成了进程守护配置\n\n如需管理supervisor内进程，参考以下指令：\n\n```shell\nsudo supervisorctl start cloudreve #启动    \nsudo supervisorctl stop cloudreve #停止    \nsudo supervisorctl status cloudreve #状态\n```\n\n附.网页管理supervisor进程配置：\n\n在supervisor配置文件中（/etc/supervisor/supervisord.conf），添加以下内容\n\n```ini\n[inet_http_server]\nport=127.0.0.1:8888\nusername=\npassword=\n```\n\n其中port、username、password参数可自行设置，若需外部访问，可将port设置为 `0.0.0.0:8888`\n\n### 配置开机自启动\n\n若在linuxdeploy中，初始化系统选择了sysv，则无需额外配置即可自启动supervisor及其中的程序\n若使用run-parts初始化，需额外配置.\n\n## 配置cloudreve离线下载功能\n\n登录cloudreve管理页面，选择 离线下载节点 ，修改 主机（本机） 节点\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20220125103835.png)\n\n1. 启用离线下载\n2. 参考配置\n3. RPC服务地址，由于cloudreve与aria2运行在同一台服务器（旧手机）上，故填写127.0.0.1:{prot}\n\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20220125103937.png)\n4. RPC令牌，与 Aria2 配置文件中rpc-secret保持一致\n5. 临时下载目录，填写绝对路径，并保证cloudreve具有此目录的权限\n6. 额外参数配置，一般保持默认\n\n完成配置后，点击下一步，修改杂项信息，再点击下一步，即可保存该节点配置\n\n然后点击用户组，编辑用户组配置，允许进行离线下载\n![](https://cdn.jsdelivr.net/gh/voidoath/photo/blog-img/20220125104705.png)\n\n---\n至此，所有配置完成，可在同一局域网下，打开cloudreve页面测试是否成功实现了个人云盘与离线下载功能\n"},{"title":"Python——列表、元组、字典、条件、循环、输入、函数","tags":["Python","代码"],"categories":"小技术","author":"Krau","excerpt":"\n## 列表\n\n### 列表基础\n\n```py\n#创建列表\nfriends = ['ah','leao','zhang','wang']\nprint(friends)\n\n#访问列表元素\nprint(f","link":"/posts/py3-quick-basic","content":"\n## 列表\n\n### 列表基础\n\n```py\n#创建列表\nfriends = ['ah','leao','zhang','wang']\nprint(friends)\n\n#访问列表元素\nprint(friends[0])#索引从0开始\nprint(friends[-1])#反向索引从-1开始\n\n#修改列表元素\nfriends[0] = 'ahchan'\n\n#添加与删除列表元素\nfriends.append('zhou')#在末尾添加\nfriends.insert(1,'cos0')#在指定索引位置添加\n\ndel friends[1]#使用del删除指定位置的元素\npopped_friends = friends.pop(1)#使用pop”弹出“指定位置的元素\nprint(friends)\nprint(popped_friends)\n\nfriends.remove('zhou')#根据值删除元素\n\n#组织列表\nfriends.sort()#按首字母排序,永久性的\nprint(friends)\nfriends.sort(reverse=True)#可以传入reverse参数使其逆序\nprint(friends)\n\nprint(sorted(friends))#临时按首字母排序\n\nfriends.reverse()#reverse只是反转列表元素的排列顺序\nprint(friends)\n\nprint(len(friends))#使用len()确定列表有多少元素\n```\n\n### 操作列表\n\n```py\nmembers = ['krau','ah','hanmiao']\n#for循环遍历列表\nfor member in members: #for循环将把members中的元素依次与member关联，并都执行下面的操作\n    print(member)\n    print(f'{member.title()},welcome to yuzunion!')#title()将首字母大写\n\n\n#range()生成数字序列\nfor i in range(1,10):\n    print(i)\n#这个循环将会依次打印1-9，因为range是在10停止的，不包括10\n\n#使用range()创建数字列表\nnums_list_1to10 = list(range(1,10))\nprint(nums_list_1to10)\n\n#range()指定步长（公差）\nnums_list_1to10_2 = list(range(1,10,2))#第三个数字指定了步长，即每次加2\nprint(nums_list_1to10_2)\n\n#for与range结合，可以生成各种数列。如下是整数1~10的平方\nnums_list_1to100 = []\nfor num in range(1,11):\n    nums_list_1to100.append(num**2)#**表示乘方运算\nprint(nums_list_1to100)\n\n#数字列表简单统计运算，以上面的nums_list_1to100为例\nprint(min(nums_list_1to100))#最小值\nprint(max(nums_list_1to100))#最大值\nprint(sum(nums_list_1to100))#求和\n\n#列表解析，一种一行代码生成列表的方法（其实就是合并起来写）\nlist_analysis = [value**2 for value in range(1,11)]\nprint(list_analysis)\n#这种语法的使用方法是\n# 列表名 = [表达式 for 变量 in 数列]\n\n#切片，圈定列表某一部分\nphones = ['pixel3','mix4','k20p','pixel2','honor8']\nprint(phones[0:3])#输出包含索引为0，1，2的元素的’子列表‘\nprint(phones[:3])#不指定第一个索引会自动从0开始\nprint(phones[1:])#不指定第二个索引会自动到最后\nprint(phones[:])#都不指定就是从头到尾，可利用此创建列表的副本\nphones_copy = phones[:]\nprint(phones_copy)\n#这和直接把phones赋值给phones_copy是不一样的，若直接赋值，实际上只是给同一个列表关联了两个变量名字，当修改列表时，这两个变量都会同步修改\n#例如，给phones添加一个元素\nphones.append('readmi')\n#然后看看phones和phones_copy这两个列表现在是什么样的\nprint('phones列表',phones)\nprint('phones_copy列表',phones_copy)\n#但如果直接赋值将是下面的效果\nmy_phones = phones\nphones.append('oppo')\nprint(phones)\nprint('可以看到即使是对phones进行修改，my_phones也将输出和phones一样的列表',my_phones)\n\n\n#遍历切片\nfor phone in phones[0:3]:\n    print(phone.title())\n\n\n#元组，不能变的列表\n#创建元组，使用圆括号\ndimensions = (10,20)\nprint(dimensions[0])\nprint(dimensions[1])\n\n#元组中的数据是不能被修改的，如果尝试修改将会报错，以下被注释的代码将会报错\n# dimensions[0] = 20\n#但是可以重新定义元组来修改元组的值\nl = 20\nw = 10\ndimensions = (l,w)#重新定义元组是合法的\nprint(dimensions)\n#但即使改变元组中存储的变量的值，元组也不会改变\nl = 500\nw = 200\nprint(dimensions)#可以看到元组还是没变\n\n#如果需要创建只有一个元素的元组，也需要带上逗号，因为元组使用逗号来标识\nonlyonetuple = (1,)\n\n#遍历元组，和遍历列表没有什么区别\n```\n\n## 条件语句——if\n\n```py\n#判断两个值是否相等，用==（两个等号），相等时返回True，否则返回False\nwife = 'Miku'\nprint(wife =='Miku')\n# == 判断是大小写敏感的\nprint(wife == 'miku')#将会输出False\n#如果不希望大小写影响判断，可以在判断时都转换为小写\nprint(wife.lower()=='miku')#lower()不会直接修改变量的值，只是读取变量的值并将其小写再进行后续操作\n#若要都大写可使用.upper()方法\n\n#判断是否不相等，使用!=。!常常是表示‘非’的\nprint(wife != 'Miku')\n\n#判断多条件\n#and 和，都为True时返回True\nage_0 = 16\nage_1 = 14\nprint(age_0 > 15 and age_1 <=15)\n#or 或，至少有一个真就返回真\nprint(age_0 == 15 or age_1 > 12)\n\n#in检查特定值是否在列表中，如果在，返回True\nwaifus = ['miku','ayanami','sakira']\nprint('sakira' in waifus)\n#not in检查特定值是否不在列表中，如果不在，将返回Ture\nprint('miku' not in waifus)\n\n#布尔表达式，如下\nMiku_is_my_wife = True\nKrau_love_miku = True\n\n#if-else语句\nif 'miku' in waifus:\n    print('miku is my wife')\nelse:\n    print('miku is also my wife')\n#if-elif-else语句，判断多种条件之一\nif wife == waifus[0]:\n    print(f'{waifus[0]} is my wife!'.title())#此处f'{}'可以在字符串中输出变量的值\nelif wife == waifus[1]:\n    print(f'{waifus[1]} is my wife!'.title())\nelif wife == waifus[2]:\n    print(f'{waifus[2]} is my wife!'.title())#elif可以是多个\nelse:\n    print('you are all my wife'.title())\n#else是可以省略不写的，如果省略，程序会在所有条件都不符合时不进行任何操作\n#if-elif-else结构一旦遇到为真的条件时将会执行对应的代码块，之后跳过整个结构，即使之后还有为真的条件\n#如果你不想让它这样，那不妨多写几个if\n```\n\n## 字典\n\n```py\n#创建字典，使用花括号{}\nhuman_1 = {'color':'yellow','height':175}# 用 : 关联两个值，即键值对\nprint(human_1['color'])\nprint(human_1['height'])#通过 键 查找 值 ，就是“字典”的含义\n\n#向字典中添加键值对\nhuman_1['weight'] = 65 #直接 字典[新键]=值，即可把新的键值对添加到字典末尾\nprint(human_1)\n#修改字典中的值也是类似的\nhuman_1['height'] = 180\n\n#字典可以包含任意数量的键值对，包括空字典\nhuman_2 = {}\n\n#删除键值对\n#与列表类似，可使用del\ndel human_1['color']\nprint(human_1)\n\n#字典的格式可以是多行，这会让代码更加美观，尤其是字典内容很多的时候\nhuman_2 = {\n    'height':177,\n    'weight':68,\n    'age':18,\n    'gender':'male',\n}\n\n#使用get()访问字典，避免引发错误\n#当要访问的键值对在字典中不存在时，使用方括号访问便会引发错误。\n#可以使用get()，使之返回一个默认值，避免错误\nprint(human_2.get('color','不存在该值'))\n#当color在字典中不存在时，将会输出“不存在该值”，如果不给出get()的第二个参数，将会返回None\n#遍历字典\n#遍历键值对\nfor key,value in human_2.items(): #item()方法用于返回一个键值对列表\n    print(key)\n    print(value)#可以看到，字典中的每个键和值分别 依次赋给了key和value，当然这两个变量是可以随意命名的\n\n#遍历所有键，使用keys()方法\nfor key in human_2.keys():\n    print(key)\n#实际上，默认遍历时便是只遍历所有键，但最好加上keys方法，便于阅读\n#keys()方法返回的是一个包含所有键的列表，正如题item()方法返回的是一个包含所有键值对的列表\n\n#遍历所有值，使用values()方法\nfor value in human_2.values():\n    print(value)\n\n#使用特定顺序遍历列表\n#比如可以使用sorted()方法，按照字母顺序遍历\nfor key in sorted(human_2.keys()):\n    print(key)\n\n\n#当字典中的值出现重复时候，可以使用集合剔除重复项\nhumangender = {\n    'krau':'me',\n    'ah':'he',\n    'xiaolv':'she',\n    'hanmiao':'he',\n}\n#可以看到这个字典中两个值都是he，可以使用set()方法创建一个集合，集合中的元素都是独一无二的\nfor gender in set(humangender.values()):\n    print(gender)\n\n#集合，也使用花括号创建，但存储的不是键值对\nlangs = {'c','py','go'}\nprint(langs)\n\n\n#嵌套\n#在列表中嵌套字典\nhumans = [human_1,human_2]\nprint(humans)\n#同样的，可以在字典中嵌套列表，在字典中嵌套字典......\n```\n\n## 用户输入与while循环\n\n```py\n#用户输入，使用inpu()函数\n\nname = input('请输入你的名字： ')\nprint(f'hello {name}')\n\n#判断一个数是奇数还是偶数\nnum = int(input('请输入一个数：　'))#int()用于将字符串转化为整数\nif num % 2 == 0: #%是求模运算，即返回两个数相除的余数\n    print(f'{num}是偶数')\nelse:\n    print(f'{num}是奇数')\n\n#while循环\n#示例，使用while循环让用户控制程序何时结束\nprint('我是复读机，输入quit以退出程序')\nmsg = ''\nwhile msg != 'quit':\n    msg = input('请输入：')\n    if msg != 'quit':\n        print(msg)\n    else:\n        pass\n\n#使用标志，清晰地控制程序运行\nprint('我是复读机二号')\nmsg = ''\nstatus0 = True #这里的status0是为了方便控制循环运行的，便被称为标志\nwhile status0:\n    msg = input('请输入： ')\n    if msg == 'quit':\n        status0 = False\n    else:\n        print(msg)\n\n#使用break退出循环\nprint('我是复读机三号')\nmsg = ''\nwhile True:\n    msg = input('请您输入： ')\n    if msg == 'quit':\n        break\n    else:\n        print(msg)\n\n#使用continue从头开始循环\n#输出所有偶数\nnum0 = 0\nwhile num0 < 10:\n    num0 += 1\n    if num0 % 2 != 0:\n        continue #与break不同的是，它会使循环返回第一行重新执行（从num0+=1）\n    print(num0)\n```\n\n## 函数基础\n\n```py\n#定义函数，使用def，最简单的一个例子如下\ndef hello():\n    #输出问候语\n    print('Hello!')\n\nhello()\n\n#向函数传递参数\ndef hello(username):\n    print(f'Hello,{username.title()}!')\n#在这里，username被称为形参，而下面传入的’krau’就称为实参\nhello('krau')\n\n\n#传递实参\n#位置实参，按实参的顺序传递给形参\ndef human_info(name,height,weight,gender):\n    #显示一个人的信息\n    print(f'''\nMy name is {name.title()}\nMy height is {height},and weight is {weight}\nIm a {gender}''')\n\nhuman_info('krau','178','65','male')\n#可以看到实参按照顺序依次传递给了形参\n\n#关键字实参，按照名称传递实参\nhuman_info(height='178',name='krau',gender='male',weight='65')\n\n\n#给参数确定默认值\ndef pet_info(pet_name,pet_animal='cat'):\n    #显示宠物信息\n    print(f'{pet_name.title()} is my pet , it is a {pet_animal}')\n\n#若不给出pet_animal，则会使用默认值cat\npet_info('ah')\n#也可以给默认值为空字符串，即''，这样做的话，这个参数将变成可选的\n\n\n#返回值，函数处理数据并返回的值\n#让函数返回值，使用return\ndef name_format(first_name,last_name):\n    #返回格式化好的姓名\n    full_name = f'{first_name} {last_name}'\n    return full_name.title()\n\nprint(name_format('acher','krau'))\n#这里只是一个示例，所以未免有些脱裤子放屁\n\n#函数可以返回任意类型的值，比如返回字典\ndef build_human(name,age):\n    person = {'name':name,'age':age}\n    return person\nme = build_human('krau',18)\nprint(me)\n\n\n#传递列表\ndef yuzu_hello(names):\n    for name in names:\n        print(f'Hello,{name.title()}!')\n\nmembers = ['krau','ah','hanmiao']\nyuzu_hello(members)\n\n#当需要处理一个列表，但不想让函数对列表产生影响时，可以传入列表的副本\nyuzu_hello(members[:])\n\n\n#传递任意数量的实参，不需首先指定多少形参\ndef do_math1(*derivatives):\n    #什么都导不出来\n    for derivative in derivatives:\n        print(f'{derivative} 导不出来')\n\ndo_math1('lnx','2x','ex')\n#可以看到，*derivatives创建了一个名为derivatives的元组，传入的实参都存入其中\n\n'''\n如果要让函数接受不同类型的实参，必须在函数定义中将接纳任意 数量实参的形参放在最后。\nPython先匹配位置实参和关键字实参， 再将余下的实参都收集到最后一个形参中。\n'''\ndef do_math2(diffculity,*integrals):\n    #什么都积不回去\n    for integral in integrals:\n        print(f'{integral}积不回去，因为它的难度是{diffculity}')\n\n#Python先匹配位置实参和关键字实参， 再将余下的实参都收集到最后一个形参中。\ndo_math2('easy','fx','gx','hx')\n\n#使用任意数量的关键字实参\n#有时候，需要接受任意数量的实参，但预先不知道传递给函数的会是什么样的信息。\n#可以使用字典中的键值对解决这一问题\ndef build_profile(first,last,**user_info):\n    '''创建一个包含用户所有信息的字典'''\n    user_info['first_name'] = first\n    user_info['last_name'] = last\n    return user_info\n\nkrau_info = build_profile('acher','krau',age=18,gender='male')\nprint(krau_info)\n#可以看到**user_info使python创建了一个名为user_info的字典，age和gender都存入了其中\n\n'''\n注意 你经常会看到形参名**kwargs \n它常常用于收集任意数量的关键字实参。\n'''\n```\n\n## 模块\n\n将函数存储在独立文件中，称其为模块。\n要创建一个模块，首先创建.py文件，在.py中仅编写函数，这便是一个模块。\n然后在同级目录下的其他代码中，便可以使用import导入这个模块。\n例如，我们创建一个greet.py文件，在文件中编写以下内容。\n\n```py\ndef hello(name):\n    print(f'Hello {name}!')\n\ndef nohello(name):\n    print(f'Not good {name}')\n```\n\n然后，我们在同级目录下编写另一个.py文件\n\n```py\nimport greet\ngreet.hello('krau')\n```\n\nPython读取这个文件时，代码行import greet让Python打开文件 greet.py，并将其中的所有函数都复制到这个程序中。\n你看不到复制的代码，因为在这个程序即将运行时，Python在幕后复制了这些代码。\n你只需知道，在现在这个文件中，可使用greet.py中定义的所有函数。\n使用模块中的函数时，要指定模块名greet和函数名hello，并使用点分割\n即 模块名.函数名()\n\n上面的方法是导入了模块中的所有函数，如果不需要全部导入，可以使用下面的语句\nfrom 模块名 import 函数名\n\n如果要导入函数的名称可能与程序中现有的名称冲突，或者函数的名称太长，可指定简短而独一无二的别名\n类似于外号。要给函数取这种特殊外号，需要在导入它时指定。\nimport 模块名 as 模块外号\nfrom 模块名 import 函数名 as 函数外号\n\n## 函数编写指南（规范）\n\n编写函数需要牢记几个细节：\n\n1. 给函数指定**描述性名称**，只在其中使用小写字母和下划线。——模块命名也需要遵循此约定。\n\n2. 每个函数都应包含简要地阐述其功能的**注释**，该注释应紧跟在函数定义后面，并采用文档字符串格式。\n\n3. 给形参指定默认值时，等号两边**不要**有空格。——关键字实参也应遵循此约定。\n\n4. PEP8建议代码行的长度不要超过79字符，这样编辑器窗口适中就能看到整行代码。如果形参定义的长度超过了79个字符，可在函数定义中输入左括号后按回车键，并在下一行按两次Tab键，从而将形参列表和只缩进一层的函数体区分开。\n\n5. 如果程序或模块包含多个函数，可使用两个空行将相邻的函数分开，这样便于阅读和查看函数的开始和结束的地方。\n\n6. 所有的import语句都应放在文件**开头**，唯一例外情形是，在文件开头使用了注释来描述整个程序。\n"},{"title":"2020年终总结","tags":[],"categories":"日常","author":"Krau","excerpt":"\n一年年来去匆匆，往事皆是云烟过眼，不做总结似乎像是虚度了一年时间。但想要写下的东西又太多，总结就不知不觉写成了流水账。\n\n","link":"/posts/summary-2020","content":"\n一年年来去匆匆，往事皆是云烟过眼，不做总结似乎像是虚度了一年时间。但想要写下的东西又太多，总结就不知不觉写成了流水账。\n\n<!-- more -->\n\n去年这个时候，我在高一，也是像现在这样，半夜用手机写着一些不知所云的东西。但那时我住宿舍，现在上了高二，自己租房在校外。\n\n不由得又开始怀念高一第一学期的时光。初入高中大门，虽有种种不达预期想象的失望之处，但也算有着新鲜感。与新同学在一个班级里学习着新知识，倒也令我兴趣盎然。但是最让我庆幸的是，这个班里有很多同好（二次元圈），宿舍里还有几个和我一样的崩坏三玩家，这让一向社交困难的我很快融入了这个新的集体，还交到了几个很要好的朋友，直到各分到不同班的现在也在一起玩的快乐。而且，每个老师的教书风格也是各有特色，那时候，我是怀着愉悦的心情去学习的。虽然成绩不算顶尖，倒也算不错。白天认真学习，晚上宿舍里一起玩游戏，看动画，有时候又补作业。对我来说每天过得已经很是充实了。\n\n但好景不长，下册期末考试后，学校重新分了班级。我们几个被各自分开，连楼层都不一样。我去了重点班（美其名曰“筑梦班”）。\n\n进入这个班的时候，我还以为我能像以前那样，很快的融入集体，很快的结识朋友，一起学习，一起娱乐。但我实在太天真了。到现在在这个班级里已经一年，我与班级里的其他同学非但没有走到一起，而是隔阂越来越大。在他们之中，几乎没有我所谓的同好，有的只是长着同一张脸的“好学生”而已。直到现在，我和他们一大半没有说过一句话。每次上体育课时，只有我一个人到学校后山，去看风景，有时候还会因为妨碍到情侣们亲热而遭受厌恶的目光。\n\n而在宿舍，再也没有了以前的气氛。灯还没熄，就有人准备睡了，从进宿舍到第二天起床，说过的话屈指可数。于是，我在今年暑假之后申请了外宿，现在一个人住在学校附近租来的一间屋子里。\n\n再怎么怀念过去，也无法拾回那些已经散去的时光。关于追忆过去与阐述现在的处境，或许可以以后专门再写一篇。而现在的主题仍然是年度总结。\n\n---\n\n今年都干了什么呢？我不知道从何处写起。只记得刚放寒假，就开始了防疫，接着就是网课。\n\n网课的时光实在是惨不忍睹，每天都很忙，但是过的很无意义。既没有学好习，也没有玩的愉快。对于网课最深的记忆就是建了博客。\n\n网课结束后开学，本以为这次要一落千丈，但在班里的成绩却几乎没有变，~~可能是我没有退步空间了罢~~。后来每天加班加点的自己补习，也算赶了回来，成绩到现在有小幅提升。\n\n我对于网课后的那段学期的事情已经记忆模糊了，具体都在干啥似乎没有印象，只记得那时候我因为住宿舍，好像每天都早睡早起？\n\n后来就是暑假，今年的暑假过得确实不是一个滋味，正在做一个 [atri](https://zh.moegirl.org.cn/zh-hans/ATRI_-My_Dear_Moments-) 动态壁纸的动画，做了两天了，突然通知说开学，当时心情就跌入低谷，于是也就搁置下了工程。\n\n重点班比其他班提前开学了两周，说是叫\"特殊优待\"。结果呢？多了两周的时间，到现在讲课进度却和其他班一样。\n\n暑假似乎大部分时间都在推 galgame 了，之前写的暑假总结有详情。\n\n自从疫情长假过后，学校越来越不做人了，食宿条件都不怎么好，却让学生三周有时候四周全封闭在校，说是为了防范疫情。可全市的学校似乎也就我们在防范疫情了，真当为校领导点赞。\n\n暑假过后入坑了原神，猛肝了一段时间，有时候晚上放学还和同学去通宵，但到现在基本咸鱼了。那段时间上课总是犯困......\n\n---\n\n今年连动画都没看多少，新番都是看了每几集搁置了，网课时候折腾博客，暑假推gal，之后是玩原神。但寒假准备补番。\n\n今年夏天的新番都挺不错的，总之就是非常可爱、魔女之旅、re0等等我都很喜欢，冬天的新番似乎也要出不少神作和续作，寒假怕不是看不完。\n\n初音的魔法未来和未来有你我能都没赶上直播，但最近补完了，依然吹爆。\n\n今年似乎在自己感兴趣的各个方面都没有什么长进，给自己的学习计划一直没有执行，结果就是收藏了一堆教程视频吃灰。但暑假浅浅的学了些 mmd，也算能摸出来个自我感觉良好的东西了。但初中闲的没事学的好多东西都开始淡忘了，连 ps 都手生了起来。网课学的 kali linux 更是忘得只会开关机了，爬虫那时候也感觉学了不少，但发现其实只会简单地爬一些图片之类的而已。\n\n有许多曾经热爱的，到现在却有些淡然了...\n\n---\n\n2020像是恍然虚度，留下的印记无处寻找，在互联网的一角记录下自己的点点絮絮，却不知何日也会消逝。但2021已经到来，再追逐过去已经没有意义，面对未来是不得不做的选择。\n\n写下自己的新年目标吧:\n\n早睡早起\n\n技术长进\n\n学业有成\n\n随心追番\n\n多听术曲\n\n不咕博客\n\n积极向上\n...\n\n2021的暑假过后就进入高三了，也许到时候会像很多人一样断网自闭期吧...\n\n祝我和我的朋友们新年快乐\n"},{"title":"使用Python写一个Telegram bot吧|Telegram bot教程","tags":["Python","telegram","bot","代码"],"categories":"小技术","author":"Krau","excerpt":"\n::: info\n2024-01-14 更新:\n\n修复了一些错误, 删除了一些不必要的内容\n\n评论区有人建议建一个群组讨论: [@kmuachat](https://t.me/kmuachat)\n\n本文只是我最初写 bot 时的一点笔记, 更建议你直接看 [Python-Telegram-Bot](https://docs.python-telegram-bot.org) 的文档\n:::\n\n## 前言\n\n~~为了激发群友们水群的积极性，~~ 为了学习和应用 python 知识，我最近在开发一个 telegram 的 bot，所以写这篇文章以记录和分享\n\n在这篇文章中，将使用 [Python-Telegram-Bot](https://docs.python-telegram-bot.org) ，基于 Python 的异步特性与 Telegram 友好开放的 API，开发一个兼顾实用性和趣味的 bot ，并使用 Docker 在任何地方部署 bot\n\nDemo: [kmua-bot](https://github.com/krau/kmua-bot)\n\n本文不是从零开始的教程，阅读本文前，你需要具有一点点(真的很少一点)的 python 或其他语言编程的基础。\n\n","link":"/posts/tg-bot-dev-note-kmua","content":"\n::: info\n2024-01-14 更新:\n\n修复了一些错误, 删除了一些不必要的内容\n\n评论区有人建议建一个群组讨论: [@kmuachat](https://t.me/kmuachat)\n\n本文只是我最初写 bot 时的一点笔记, 更建议你直接看 [Python-Telegram-Bot](https://docs.python-telegram-bot.org) 的文档\n:::\n\n## 前言\n\n~~为了激发群友们水群的积极性，~~ 为了学习和应用 python 知识，我最近在开发一个 telegram 的 bot，所以写这篇文章以记录和分享\n\n在这篇文章中，将使用 [Python-Telegram-Bot](https://docs.python-telegram-bot.org) ，基于 Python 的异步特性与 Telegram 友好开放的 API，开发一个兼顾实用性和趣味的 bot ，并使用 Docker 在任何地方部署 bot\n\nDemo: [kmua-bot](https://github.com/krau/kmua-bot)\n\n本文不是从零开始的教程，阅读本文前，你需要具有一点点(真的很少一点)的 python 或其他语言编程的基础。\n\n<!-- more -->\n\n## 准备\n\n### 环境搭建\n\n使用你喜欢的工具创建虚拟环境，并安装 `python-telegram-bot` 库\n\n```shell\npip install python-telegram-bot\n```\n\n### bot 申请\n\n私聊 [@BotFather](https://t.me/BotFather)。发送 `/newbot`，根据提示一步步创建，记得妥善保存最后的 **API Token**。\n\n### 获取你的 id\n\n每个 tg 用户都有一串唯一标识，即为 **user_id**，可以私聊 [@kmua](https://t.me/kmuav2bot) 发送 `/id` 来获取它\n\n## 编程\n\n### 开始:响应/start\n\n在项目文件夹内，新建 `bot.py`，开始编写 bot 最基础的功能，让其响应 /start 命令\n\n首先，导入包\n\n```python\nfrom telegram import Update\nfrom telegram.ext import ApplicationBuilder, ContextTypes, CommandHandler\n```\n\nUpdate 类是从 Telegram 服务器获取到的各种\"更新\", 包括而不限于用户发送的消息, 群组的信息变化等.\n\n然后，写一个异步函数 start()，当收到 /start 命令时，要调用它。\n\n```python\nasync def start(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    '''响应start命令'''\n    text = '你好~我是一个bot'\n    await context.bot.send_message(chat_id=update.effective_chat.id,text=text)\n```\n\n这个函数接受两个参数 `update` 和 `context`，形参冒号后是类型注解。\n\n`context.bot.send_message()` 方法即为让 bot 发送消息，它能接受的参数其实很多，但是往往只需要 `chat_id` ，和 `text` 就够了，它们分别表示 要发送消息给的用户或群组 id ，要发送的文本。\n\n而 `update.effective_chat.id` 即为当前有效对话的 id ，bot 收到的是哪里的消息 ，它就指向哪里的 id。\n\n现在，添加一个处理器(handler)\n\n```python\nstart_handler = CommandHandler('start', start)\n```\n\n`CommandHandler` 类可以实现当收到某个命令时，调用某个函数（命令和函数名可以不一样），我们将其实例化为了 `start_handler` ，并且将命令名字 'start' 和对应要回调的函数名 `start` 传递给它\n\n然后，启动bot\n\n```python\n# 构建 bot\nTOKEN='你 bot 的 api token'\napplication = ApplicationBuilder().token(TOKEN).build()\n# 注册 handler\napplication.add_handler(start_handler)\n# run!\napplication.run_polling()\n```\n\n最后，就可以使用 `python bot.py` 启动你的 bot ，对 bot 发送 /start ，它应该就会回复你 ”你好~我是一个bot”。\n使用 Ctrl + C 结束程序运行。\n\n上述完整代码:\n\n```python\nfrom telegram import Update\nfrom telegram.ext import ApplicationBuilder, ContextTypes, CommandHandler\n\nasync def start(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    '''响应start命令'''\n    text = '你好~我是一个bot'\n    await context.bot.send_message(chat_id=update.effective_chat.id,text=text)\n\nstart_handler = CommandHandler('start', start)\n\n# 构建 bot\nTOEKN='你 bot 的 api token'\napplication = ApplicationBuilder().token(TOKEN).build()\n# 注册 handler\napplication.add_handler(start_handler)\n# run!\napplication.run_polling()\n```\n\n到这里，其实你已经了解到了最基本的 telegram bot 编写规则，即：\n\n1. 编写回调函数。上面的例子中即为 `start` 这个函数。\n2. 决定调用回调函数的规则。上述例子中，即为收到 `/start` 命令时，调用 `start` 函数\n3. 实例化 `handler` , 注册给 `application`。上述例子中，即为 `application.add_handler(start_handler)`\n\n::: tip\n如果你的环境无法直接访问 Telegram 服务器，可以设置代理\n\n全局代理, 代理整个程序.\n\n```python\nos.environ['http_proxy'] = '代理地址'\nos.environ['https_proxy'] = '代理地址'\n```\n\n若想仅为 telegram bot api 设置代理,则需要改动一下构建 bot 部分的代码:\n\nhttp(s)代理:\n\n```python\nproxy_url = 'http://USERNAME:PASSWORD@PROXY_HOST:PROXY_PORT'  # can also be a https proxy\napplication = ApplicationBuilder().token(\"TOKEN\").proxy_url(proxy_url).get_updates_proxy_url(proxy_url).build()\n```\n\nsocks5代理,需要安装 `python-telegram-bot[socks]`,然后:\n\n```python\nproxy_url = \"socks5://user:pass@host:port\"\napplication = ApplicationBuilder().token(\"TOKEN\").proxy_url(proxy_url).get_updates_proxy_url(proxy_url).build()\n```\n\n:::\n\n接下来，写一些更有趣的功能，使用更复杂一些的规则来调用这些功能。\n\n### 授予群成员头衔\n\n让群成员可以通过 bot 自助获得一个头衔吧，比如，群友可以在群里使用 `/p@botname 好人` 来给自己加上 “好人” 的头衔。\n\n当然，前提是 bot 自己要是管理员，并且具有相应的权限。\n\n要实现这个功能，可以这样写:\n\n```python\nasync def set_right(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    '''设置成员权限和头衔'''\n    chat_id = update.effective_chat.id\n    user_id = update.effective_user.id\n    bot_username_len = len(update._bot.name)\n    custom_title = update.effective_message.text[3+bot_username_len:]\n    if not custom_title:\n        custom_title = update.effective_user.username\n    try:\n        await context.bot.promote_chat_member(chat_id=chat_id, user_id=user_id, can_manage_chat=True)\n        await context.bot.set_chat_administrator_custom_title(chat_id=chat_id, user_id=user_id, custom_title=custom_title)\n        text = f'好,你现在是{custom_title}啦'\n        await context.bot.send_message(chat_id=chat_id, reply_to_message_id=update.effective_message.id, text=text)\n    except:\n        await context.bot.send_message(chat_id=chat_id, text='不行!!')\n```\n\n然后，添加这个功能的handler:\n\n```python\nset_right_handler = CommandHandler('p', set_right)\napplication.add_handler(set_right_handler)\n```\n\n注意handler的添加应该在 `application.run_polling()` 之前，也就是说 `application.run_polling()` 才是真正开始运行 bot\n\n简单解释一下 `set_right` 这个函数:\n\n首先，设置了调用这个函数时的 `chat_id` 和 `user_id` 为当前聊天和当前用户\n\n然后用 `len(update._bot.name)` 获取 bot 自己用户名的长度，用于下面的切片选取用户想要的头衔\n\n而 `custom_title = update.effective_message.text[3+bot_username_len:]` 即获取用户想要的头衔，存储在 `custom_title` 中，下面的 if not 的作用是，如果用户没有发送他想要的头衔，那么默认头衔为他的用户名\n\n由于只有管理员才有头衔，所以我们使用 promote_chat_member() 方法设置成员权限，将其的 can_manage_chat 权限设置为 True 。注意，即使这样设置了，用户实则是有名无权的状态，只有一个管理员的名头，实际上没有任何权限。\n> 要想赋予权限，你可以向 promote_chat_member() 方法中继续添加参数，如 can_pin_messages=True 可置顶消息\n\n然后就可以使用 `set_chat_administrator_custom_title()` 方法设置成员头衔了，如果成功了，会继续执行接下来的语句，将结果反馈给用户。\n\n### 响应未知命令\n\n如果 bot 只能回应设置好的命令就太无趣了，所以再编写一个当收到未知命令时的执行功能\n比如，想要让 bot 回应未知命令说 “我不会这个哦~”，可以这样写\n\n```python\nasync def unknown(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    await context.bot.send_message(chat_id=update.effective_chat.id, text=\"我不会这个哦~\")\n```\n\n然后，添加它的 `handler`。这时候可能就出现问题：\n前面的两个功能都是回应一个特定的命令，在这里，我们希望它回应除已经设定的命令外的其他所有命令，该怎么做？\n\n这就需要用到 `filters` ，即过滤需要处理器处理的更新. 并且要**设置功能的优先级**\n你需要先导入它\n\n```python\nfrom telegram.ext import filters\n```\n\n然后可以这样写:\n\n```python\nunknown_handler = MessageHandler(filters.COMMAND, unknown)\n```\n\n`filters.COMMAND` 即为过滤出命令。而设置优先级其实很简单，在不对处理器分组的情况下, **添加 `handler` 的顺序越靠后，对应功能的优先级越低**\n\n也就是说，我们需要在其他命令类 `handler` 之后，添加 `unknown_handler`\n\n```python\napplication.add_handler(start_handler)\napplication.add_handler(set_right_handler)\napplication.add_handler(unkonw_handler)\n\napplication.run_polling()\n```\n\n### 简单的关键词回复\n\nbot 最常见的功能之一就是根据关键词回复特定内容，比如，当对 bot 说早安之类的话时，让 bot 对此做出回应。下面来实现这这一功能\n\n由于命令和普通消息是两种不同的消息类，处理它们的方法是不一样的，针对非命令消息，要使用 `MessageHandler`:\n\n```python\nfrom telegram.ext import MessageHandler\n```\n\n首先还是要编写这个功能执行的函数。\n\n```python\nimport random\n\nasync def ohayo(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    texts = ['早上好呀','我的小鱼你醒了，还记得清晨吗','哦哈哟~']\n    await context.bot.send_message(chat_id=update.effective_chat.id, text=random.choice(text))\n```\n\n由于只回复一个固定的消息过于单调，所以我们使用 `random` 库来从一个列表中随机选择一个回复\n\n实际上，这个函数仍然只是简单的发送消息，而何时调用这个函数，并不是这个函数本身要做的事，而是由接下来我们要编写的 `MessageHandler` 中的 `filters` 决定的:\n\n```python\nfilter_ohayo = filters.Regex('早安|早上好|哦哈哟|ohayo')\nohayo_handler = MessageHandler(filter_ohayo, ohayo)\n```\n\n`filters.Regex()` 即为使用正则表达式过滤，我们使用 `'早安|早上好|哦哈哟|ohayo'` 这个表达式，很容易理解何时会调用 `ohayo` 这个函数\n\n记得添加它的 `handler`\n\n```python\napplication.add_handler(ohayo_handler)\n```\n\n---\n\n上面完整代码:\n\n```python\nimport random\n\nfrom telegram import Update\nfrom telegram.ext import ApplicationBuilder, ContextTypes, CommandHandler, filters, MessageHandler\n\nasync def start(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    '''响应start命令'''\n    text = '你好~我是一个bot'\n    await context.bot.send_message(chat_id=update.effective_chat.id,text=text)\n\n\nasync def set_right(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    '''设置成员权限和头衔'''\n    chat_id = update.effective_chat.id\n    user_id = update.effective_user.id\n    bot_username_len = len(update._bot.name)\n    custom_title = update.effective_message.text[3+bot_username_len:]\n    if not custom_title:\n        custom_title = update.effective_user.username\n    try:\n        await context.bot.promote_chat_member(chat_id=chat_id, user_id=user_id, can_manage_chat=True)\n        await context.bot.set_chat_administrator_custom_title(chat_id=chat_id, user_id=user_id, custom_title=custom_title)\n        text = f'好,你现在是{custom_title}啦'\n        await context.bot.send_message(chat_id=chat_id, reply_to_message_id=update.effective_message.id, text=text)\n    except:\n        await context.bot.send_message(chat_id=chat_id, text='不行!!')\n\n\nasync def unknown(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    await context.bot.send_message(chat_id=update.effective_chat.id, text=\"我不会这个哦~\")\n\n\nasync def ohayo(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    texts = ['早上好呀','我的小鱼你醒了，还记得清晨吗','哦哈哟~']\n    await context.bot.send_message(chat_id=update.effective_chat.id, text=random.choice(text))\n\n\nstart_handler = CommandHandler('start', start)\nset_right_handler = CommandHandler('p', set_right)\nunknown_handler = MessageHandler(filters.COMMAND, unknown)\nfilter_ohayo = filters.Regex('早安|早上好|哦哈哟|ohayo')\nohayo_handler = MessageHandler(filter_ohayo, ohayo)\n\n# 构建 bot\nTOEKN='你 bot 的 api token'\napplication = ApplicationBuilder().token(TOKEN).build()\n# 注册 handler\napplication.add_handler(start_handler)\napplication.add_handler(set_right_handler)\napplication.add_handler(unkonw_handler)\napplication.add_handler(ohayo_handler)\n# run!\napplication.run_polling()\n```\n\n## 部署\n\npython 程序的环境管理很烦人,用docker来跑再合适不过.\n\n### Docker 本地构建\n\n如果要在本地构建 docker 镜像,参考下面的 `Dockerfile` 文件\n\n```Dockerfile\nFROM python:3.9\nCOPY . /app\nWORKDIR /app\nRUN pip install -r requirements.txt\nENTRYPOINT [ \"python\",\"/app/bot.py\" ]\n```\n\n将 Dockerfile 文件放到合适的目录(项目根目录即可),然后执行\n\n`docker build -t bot .`\n\n注意后面有一个 .\n\n然后使用 `docker run -d bot` 启动容器,运行 bot\n\n### 使用 GitHub action 自动构建\n\ngithub action 可以构建 docker 镜像并发布到 ghcr,方便在其他地方部署 docker 容器.你依然需要在项目中写好 `Dockerfile`\n\n在项目中新建 `.github/workflows/build-docker.yml`,参考以下配置\n\n```yml\nname: Build and publish docker container\n\non:\n push:\n     branches:\n     - main\n  workflow_dispatch:\n    \n    \n\njobs:\n  publish:\n    name: Publish container image\n    runs-on: ubuntu-20.04\n    env:\n      TZ: Asia/Shanghai\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3\n\n      - name: OCI meta\n        id: meta\n        uses: docker/metadata-action@v4.1.1\n        with:\n          images: ghcr.io/${{ github.repository }}\n          tags: |\n            type=edge,branch=main\n            type=ref,event=branch\n            type=semver,pattern={{version}}\n            type=semver,pattern={{major}}.{{minor}}\n            type=semver,pattern={{major}}\n            type=sha\n      - name: Set up Docker Buildx\n        uses: docker/setup-buildx-action@v2\n        \n      - name: Set up QEMU\n        uses: docker/setup-qemu-action@v2\n\n      - name: Login to GHCR\n        uses: docker/login-action@v2\n        with:\n          registry: ghcr.io\n          username: ${{ github.repository_owner }}\n          password: ${{ secrets.GITHUB_TOKEN }}\n\n      - name: Build and push\n        uses: docker/build-push-action@v3\n        with:\n          context: .\n          push: true\n          tags: ${{ steps.meta.outputs.tags }}\n          labels: ${{ steps.meta.outputs.labels }}\n          platforms: linux/amd64,linux/arm64\n          cache-from: type=gha\n          cache-to: type=gha,mode=max\n```\n\n然后可以使用 `docker pull` 的方法运行,或者使用 docker compose:\n\n新建 `docker-compose.yml`,参考以下内容\n\n```yml\nversion: \"3\"\nservices:\n  kmua:\n    image: ghcr.io/krau/kmua-bot:main\n    container_name: kmua-main\n    init: true\n    volumes:\n      - ./data:/kmua/data\n      - ./logs:/kmua/logs\n      - ./config.yml:/kmua/config.yml\n    environment:\n      - TZ=Asia/Shanghai\n```\n\n注意根据自己需要更改\n\n然后就可以使用 `docker compose up -d` 启动容器\n"},{"title":"ChatGPT简单使用体验|你的下一个Google，何必是搜索引擎","tags":["AI"],"categories":"小技术","author":"Krau","excerpt":"\n最近 openai 的 [ChatGPT](https://chat.openai.com/chat) 有点小火，看了官方和民间的一些截图之后，感觉这东西确实有点意思，所以就想办法注册了个号来体验体验。\n\n","link":"/posts/ChatGPT-simple-exp/index","content":"\n最近 openai 的 [ChatGPT](https://chat.openai.com/chat) 有点小火，看了官方和民间的一些截图之后，感觉这东西确实有点意思，所以就想办法注册了个号来体验体验。\n\n<!-- more -->\n\n结论：ChatGPT像一面镜子，只要问题详尽，描述清楚，那么它就能给你一个基本准确的答案，这比使用谷歌搜索要节省很多时间。但是有些问题它给出的答案还有待优化。\n\n下面是我提问的一些问题。\n\nLinux使用相关\n\n切换个时区，完全正确，简简单单\n\n![](./ChatGPT-simple-exp_2022-12-05-20-57-25.webp)\n\n装个docker\n\n![](./ChatGPT-simple-exp_2022-12-05-20-59-13.webp)\n\nnginx的使用，示例配置文件写的格式也对\n\n![](./ChatGPT-simple-exp_2022-12-05-21-01-20.webp)\n\n![](./ChatGPT-simple-exp_2022-12-05-21-03-33.webp)\n\n这个我感觉最逆天，它能针对一个具体的项目给出使用文档\n\n![](./ChatGPT-simple-exp_2022-12-05-21-05-57.webp)\n\nPython编程相关\n\n字符串匹配问题，~~我以为它会给我写一个ac算法~~，没想到直接用的for in，只能说又不是不能用吧\n\n![](./ChatGPT-simple-exp_2022-12-05-21-15-11.webp)\n\n简单的json使用问题\n\n![](./ChatGPT-simple-exp_2022-12-05-21-16-28.webp)\n\npython的日期和时间\n\n![](./ChatGPT-simple-exp_2022-12-05-21-17-41.webp)\n\n来排个经典的解码问题错误吧\n\n![](./ChatGPT-simple-exp_2022-12-05-21-19-37.webp)\n\n还要第三方包的导入问题\n\n![](./ChatGPT-simple-exp_2022-12-05-21-24-13.webp)\n\n这个就有点厉害了，给出的答案基本是正确的，可以直接使用。如果使用Google解决这些问题，那么要花费一定的时间去翻看不同网站的回答，还不一定准确。\n\n其他\n\n来问个我以前写过的文章（\n\n![](./ChatGPT-simple-exp_2022-12-05-21-30-19.webp)\n\n有点厉害，但是不是我想要的结果，我是想把图片直接保存在本地的，所以我又追问它：\n\n![](./ChatGPT-simple-exp_2022-12-05-21-33-17.webp)\n\n结果给了我一个最麻烦的办法，所以我继续追问：\n\n![](./ChatGPT-simple-exp_2022-12-05-21-35-23.webp)\n\n似乎我想要的答案要出来了，但是它突然卡壳了，不知道怎么回事😅\n\n总结\n\n就这样，总体感觉是，在某些场景它比Google是要好用很多的，但是要说取代谷歌，我觉得还有点距离。在简单而足够具体的问题上，使用chatGPT要比使用Google效率高的多，但是比较抽象的问题就不是了。\n"},{"title":"使用ACME脚本申请并配置SSL证书","tags":["SSL"],"categories":"小技术","author":"Krau","excerpt":"\n## 前言|为什么选择ACME方法\n\n要想通过TLS/https协议访问自己域名下的服务, 就必须申请SSL证书。类似宝塔这种面板提供了简单快捷的方法一键申请, 但终究不是良好的解决方案。一来宝塔过于臃肿, 二来其需要手机实名验证。使用各大云服务商提供的【免费证书】则还需要登录网页、申请、导入证书, 未免操作繁琐。更何况这些云服务商提供的ssl证书只能给你很少的自由选择性。\n\n而ACME则很好地解决了这些问题。\n","link":"/posts/acmessl/index","content":"\n## 前言|为什么选择ACME方法\n\n要想通过TLS/https协议访问自己域名下的服务, 就必须申请SSL证书。类似宝塔这种面板提供了简单快捷的方法一键申请, 但终究不是良好的解决方案。一来宝塔过于臃肿, 二来其需要手机实名验证。使用各大云服务商提供的【免费证书】则还需要登录网页、申请、导入证书, 未免操作繁琐。更何况这些云服务商提供的ssl证书只能给你很少的自由选择性。\n\n而ACME则很好地解决了这些问题。\n<!-- more -->\n系统环境: Debian\n\n## 准备工作与脚本安装\n\n在开始之前, 首先将域名解析到服务器的ip上。\n\n### 安装\n\n首先安装socat, 它是acme所需的组件\n\n```shell\napt update\napt install socat -y\n```\n\n然后安装acme脚本\n\n```shell\ncurl https://get.acme.sh | sh\n```\n\n脚本安装在用户目录下的`.acme.sh`（隐藏）文件夹内, 使用 `. .bashrc` 让acme.sh命令生效\n\n接下来使用脚本申请证书\n\n## 证书申请\n\n首先注册CA账户, 将下列命令中的邮箱改为自己的邮箱地址\n\n```shell\nacme.sh --register-account -m xxxx@xxxx.com\n```\n\n注册成功的输出结果如下\n\n![1](./acmessl1.webp)_注册成功\n\n然后申请证书, 接下来的方法有多种, 根据自己情况选择可用的一种即可\n\n### 监听80端口申请证书\n\n如果服务器的80端口空闲, 且能够访问, 可以让acme临时监听80端口, 完成验证。执行以下命令即可。将domain.com改为自己的域名\n\n```shell\nacme.sh --issue -d domain.com --standalone\n```\n\n### 通过Nginx服务申请\n\n如果服务器上已经安装了nginx, 且网页能够正常打开, 执行以下命令即可通过nginx验证并申请证书。\n\n```shell\nacme.sh --issue -d mydomain.com --nginx\n```\n\n---\n如果成功申请了证书, 将会看到的输出结果是一长串自己的证书和证书文件存放路径。\n\n## 安装证书到指定路径\n\n生成的证书文件默认存放在与acme.sh脚本相同文件夹内, 大多数情况下不应直接使用该路径下的证书文件, 而使用以下命令安装证书到指定路径。\n\n```shell\nacme.sh --install-cert -d domain.com --key-file <path>privkey.pem --fullchain-file <path>fullchain.pem\n```\n\n其中`--key-file <path>privkey.pem`指定的为私钥文件, `--fullchain-file <path>fullchain.pem`为证书文件。\n\ndone\n\n## 善后工作\n\n在安装acme.sh脚本时, 它自动为创建 cronjob, 每天 0:00 点自动检测所有的证书, 如果快过期了, 需要更新, 则会自动更新证书。\n但由于acme 协议和 letsencrypt CA 都在频繁的更新, 因此 acme.sh 也应当经常更新以保持同步。参考以下命令\n\n```shell\nacme.sh --upgrade --auto-upgrade  #开启acme的自动更新\nacme.sh --upgrade --auto-upgrade 0  #关闭自动更新\n```\n"},{"title":"JWT 认证及其在 FastAPI 中的使用","tags":["Python","代码","FastAPi"],"categories":["小技术"],"author":"Krau","excerpt":"\n## 什么是 JWT\n\nJWT: JSON Web Tokens,它是一种将 JSON 对象编码为没有空格，且难以理解的长字符串的标准。在具体上,它就是一段字符串,下面就是 FastAPI 文档中给出的例子\n\n```txt\neyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c\n```\n\n抽象地把它看成是这样的\n\n```txt\naaaaaaaaaaaa.bbbbbbbbbbbb.cccccccccccc\n```\n\n","link":"/posts/fastapi-jwt/index","content":"\n## 什么是 JWT\n\nJWT: JSON Web Tokens,它是一种将 JSON 对象编码为没有空格，且难以理解的长字符串的标准。在具体上,它就是一段字符串,下面就是 FastAPI 文档中给出的例子\n\n```txt\neyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c\n```\n\n抽象地把它看成是这样的\n\n```txt\naaaaaaaaaaaa.bbbbbbbbbbbb.cccccccccccc\n```\n\n<!-- more -->\n\njwt 由三个部分组成,这三个部分之间用点`.`拼接起来,这三个部分分别是\n\n- Header --- 头,定义了 jwt 使用的算法等信息\n- Payload --- 载荷,存储有效信息的地方\n- Signature --- 签名,用于校验 jwt 令牌\n\n这三个部分中,只有第三个部分是无法还原的,前两个部分只是简单的进行了 base64 编码,把上面例子中的前两部分解码之后,看起来是这样的:\n\nHeader:\n\n```json\n{\n    \"alg\":\"HS256\",\n    \"typ\":\"JWT\"\n}\n\n```\n\nalg 即为算法,这里使用了 HS256 算法\n\ntyp 即为类型,指明这里是一个 JWT 字符串\n\nPayload\n\n```json\n{\n    \"sub\":\"1234567890\",\n    \"name\":\"John Doe\",\n    \"iat\":1516239022\n}\n```\n\n可以看到 Payload 中存储了主要的信息\n\n::: tip 提示\n根据 JWT 规范, Payload 中的 `sub` 是一个预定义的声明（Claim），表示JWT的主题（**Subject**）。它指定了JWT所代表的实体或主题，通常是用户或客户端应用程序。\n`sub`声明的值是字符串类型，通常是**唯一**标识用户或客户端应用程序的ID。\n:::\n\n而 Signature 则是通过加盐加密得到的,加密由服务端实现\n\n::: tip 关于具体如何实现\n\n参考下图\n\n![图 1](./fastapi-jwt_03-22-11-28-26.webp)\n\n即,把 header 和 payload 部分进行 base64编码,用点拼接起来,得到**结果**,把这个结果用我们设置的密钥和算法进行加盐加密,就得到了 Signature\n\n:::\n\n### JWT 有什么用\n\n其实它与 token ,cookie 的作用类似,就是用来免密码认证客户端\n\n比如你去上学,学校是服务端,你是客户端.你完成学籍注册之后,学校发给你一个学生证,学生证就是你的 jwt 令牌.\n\n你使用学校的很多服务,都要出示学生证.\n\n而在实际业务中,jwt 令牌是有过期时间的,过期之后,需要客户端再次登录,获取新的 jwt\n\n## FastAPI 实现 Bearer JWT 令牌验证\n\n需要安装以下几个包\n\npython-jose，在 Python 中生成和校验 JWT 令牌\n\n```bash\npip install python-jose[cryptography]\n```\n\nPasslib ,处理密码哈希\n\n```bash\npip install passlib[bcrypt]\n```\n\n::: warning\n\n密码哈希和 jwt 的加密不是同一个问题.\n\n哈希是指把特定内容（本例中为密码）转换为乱码形式的字节序列（其实就是字符串）。\n\n每次传入完全相同的内容时（比如，完全相同的密码），返回的都是完全相同的乱码。\n\n但这个乱码无法转换回传入的密码。\n\n把密码进行哈希并存储是必要的安全措施\n\n:::\n\n先不考虑用户注册的问题,假设我们已经有了一个在数据库中的用户,那么这里的逻辑是这样的:\n\n1. 该用户通过用户名和密码登录\n2. 服务端对其进行校验和认证\n3. 完成认证后,用户拿到 jwt 令牌(token)\n4. 用户使用 jwt 令牌(token)访问其他服务\n\n所以,我们需要:\n\n1. 一个存储了用户信息的数据库,其中密码存储的是哈希值\n2. 用户和 jwt 令牌(token)的模型\n3. 用于从数据库中获得用户信息,并验证的函数. 包括获取用户,哈希传入的密码,验证用户等\n4. 用于创建 jwt 令牌的函数\n5. 给用户登录并获取 jwt 令牌(token)的接口\n6. 验证用户的 jwt 是否正确和有效\n\n### 数据库与模型\n\n呃,为了简便和偷懒,就用 FastAPI 文档中的假数据库吧\n\n```python\nfake_users_db = {\n    \"johndoe\": {\n        \"username\": \"johndoe\",\n        \"full_name\": \"John Doe\",\n        \"email\": \"johndoe@example.com\",\n        \"hashed_password\": \"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW\",\n        \"disabled\": False,\n    }\n}\n```\n\n定义之后要用到的模型\n\n```python\nfrom pydantic import BaseModel\nfrom typing import Union\n\nclass Token(BaseModel):\n    access_token: str\n    token_type: str\n\n\nclass TokenData(BaseModel):\n    username: Union[str, None] = None\n\n\nclass User(BaseModel):\n    username: str\n    email: Union[str, None] = None\n    full_name: Union[str, None] = None\n    disabled: Union[bool, None] = None\n\n\nclass UserInDB(User):\n    hashed_password: str\n\n```\n\n`Token` 模型用于在登录接口中指定 `response_model`\n\n`TokenData` 用于从 token 中获取数据\n\n`User` 即用户模型,供外部使用\n\n`UserInDB` 是用户在数据库中的模型,它继承自 `User` 添加了 `hashed_password` 属性\n\n这些模型在之后会用到\n\n### 对用户名和密码的校验与认证\n\n这部分比较简单,就是把用户输入的密码哈希之后和数据库中的对比就好了\n\n```python\nfrom passlib.context import CryptContext\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n\ndef verify_password(plain_password, hashed_password):\n    \"\"\"\n    校验密码是否正确\n    将传入的明文密码与数据库中的哈希值进行比对\n    \"\"\"\n    return pwd_context.verify(plain_password, hashed_password)\n\n\ndef get_password_hash(password):\n    \"\"\"获取传入的密码的哈希值\"\"\"\n    return pwd_context.hash(password)\n\n\ndef get_user(db, username: str):\n    \"\"\"根据用户名从指定数据库中获取用户\"\"\"\n    if username in db:\n        user_dict = db[username]\n        return UserInDB(**user_dict)\n\n\ndef authenticate_user(fake_db, username: str, password: str):\n    \"\"\"身份验证, 返回用户对象或者 False\"\"\"\n    user = get_user(fake_db, username)\n    if not user:\n        return False\n    if not verify_password(password, user.hashed_password):\n        return False\n    return user\n```\n\n### 创建 jwt token\n\n完成认证之后,就可以给用户创建 token 了\n\n首先,定义 jwt 的加密密钥,加密算法和过期时间\n\n```python\nSECRET_KEY = \"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7\"\nALGORITHM = \"HS256\"\nACCESS_TOKEN_EXPIRE_MINUTES = 30\n```\n\n::: warning 注意\n\n在实际项目中,jwt 的密钥不应该直接写在代码中,而是应该从环境变量中读取\n\n例如,从环境变量中获取 SECRET_KEY\n\n```python\nimport os\nSECRET_KEY = os.environ.get(\"SECRET_KEY\")\n```\n\n:::\n\n然后写创建 token 的函数\n\n```python\nfrom datetime import datetime, timedelta\nfrom jose import JWTError, jwt\n\ndef create_access_token(data: dict, expires_delta=None):\n    \"\"\"创建 jwt token\"\"\"\n    to_encode = data.copy()\n    if expires_delta:\n        expire = datetime.utcnow() + expires_delta\n    else:\n        expire = datetime.utcnow() + timedelta(minutes=15)\n    to_encode.update({\"exp\": expire})\n    # 注意这里就用到了上面定义的 SECRET_KEY 和 ALGORITHM\n    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)\n    return encoded_jwt\n```\n\n上面这个函数把传入的用于获取 jwt 的数据进行拷贝,并添加过期时间,然后 encode 得到 jwt token 并返回\n\n至此,我们完成了对用户的校验和认证,以及创建 jwt token 的功能,下面我们要在接口中使用它们\n\n### 提供登录并创建token的接口\n\n```python\nfrom fastapi import Depends, FastAPI, HTTPException, status\nfrom fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm\n\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"token\")\n@app.post(\"/token\", response_model=Token)\nasync def login_for_access_token(form_data: OAuth2PasswordRequestForm = Depends()):\n    \"\"\"登录并获取 token\"\"\"\n    # 通过用户名和密码获取用户, 如果用户不存在或者密码错误, 则抛出异常\n    user = authenticate_user(fake_users_db, form_data.username, form_data.password)\n\n    if not user:\n        raise HTTPException(\n            # 这部分是规范, 401 表示未授权\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Incorrect username or password\",\n            headers={\"WWW-Authenticate\": \"Bearer\"},\n        )\n\n    # 上面已经相当于进行了用户身份验证, 所以这里可以直接创建 token\n    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)\n    access_token = create_access_token(\n        data={\"sub\": user.username}, expires_delta=access_token_expires\n    )\n    # 这里如何返回也是规范, 我们已在上面已经定义好了 response_model=Token\n    return {\"access_token\": access_token, \"token_type\": \"bearer\"}\n```\n\n`oauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"token\")` 声明了用户应该从哪个路由获取 token (相对路径),但是并未实现具体的功能\n\n而我们自己写的 `login_for_access_token` 则是实现.\n\n现在用户成功登录后,就拿到了 jwt token ,访问其他服务时,浏览器会携带 jwt token 一起发送请求\n\n我们只需要在其他接口中,对用户传来的 jwt token 进行验证即可\n\n### 在其他接口中验证jwt token\n\n比如我们有一个获取用户信息的接口 `read_users_me` ,那么,我们需要:\n\n1. 获取用户传来的 token\n2. 验证 token 是否正确和有效\n3. 通过 token 获取当前的用户信息\n\n首先,解密 jwt token ,获取当前用户:\n\n```python\nasync def get_current_user(token: str = Depends(oauth2_scheme)):\n    \"\"\"依赖函数, 用于获取当前用户\"\"\"\n    # 定义一个异常, 用于在用户身份验证失败时抛出\n    credentials_exception = HTTPException(\n        status_code=status.HTTP_401_UNAUTHORIZED,\n        detail=\"Could not validate credentials\",\n        headers={\"WWW-Authenticate\": \"Bearer\"},\n    )\n\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        # 从 payload 中获取 username\n        # 关于 sub 的解释, 可以参考文档\n        username: str = payload.get(\"sub\")\n        if username is None:\n            raise credentials_exception\n        token_data = TokenData(username=username)\n    except JWTError:\n        raise credentials_exception\n    user = get_user(fake_users_db, username=token_data.username)\n    if user is None:\n        raise credentials_exception\n    return user\n\nasync def get_current_active_user(current_user: User = Depends(get_current_user)):\n    \"\"\"依赖函数, 用于获取当前活跃的用户,用到了上面的依赖函数 get_current_user\n    为什么 current_user 可以是 User 类型而不是 get_current_user 返回的 UserInDB 类型呢?\n    因为 UserInDB 类型是 User 类型的子类, 所以可以直接赋值给 User 类型的变量\n    \"\"\"\n    if current_user.disabled:\n        raise HTTPException(status_code=400, detail=\"Inactive user\")\n    return current_user\n```\n\n在 数据库与模型 中, 我们定义的 `TokenData` 就是这里要用的\n\n因为只是演示,所以这个 `TokenData` 类显得有点多此一举.\n\n但是如果你需要传递多个 JWT 数据，或者有多个函数需要访问 JWT 数据，那么 `TokenData` 类可以方便地将这些数据打包在一起，并在函数之间传递它们。\n\n之后就可以在接口中利用依赖注入,验证用户请求\n\n```python\n@app.get(\"/users/me/\", response_model=User)\nasync def read_users_me(current_user: User = Depends(get_current_active_user)):\n    \"\"\"获取当前用户信息\"\"\"\n    return current_user\n```\n\n## 总结\n\nJWT 是一种认证方式,它的本质是一段带有签名的字符串.\n\n在 Python 中,我们可以使用 `jwt` 模块来创建和解析 jwt token.\n\n在 FastAPI 中,我们可以使用 `OAuth2PasswordBearer` 来获取用户传来的 token,然后使用 `jwt` 模块来解析 token,从而获取用户信息.\n\n## 参考\n\n[JWT 官方文档](https://jwt.io/introduction/)\n\n[FastAPI 官方文档 - 安全性](https://fastapi.tiangolo.com/tutorial/security/)\n\n[FastAPI 官方文档 - 依赖注入](https://fastapi.tiangolo.com/tutorial/dependencies/)\n"},{"title":"将 hexo 博客迁移至 valaxy","tags":["hexo","valaxy","博客","安利"],"categories":["小技术"],"author":"Krau","excerpt":"\n::: warning 注意\n本文章作于 valaxy 版本 0.12.2 , 部分内容可能已经过时 , 请结合[官方文档](https://valaxy.site/guide/getting-started)一起阅读\n:::\n\n## 前言\n\n在 2022 年 8 月份，我向[云游君](https://github.com/YunYouJun)的 hexo 主题 [hexo-theme-yun](https://github.com/YunYouJun/hexo-theme-yun) 提 issue 的时候，他向我提到了 [valaxy](https://valaxy.site/) 这个由他开发的静态博客框架。当时 valaxy 十分先进的技术栈和一些优良特性一下就吸引了我，但是由于我已经使用 hexo 写了很多文章，且 valaxy 也没有迁移文档/工具，所以那时我并没有迁移。\n\n时隔半年，我再去看 valaxy 的时候，它已经基本可用了，文档虽然还是不完整，但是够用。于是我决定将我的 hexo 博客迁移至 valaxy。~~hexo 这贼船越早下越好~~\n\n","link":"/posts/hexo-migrate-to-valaxy/index","content":"\n::: warning 注意\n本文章作于 valaxy 版本 0.12.2 , 部分内容可能已经过时 , 请结合[官方文档](https://valaxy.site/guide/getting-started)一起阅读\n:::\n\n## 前言\n\n在 2022 年 8 月份，我向[云游君](https://github.com/YunYouJun)的 hexo 主题 [hexo-theme-yun](https://github.com/YunYouJun/hexo-theme-yun) 提 issue 的时候，他向我提到了 [valaxy](https://valaxy.site/) 这个由他开发的静态博客框架。当时 valaxy 十分先进的技术栈和一些优良特性一下就吸引了我，但是由于我已经使用 hexo 写了很多文章，且 valaxy 也没有迁移文档/工具，所以那时我并没有迁移。\n\n时隔半年，我再去看 valaxy 的时候，它已经基本可用了，文档虽然还是不完整，但是够用。于是我决定将我的 hexo 博客迁移至 valaxy。~~hexo 这贼船越早下越好~~\n\n<!-- more -->\n\n### 关于 hexo\n\n相信很多博主在搜索“白嫖”建自己的博客网站的时候，第一个了解到的方案就是 hexo + GitHub pages 。hexo 确实经典、成熟，但是却有很多历史问题。功能上不够组件化、体验上不能热更新、性能上构建速度不够快等等。尤其让我感到别扭的是它杂乱的目录结构...尽管已经使用 hexo 三年，我还是决定放弃它了。\n\n### 关于 valaxy\n\n这是一个各种意义上很新的东西，主要由云游君开发，它的目标是成为下一代静态博客框架。\n\n关于 valaxy 的介绍可以在下面获取\n\n- 项目地址：[YunYouJun/valaxy](https://github.com/YunYouJun/valaxy)\n\n- 官方文档：[valaxy](https://valaxy.site/)\n\n但是 valaxy 并不旨在成为下一代的 hexo ，也就是说并不向着与 hexo 的兼容的方向开发。因此迁移起来并不是特别简单。\n\n---\n\n## 创建 valaxy 项目\n\n### 环境\n\nValaxy 要求 Node.js 的 14.18 以上，如果你是从 hexo 的较新版本迁移的，一般不需要去升级。\n\nvalaxy 建议使用 pnpm 作为包管理器，使用 `npm i -g pnpm` 全局安装它\n\n### 创建\n\n在工作文件夹下，使用以下命令\n\n```shell\npnpm create valaxy\n```\n\n然后输入你的博客文件夹名，同时也是项目名称，默认为 `valaxy-blog`。我这里使用 `valaxy-demo`\n\n![输入项目名称](./hexo-migrate-to-valaxy_01-16-13-37-38.webp)\n\n随后询问是否现在安装并启动，确定。\n\n![询问是否安装并启动](./hexo-migrate-to-valaxy_01-16-13-39-16.webp)\n\n很快就完成了项目创建，此时可以在终端中按 o 打开浏览器预览\n\n![预览](./hexo-migrate-to-valaxy_01-16-13-40-50.webp)\n\n进入创建好的项目文件夹，使用以下命令安装依赖\n\n```shell\n# install\npnpm i\n```\n\n### 命令\n\nvalaxy 在默认局部配置脚本下的一些命令\n\n开启本地开发环境（预览，支持热重载）\n\n```shell\npnpm run dev\n```\n\n构建静态文件\n\n```shell\npnpm run build\n```\n\n升级(pnpm 交互升级命令)\n\n```shell\n# upgrade valaxy\npnpm up --latest -i\n```\n\n新建文章\n\n```shell\npnpm new post-title\n```\n\n## 修改配置\n\n在此简要了解一下[目录结构](https://valaxy.site/guide/getting-started#%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84)，见下图\n\n![valaxy目录结构](./hexo-migrate-to-valaxy_01-16-14-13-22.webp)\n\n其中 `valaxy.config.ts` 是主要需要修改的配置。建议使用 VSCode 编辑它，并按照提示安装推荐的插件。\n\n> valaxy.config.ts 提供了完备的类型提示，这意味着你在 VSCode 中可以直接鼠标悬浮查看各参数注释。\n\n默认有些配置项未在 valaxy.config.ts 中给出，使用的是默认值，可以自己添加上就可以覆盖默认值。\n\n### 站点与作者信息\n\n![站点与作者信息配置](./hexo-migrate-to-valaxy_01-16-13-50-34.webp)\n\n- url: '站点链接'\n- lang: '默认语言(valaxy支持单页国际化)'\n- title: '站点标题'\n- subtitle: '副标题'\n- author:\n  - name: '博主名字'\n  - avatar: '头像地址'\n  - status:\n    - emoji: '一个emoji'\n    - message: '状态说明'\n- mode: '默认颜色模式'\n- lastUpdated: '开启最近更新:true'\n- favicon: '站点图标地址'\n- description: '描述'\n\n示例:\n\n```ts\n  url: 'http://krau.top',\n  lang: 'zh-CN',\n  title: '柯罗krau的博客 | krau\\'s blog',\n  subtitle: '',\n  author: {\n    name: '柯罗krau',\n    avatar: '/photo/avatar/avatar.jpg',\n    status:\n    {\n      emoji: '😐',\n      message: '真不想上学'\n  }},\n  mode: 'auto',\n  lastUpdated: true,\n  favicon: '',\n  description: '年轻，就要折腾',\n  //...\n```\n\n### 社交链接\n\n- social\n  - name: '名称'\n  - link: '链接'\n  - icon: '图标'\n  - color: '颜色'\n\n示例:\n\n```ts\nsocial: [\n    {\n      name: 'RSS',\n      link: '/atom.xml',\n      icon: 'i-ri-rss-line',\n      color: 'orange',\n    },\n    {\n      name: 'GitHub',\n      link: 'https://github.com/krau',\n      icon: 'i-ri-github-line',\n      color: '#6e5494',\n    },\n    {\n      name: '网易云音乐',\n      link: 'https://music.163.com/#/user/home?id=1428613796',\n      icon: 'i-ri-netease-cloud-music-line',\n      color: '#C20C0C',\n    },\n    {\n      name: '哔哩哔哩',\n      link: 'https://space.bilibili.com/296036767',\n      icon: 'i-ri-bilibili-line',\n      color: '#FF8EB3',\n    },\n    {\n      name: 'Telegram Channel',\n      link: 'https://t.me/acherkrau',\n      icon: 'i-ri-telegram-line',\n      color: '#0088CC',\n    },\n    {\n      name: 'Telegram Group',\n      link: 'https://t.me/blogszh',\n      icon: 'i-ri:telegram-fill',\n      color: '\"#0088CC'\n    },\n    {\n      name: 'E-Mail',\n      link: 'mailto:me@krau.top',\n      icon: 'i-ri-mail-line',\n      color: '#8E71C1',\n    },\n    {\n      name: 'Travelling',\n      link: 'https://www.travellings.cn/go.html',\n      icon: 'i-ri-train-line',\n      color: 'var(--va-c-text)',\n    },\n  ],\n```\n\n### 搜索\n\n- search\n  - enable: 开启搜索功能:true\n  - type: '搜索方式:local|engine|algolia'\n\n示例:\n\n```ts\n  search: {\n    enable: true,\n    type: 'engine',\n  },\n```\n\n### 赞助\n\n- sponsor\n  - enable: true|false\n  - title: '赞助标题'\n  - methods\n    - name: '赞助方式名称'\n    - url: '链接'\n    - color: '颜色'\n    - icon: '图标'\n\n示例:\n\n```ts\n  sponsor: {\n    enable: false,\n    title: '我很可爱，请给我钱！',\n    methods: [\n      {\n        name: '支付宝',\n        url: '',\n        color: '#00A3EE',\n        icon: 'i-ri-alipay-line',\n      },\n      {\n        name: 'QQ 支付',\n        url: '',\n        color: '#12B7F5',\n        icon: 'i-ri-qq-line',\n      },\n      {\n        name: '微信支付',\n        url: '',\n        color: '#2DC100',\n        icon: 'i-ri-wechat-pay-line',\n      },\n    ],\n  },\n```\n\n### yun主题配置\n\nvalaxy 目前默认主题是 [yun](https://github.com/YunYouJun/valaxy/tree/main/packages/valaxy-theme-yun)\n\n- theme: '主题名称'\n- themeConfig\n  - banner\n    - enable: 是否开启首页标题动画:true|false\n    - title: '标题'\n  - bg_image:\n    - enable: 是否开启背景图:true|false\n    - url: '背景图链接'\n    - dark: '深色模式下的背景图'\n    - opactity: 背景不透明度:float\n  - colors:\n    - primary: '主题色,支持16进制任意配色'\n  - say:\n    - enable: 是否开启一言:true|false\n    - api: '一言api地址,可留空使用默认'\n  - pages //页面配置\n    - name: '名称'\n    - url: '路径|链接'\n    - icon: '图标'\n    - color: '颜色'\n  - footer\n    - since: 网站开始年份\n    - beian\n      - enable: 是否开启备案信息显示:true|false\n      - icp: '备案信息'\n\n示例:\n\n```ts\n  theme: 'yun',\n\n  themeConfig: {\n    banner: {\n      enable: true,\n      title: '柯罗の自留地',\n    },\n    bg_image: {\n      enable: true,\n      url: '/photo/bg/atri.webp',\n      dark: '/photo/bg/bg.webp',\n      opacity: 0.7\n    },\n    colors: {\n      primary: '#39c5bb'\n    },\n    say:{\n      enable: false\n    },\n    pages: [\n      {\n        name: '友人帐',\n        url: '/links/',\n        icon: 'i-ri-genderless-line',\n        color: 'dodgerblue',\n      },\n      {\n        name: 'My Love',\n        url: '/girls/',\n        icon: 'i-ri-women-line',\n        color: 'hotpink',\n      },\n    ],\n\n    footer: {\n      since: 2020,\n      beian: {\n        enable: false,\n        icp: '苏ICP备17038157号',\n      },\n\n    },\n  },\n```\n\n### 评论\n\nvalaxy 通过插件的方式实现评论，目前实现了对 [waline](https://waline.js.org) 的支持\n\n```ts\n  comment: {\n    enable: true,\n  },\n\n  addons: [\n    addonWaline({\n      serverURL: '后端链接',\n      //以下功能未实现，但可以先写进配置里\n      pageview: true,\n      dark: 'auto',\n      requiredMeta: ['nick','mail'],\n      locale:{\n        placeholder: '填写邮箱，可以收到回复通知~'\n      }\n        \n    }),\n  ],\n```\n\n### 完整配置文件示例\n\n```ts\nimport { defineConfig } from 'valaxy'\nimport type { ThemeConfig } from 'valaxy-theme-yun'\nimport { addonWaline } from 'valaxy-addon-waline'\n//import { defineConfig } from 'vite'\n// add icons what you will need\n\n/**\n * User Config\n */\n\nexport default defineConfig<ThemeConfig>({\n  url: 'https://krau.top',\n  lang: 'zh-CN',\n  title: '柯罗krau的博客 | krau\\'s blog',\n  subtitle: '',\n  author: {\n    name: '柯罗krau',\n    avatar: '/photo/avatar/avatar.jpg',\n    status:\n    {\n      emoji: '😐',\n      message: '真不想上学'\n  }},\n  mode: 'auto',\n  lastUpdated: true,\n  favicon: '',\n  description: '年轻，就要折腾',\n  social: [\n    {\n      name: 'RSS',\n      link: '/atom.xml',\n      icon: 'i-ri-rss-line',\n      color: 'orange',\n    },\n    {\n      name: 'GitHub',\n      link: 'https://github.com/krau',\n      icon: 'i-ri-github-line',\n      color: '#6e5494',\n    },\n    {\n      name: '网易云音乐',\n      link: 'https://music.163.com/#/user/home?id=1428613796',\n      icon: 'i-ri-netease-cloud-music-line',\n      color: '#C20C0C',\n    },\n    {\n      name: '哔哩哔哩',\n      link: 'https://space.bilibili.com/296036767',\n      icon: 'i-ri-bilibili-line',\n      color: '#FF8EB3',\n    },\n    {\n      name: 'Telegram Channel',\n      link: 'https://t.me/acherkrau',\n      icon: 'i-ri-telegram-line',\n      color: '#0088CC',\n    },\n    {\n      name: 'Telegram Group',\n      link: 'https://t.me/blogszh',\n      icon: 'i-ri:telegram-fill',\n      color: '\"#0088CC'\n    },\n    {\n      name: 'E-Mail',\n      link: 'mailto:me@krau.top',\n      icon: 'i-ri-mail-line',\n      color: '#8E71C1',\n    },\n    {\n      name: 'Travelling',\n      link: 'https://www.travellings.cn/go.html',\n      icon: 'i-ri-train-line',\n      color: 'var(--va-c-text)',\n    },\n  ],\n\n  search: {\n    enable: true,\n    type: 'engine',\n  },\n\n  sponsor: {\n    enable: false,\n    title: '我很可爱，请给我钱！',\n    methods: [\n      {\n        name: '支付宝',\n        url: '',\n        color: '#00A3EE',\n        icon: 'i-ri-alipay-line',\n      },\n      {\n        name: 'QQ 支付',\n        url: '',\n        color: '#12B7F5',\n        icon: 'i-ri-qq-line',\n      },\n      {\n        name: '微信支付',\n        url: '',\n        color: '#2DC100',\n        icon: 'i-ri-wechat-pay-line',\n      },\n    ],\n  },\n\n  theme: 'yun',\n\n  themeConfig: {\n    banner: {\n      enable: true,\n      title: '柯罗の自留地',\n    },\n    bg_image: {\n      enable: true,\n      url: '/photo/bg/atri.webp',\n      dark: '/photo/bg/bg.webp',\n      opacity: 0.7\n    },\n    colors: {\n      primary: '#39c5bb'\n    },\n    say:{\n      enable: false\n    },\n    pages: [\n      {\n        name: '友人帐',\n        url: '/links/',\n        icon: 'i-ri-genderless-line',\n        color: 'dodgerblue',\n      },\n      {\n        name: 'My Love',\n        url: '/girls/',\n        icon: 'i-ri-women-line',\n        color: 'hotpink',\n      },\n    ],\n\n    footer: {\n      since: 2020,\n      beian: {\n        enable: false,\n        icp: '苏ICP备17038157号',\n      },\n\n    },\n  },\n\n  unocss: {\n    safelist: [\n      'i-ri-home-line',\n    ],\n  },\n\n  comment: {\n    enable: true,\n  },\n\n  addons: [\n    addonWaline({\n      serverURL: 'https://后端',\n      pageview: true,\n      dark: 'auto',\n      requiredMeta: ['nick','mail'],\n      locale:{\n        placeholder: '填写邮箱，可以收到回复通知~'\n      }\n        \n    }),\n  ],\n})\n```\n\n## 迁移文章\n\n### 批量修改 frontmatter\n\n由于原先在 hexo 的文章有太多 valaxy 不支持的 frontmatter 项，所以需要批量修改它们，以免引起奇怪的问题\n\n由于文章数多，所以写个简单的脚本批量操作\n\n需要先安装 `python-frontmatter`\n\n```shell\npip3 install python-frontmatter\n```\n\n```python\nimport frontmatter\nimport glob\n\npath = 'posts' #你的文章路径，相对于该脚本\nmds = glob.glob(f'./{path}/*.md')\n\ndef del_metedata(md: str, key: str | list):\n    post = frontmatter.load(md)\n    metedata = post.metadata\n    try:\n        if isinstance(key, list):\n            for k in key:\n                try:\n                    del metedata[k]\n                except:\n                    continue\n        elif isinstance(key, str):\n            del metedata[key]\n        else:\n            raise TypeError('key 是 str 或 list')\n        frontmatter.dump(post, md)\n    except Exception as e:\n        print(f'{e} 在 {md}')\n\n\ndef add_metedata(md: str, key: str, value: str):\n    post = frontmatter.load(md)\n    metedata = post.metadata\n    try:\n        metedata[key] = value\n        frontmatter.dump(post, md)\n    except Exception as e:\n        print(f'{e} 在 {md}')\n\ndef main():\n    del_keys = [\n        #要删除的项，你可以根据需要修改\n        'toc',\n        'abbrlink',\n        'mathjax',\n        'author',\n        'hide',\n        'sitemap',\n        'indexing',\n        'top',\n        'password',\n        'summary',\n        'comments',\n        'reward',\n        'license',\n        'edit',\n        'copyright',\n        'sticky',\n        'description'\n    ]\n    for md in mds:\n        del_metedata(md,del_keys)\n        #添加你需要的项,如添加 layout: post\n        add_metedata(md, 'layout', 'post')\n\n\nif __name__ == '__main__':\n    main()\n```\n\n### 修改文章内图片路径\n\n如果你全站都使用的图床，可以忽略这一步。而我为了方便管理，把图片放在了本地，所以需要修改\n\n原先是在 hexo 的 source 目录下，需要使用相对路径引用。而 valaxy 可以**直接引用**静态文件夹(`public`)内的文件，直接使用 /xxxx 即可\n\n例如，我原先的图片路径是\n\n`../photos/post-pics/1.webp`\n\n那么只需要**将原先在 hexo 博客目录的 photos 文件夹移动到 valaxy 的 public 文件夹**下，然后将路径修改为\n\n`/photos/post-pics/1.webp`\n\n这里的修改可以使用 VSCode 的全局关键字替换功能\n\n### 移动文章\n\n把文章移动到 `博客文件夹/pages/posts` 下即可\n\n但是我在操作的时候发现，一次性塞进去太多文章会导致预览页面加载不出来，这可能是一个 bug (版本 0.12.2 )。当然构建是没问题的，所以如果你不需要本地预览的话，可以直接都丢进去。\n\n## 迁移友联页面\n\nvalaxy 的 yun 主题的友联页面在 pages/links/index.md，在 frontmatter 里配置就可以了，参考 [valaxy-theme-yun 文档](https://github.com/YunYouJun/valaxy/tree/main/packages/valaxy-theme-yun/docs/zh-CN)\n\n注意 frontmatter 的下面要写一个\n\n```html\n<YunLinks :links=\"frontmatter.links\" :random=\"frontmatter.random\" />\n```\n\n## 迁移 [girls](/girls/) 页面\n\n与 [hexo-theme-yun](https://yun.yunyoujun.cn/guide/page.html#girls) 的配置相同，但是 frontmatter 下面要加上\n\n```html\n<YunGirls :girls=\"frontmatter.girls\" :random=\"frontmatter.random\" />\n```\n\n~~哪来的二次元~~\n\n---\n\n这样就完成迁移了。如果有其他问题，或者需要更多信息，可以对比[云游君的博客仓库](https://valaxy.site/migration/hexo#%E7%A4%BA%E4%BE%8B)中 hexo 和 valaxy 分支的差异。或者提出 [issue](https://github.com/YunYouJun/valaxy/issues/new) 、提出[讨论](https://github.com/YunYouJun/valaxy/discussions/new/choose) ，以及在我博客下评论留言。\n"},{"title":"Debian/Linux安装最新Python版本及多版本环境管理","tags":["Python","Linux"],"categories":"小技术","author":"Krau","excerpt":"\nPython 的环境管理确实烦,而且会出现版本之间不兼容的情况,所以有必要知道如何安装不同版本的 Python 并管理其环境.\n\n本文系统环境为 Debian11, 虚拟环境工具使用的是 venv, 采用编译安装的方法. Python 版本为 3.11.6\n\n","link":"/posts/install-manage-python-version-on-linux/index","content":"\nPython 的环境管理确实烦,而且会出现版本之间不兼容的情况,所以有必要知道如何安装不同版本的 Python 并管理其环境.\n\n本文系统环境为 Debian11, 虚拟环境工具使用的是 venv, 采用编译安装的方法. Python 版本为 3.11.6\n\n<!-- more -->\n\n## 安装\n\n### 下载Python源码\n\n去往 [Python 官网](https://www.python.org/downloads/) 下载你想安装的版本的源码, 以目前最新的 Python3.11 为例\n\n![图 3](./install-manage-python-version-on-linux_04-13-15-38-10.webp)  \n\n使用 wget 下载:\n\n```shell\nwget https://www.python.org/ftp/python/3.11.6/Python-3.11.6.tar.xz\n```\n\n### 配置构建\n\n下载完成后, 将其解压:\n\n```shell\ntar -xf Python-3.11.6.tar.xz\n```\n\n安装必要的依赖软件:\n\n```shell\nsudo apt update\n\nsudo apt install build-essential zlib1g-dev libncurses5-dev \\\nlibgdbm-dev libnss3-dev libssl-dev libsqlite3-dev pkg-config \\\nlibreadline-dev libffi-dev curl libbz2-dev curl libgdbm-dev \\ \nlzma-dev uuid-dev libsqlite3-dev openssl tk8.6-dev -y\n```\n\n进入 Python 源码文件夹, 并配置\n\n```shell\ncd Python-3.11.6\n./configure --enable-optimizations --with-lto --prefix=/usr/local/python3.11\n```\n\n::: tip 注意\n`configure` 后的 `--enable-optimizations` `--with-lto` 两个参数是为了提高性能, 但它会使得 Python 编译过程变慢, 你可以选择不启用它们. 如果你遇到了问题, 可以尝试只开启 `--enable-optimizations`, 或者二者都不使用\n\n关于配置参数的更多信息, 可以参阅[官方文档](https://docs.python.org/zh-cn/3/using/configure.html)\n:::\n\n如果上面命令的输出没有错误, 那么就可以开始编译了.\n\n![图 4](./install-manage-python-version-on-linux_04-13-15-52-08.webp)  \n\n若提示缺少某个依赖, 请手动安装它\n\n### 编译安装\n\n运行 `make` 即可开始构建 Python , 若你有多个 cpu 核心, 可以加上 `-j` 参数来多核编译, `-j` 后是你的 cpu 核心数, 可以使用 `nproc` 获取\n\n若你机器的性能不佳, 这一过程可能十分漫长(几十分钟甚至更久), 你可以使用 screen 或 tmux 使其在后台运行\n\n![图 5](./install-manage-python-version-on-linux_04-13-15-57-12.webp)  \n\n完成后, 使用 `sudo make altinstall` 安装(可能也很漫长,但比上一步要快), 之后你就可以使用 Python3.11:\n\n![图 6](./install-manage-python-version-on-linux_04-13-16-21-43.webp)  \n\n```shell\npython3.11 --version\n```\n\n![图 7](./install-manage-python-version-on-linux_04-13-16-25-55.webp)  \n\n## 环境管理\n\n### 虚拟环境\n\n#### 创建\n\nPython 的虚拟环境可以将项目与全局环境相互隔离,可以避免污染你的系统环境,并方便得使多个 Python 版本共存与切换.\n\n本文使用的虚拟环境工具是 [venv](https://docs.python.org/3/library/venv.html) , 它是 Python 官方推荐的工具.\n\n> 但其实更现代的工具是 [poetry](https://python-poetry.org/) , 然而其使用比较复杂,且主要面向 pypl 模块开发者, 如有兴趣你可以自行了解.\n\n安装 venv:\n\n```shell\napt install python3-venv\n```\n\n使用以下命令在当前目录下创建虚拟环境:\n\n```shell\npython3.11 -m venv myenv\n```\n\n这个命令会在你当前目录下创建 `myenv` 文件夹, 它就是一个\"虚拟环境\", 其中包含了你所指定的 `Python3.11` 版本, 未来在虚拟环境中安装的第三方库等文件也会在此文件夹内.\n\n显然, 如果你想创建一个其他 Python 版本的虚拟环境, 那么只需要将前面的 `python3.11` 改成你需要的版本且已经安装的即可\n\n#### 使用\n\n创建完成后,要进入到虚拟环境,需要激活它,使用以下命令.\n\n```shell\nsource myenv/bin/activate\n```\n\n这时你的终端应该会有一些标识来提示你处在虚拟环境中,如下\n\n![图 10](./install-manage-python-version-on-linux_04-13-16-54-47.webp)  \n\n在虚拟环境中, `python` `python3.11` `python3` 命令都可以打开 python ,并且版本都是 python3.11\n\n在其中使用 pip 安装的包也都在虚拟环境中\n\n使用 `deactive` 命令可退出虚拟环境\n\n#### 删除\n\n使用 venv 工具创建的虚拟环境实际上就是一个文件夹, 删除它就是删除了环境\n\n### 默认版本\n\n始终建议使用官方软件源提供的 python 作为默认版本, 如果你真的想要替换默认版本, 那么可以使用下面的命令\n\n```shell\nsudo ln -sf /usr/bin/python3.11 /usr/bin/python\n```\n\n这条命令将 python3.11 的可执行文件链接到 linux PATH 的默认搜索路径中, 此时系统的默认版本就是 3.11\n\n::: tip\n即使默认版本就是你想要使用的 Python 版本, 你也应该在你的项目里创建虚拟环境, 除非你想把自己的系统环境搞得乱七八糟\n:::\n"},{"title":"自己动手制作网线水晶头","tags":["DIY"],"categories":"小技术","author":"Krau","excerpt":"\n我最近买了一台二手主机当nas用, 但是由于我家的布局设置, 必须要把这台主机放置在离路由器较远的一个位置。所以我直接买了根超长网线 (指30m) 以防长度不够, 但是到手之后发现, 我严重高估了我所需的长度, 于是把这根长网线剪去一大段, 并去学会了接网线水晶头的操作。\n\n","link":"/posts/make-cable/index","content":"\n我最近买了一台二手主机当nas用, 但是由于我家的布局设置, 必须要把这台主机放置在离路由器较远的一个位置。所以我直接买了根超长网线 (指30m) 以防长度不够, 但是到手之后发现, 我严重高估了我所需的长度, 于是把这根长网线剪去一大段, 并去学会了接网线水晶头的操作。\n\n<!-- more -->\n\n## 准备工具\n\n制作水晶头需要以下工具：\n\n1. 网线钳（某宝十块钱左右一个, 还送一些水晶头和墙钉）\n2. 水晶头（买网线钳送）\n3. 剥线刀（买网线钳也送）\n\n所以实际上你只需要去某宝购买一个小套装即可。\n\n## 实操\n\n一般购买到的一根超长网线, 两端是接好水晶头的, 但是我们不需要这么长, 所以截取你需要的长度, 用剪刀剪下一端。\n\n![](./make-cable_2022-06-20-22-37-16.webp)\n\n然后用剥线刀把这端的一段外皮剥去。\n把剥线刀在剥线位点上转一圈即可。\n![](./make-cable_2022-06-20-22-38-39.webp)\n\n剥完皮是这样的\n\n![](./make-cable_2022-06-20-22-39-25.webp)\n\n仔细观察, 这根网线内有八根线, 各自有着不同的颜色, 尤其注意白线, 它们带有的颜色也是不同的。这八根线色分别是 **橙白、绿白、蓝白、棕白、橙色、绿色、蓝色、棕色**。\n\n![](./make-cable_2022-06-20-22-43-11.webp)\n\n![](./make-cable_2022-06-20-22-43-20.webp)\n\n接下来把这八根线理顺好, 用网线钳把它们剪成齐平。\n\n![](./make-cable_2022-06-20-22-44-37.webp)\n\n然后理顺八根线的次序, 如图（引用自淘宝某店铺）。\n\n![](./make-cable_2022-06-20-22-46-03.webp)\n\n![](./make-cable_2022-06-20-22-46-23.webp)\n\n再把线塞入水晶头, 注意排列顺序与水晶头的正反。\n\n![](./make-cable_2022-06-20-22-47-27.webp)\n\n最后用网线钳压下水晶头, 听见咔哒声就算完成了。\n\n![](./make-cable_2022-06-20-22-49-06.webp)\n"},{"title":"常轨脱离 Misanthrope","tags":[],"categories":"日常","author":"Krau","excerpt":"\n## 又是一年冬季\n\n很久没有往自己博客的\"日常\"文件夹里发过什么东西, 倒不如说这个网站本身已近一年未曾打理. 一是倦怠, 二是顾虑.\n\n倦怠了像写流水账一样记录自己无关痛痒的日常, 顾虑于现实中","link":"/posts/mashed-potato-future/index","content":"\n## 又是一年冬季\n\n很久没有往自己博客的\"日常\"文件夹里发过什么东西, 倒不如说这个网站本身已近一年未曾打理. 一是倦怠, 二是顾虑.\n\n倦怠了像写流水账一样记录自己无关痛痒的日常, 顾虑于现实中的一些\"大人们\"和\"朋友们\"可能的对这个网站的窥视.\n\n以往的文章大半也删了去, 无论是\"技术\"还是\"日常\". 年少轻狂, 写东西总忍不住追求辞藻华丽. 写的不是文章, 是多巴胺. 那时候写的东西现在看来有太多可吐槽之处, 倒不如删除了之.\n\n截至今日今年所发的都是一些所谓技术向的内容, 其实更多的也只是我稍微学了一点新知识来卖弄两句. 不过今天还是稍微聊下近况.\n\n---\n\n今年其实也发生了很多事情, 也有很多没有记录的想法, 不过既然已经过去, 那便装作它们是鸡毛和蒜皮.\n\n作为博客网站, 就先聊下这个网站本身.\n\n年初时我终于抛弃了用了三年的 Hexo, 转而使用 [Valaxy](https://valaxy.site/) 这个\"下一代静态博客框架\". 由于前后都使用的同一个作者的同一个主题( [yun](https://github.com/YunYouJun/valaxy/tree/main/packages/valaxy-theme-yun) ), 可能从外观上看网站并没有什么变化, 但对于我写作, 部署和维护的体验确实是好了许多. 并且我现在学了一些 vue, 基于 valaxy 和 vue 的一些特性, 或许有空可以定制一下这个网站.\n\n如果你也想从 Hexo 迁移至 valaxy, 可以参考下官方文档和[这篇文章](/posts/hexo-migrate-to-valaxy/index.md).\n\n以及更换了主题色和背景图, 看起来更加温暖了些. 虽然这些无关紧要, 但是很久以来它们确实都没有变更过.\n\n我一直坚持用静态框架来构建博客. 这样有两个显而易见的优点. 一是无论从时间或精力的花费, 还是金钱的开销上来看, 相比于具有后端的博客系统成本都降低了. 二是能保证这个博客更轻易地存在更长时间, 这是第一点所带来的.\n\n在早期这个博客一直是十分之七的琐碎日常的灌水和十分之三的没有什么含金量的技术分享, 曾经有一段时间想把它打造为所谓的\"技术博客\", 于是删去了所有的\"非技术\"的文章. 但不久之后我看着博客上那一张张毫无生命感的文章卡片, 顿时生出一种难以形容异样感. 就像是见到了和自己一模一样的木偶在机械地说话, 又像是在吃发霉的土豆用清水炖成的泥. 于是便决定回归更多的碎碎念灌水.\n\n说是写博客单纯为了记录, 但要是有人来访留言几句, 或者申请友联, 还是会暗暗开心一下. 毕竟人总会有些分享欲.\n\n今年暂停了作为学生的身份. 也就是没有上学. 想起来之前玩过一款 galgame 叫 [常轨脱离](https://zh.moegirl.org.cn/zh-hans/%E5%B8%B8%E8%BD%A8%E8%84%B1%E7%A6%BBCreative), 那我现在各种意义上也算是脱离了\"常轨\".\n\n不过同样都是\"不上学\", 游戏里的生活可比现实美丽多了, 而那种生活在我认知之内也只有虚构的.\n\n随着去年六月的炎夏, 我普普通通地参加高考, 拿到普普通通的成绩, 被武汉一所普普通通的一本录取. 我也终于结束了我那牢狱一般的中学教育.\n\n虽然现在说起来很普通, 但其实是发生了很多事, 并且也间接导致我现在休学中的状况. 我实在不愿回忆和叙述它们.\n\n寒假过后我依然希望自己能坚持下去, 但显然没有成功. 于是第二学期仅仅到了学校三天, 我就回来开始了为期一年的休学.\n\n---\n\n初到家里有些无所适从, 以及去办休学相关手续的时候总有种莫大的愧疚感. 现在我知道那就是所谓的\"好学生心态\". 在河南农村, 大部分同龄人的归宿是辍学打工或是职校大专, 所以我便一直被认为是一个好学生, 被要求成为一个好学生.\n\n不过一段时间之后便适应了下来. 我开始做些事情. 过去由于学业, 很多想做的事情都被学校和家庭归为无意义的, 无价值的. 如今看来那些事都比做一套高考模拟试卷更加有益.\n\n我开始尝试主动社交, 不过主要是在网络上. 在过去这对我来说是不可能的, 如果没有休学在以后也很可能不会. 初衷可能更多的是出于对独自在家的不安, 但结果总是好的. 遇见了各种各样的人, 认识了不少朋友, 还和几位见了面, 去他们的城市看了看, 一起度过了一些愉快的时间. 不过可惜没有拍很多能展示的照片.\n\n[Travel-2023](/albums/travel-2023.md)\n\n即使去了不少地方, 相比于一年的长度来说, 旅行的时间仍是短暂. 大部分的时间我还是待在家里, 坐在屏幕前. 有时候无所事事地浏览各种社交媒体, 有时候也认真地学习一些感兴趣的技术.\n\n家里并不同意我休学, 而我给出的说法是休学是为了学习技术. 所以其实休学期间的\"正事\"还是学习. 不过和学校教育中的学习有很大区别. 倒不如说, \"学习\"一词的意义是被教育体制, 家庭, 社会压力等东西所改变, 变成了踩着别人的尸骨通往\"成功\"的手段.\n\n之前虽然对 CS 有很大兴趣, 但更多的时间只是在\"折腾\": 折腾各种电子硬件, 搭建各种应用服务, 以及使用各种软件或系统. 这个博客也是折腾的产物之一. 我甚至一直大言不惭地把\"年轻就要折腾\"作为博客的标语.\n\n现在看来当然不能说折腾没用, 它让我了解了相当多的碎片知识, 也见过和解决了很多疑难杂症, 有了比较好的\"使用电脑\"的能力. 但是终究是作为\"用户\"而不是\"创作者\". 而显然后者总是比前者更能在某一领域深入.\n\n那时并不是没想创作, 反而是非常想要系统地学习某个方向的知识, 能够做出些什么东西. 但可惜仍然是碍于中学学业, 能挤出一些时间来折腾对我来说已经很是困难. 所以直到今年休学, 我才能开始真正写一些代码. 到现在也做了些小玩具, 有开源的或是不开源的. 正如前文所说, 接下来的计划可能是给博客写一套主题, 或是开发一个自己的博客系统.\n\n中学以来有很大的一个感触, 人在做自己喜欢的事时是内驱力强大的, 根本不需要去谈\"坚持\"或是\"努力\", 所以用这两个词形容的事情往往都是你讨厌做的事. 学校中的学习便是最大的例子. 关于我高中的种种我已经不想再提, 可以肯定的是, 那三年让我被迫失去了很多东西, 也给我造成了很大的创伤. 而大学里发生的事可能是二次伤害.\n\n有时候翻着以前的自己留下的痕迹, 或是照片或是文字, 总觉得很怀念, 也觉得很厌恶. 怀念随着一张张试卷一起逝去的热情, 厌恶伴着一次次打压一起收获的软弱. 我看着他无数次尝试喜欢自己, 热爱生活. 又无数次被生活伤害, 被自己厌恶. 终于他变成了我, 一个消极完美主义者, 一个偏执的厌世者.\n\n说回休学之后的生活.\n\n今年新增和更换了不少电子设备, 也卖掉了一些. 其中对我幸福感提升最大的产品是一台显示器. 对于像我这样每天绝大部分时间都对着屏幕的人, 一个更大更好的屏幕会十分有用. 不过它的尺寸似乎有些大了, 放学校宿舍的桌子上几乎占满了空间, 比较显眼. 但开学后应该还是会带去, 毕竟笔记本十几寸的高分屏着实难受了些. 相比以前来说, 在这一年里几乎没有搞\"二次元\", 也就是几乎没有看什么动画, 漫画或是小说, 也没有玩什么游戏. 这些东西只有回顾的时候才发现, 自己已经不知不觉地与\"圈子\"脱离. 不过倒是入坑了一款街机音游 ([maimai](https://zh.wikipedia.org/wiki/Maimai)), 天气不错的时候就去机厅玩, 大部分时候它能带给我一些愉悦感.\n\n五月份的时候和几个同学也是朋友们去了一次漫展, 武汉梦乡, 一个不大不小的展. 这是我第二次去漫展, 上一次是在高考完的那个暑假, 也是武汉. 相比于第一次少了些新奇感, 多了些疲惫感. 不知道变得无趣的是漫展还是我. 不过漫展的氛围还是让我很舒适, 和熟人或者陌生人一起发疯, 一起整活.\n\n[查看相册](/albums/comic-con-wuhan-2305.md)\n\n旅行能让人收获很多. 出去之后就会发现自己是如此渺小, 幼稚和无知. 在旅途中我经历了许多的\"第一次\", 得到了生活的见闻和经验, 也好像拾回了一些失去的东西. 我自认为对\"归属感\"并没有什么概念, 或许会有些向往四海漂泊的生活. 但马上就要过年了, 也意味着我不太充实也不太无聊的休学生活的结束, 在复学之前是否还会旅行, 下一站又去哪里, 也还没有打算. 但无法由我打算的是, 几个月之后我就要再次踏上不得不去的旅途.\n\n家庭环境, 学校的pua, 苦难和感恩教育让我以前总是秉持着一种可悲的自卑与可怜的自尊. 最初休学时还会担忧学校方面和邻里亲戚对我的看法, 以及复学后如何面对以往的和新的老师和同学, 现在醒悟这种心态仍是那些伤害所带来的, 其实根本都是些无关痛痒之事, I don't care. 包括文首提到的顾虑或许也一样是因为自我被长时间压抑而怯于表达, 但能写下这篇文章也就说明我不再有那样的顾虑.\n\n由于各种各样的原因, 一年里的精神呢状态并不算太好, 偶尔还是会有像在学校一样情绪崩溃的时候. 但也不算太差, 从我自己的感受上是随时间渐渐好转的. 临近复学, 偶尔还是会焦虑, 但我已经不知道自己在焦虑什么. 也许学校造成的阴影还在让我无意识地排斥上学这件事. 不过我觉得自己已经比去年更强大了.\n\n本想再聊下去, 继续谈谈环境与人格, 教育与成长之类的话题. 但写到此处已是深夜, 我冰冷的四肢和疲惫的眼睛已经不愿再活动. 由于显而易见的原因, 去年并没有写所谓的年终总结. 今年会不会写也暂且未知, 可能会就把此篇就作为总结. 而现在还是睡觉吧.\n"},{"title":"Minecraft开服入门","tags":["Minecraft","DIY","游戏","服务器"],"categories":"小技术","author":"Krau","excerpt":"\n想和基友们联机玩mc，相比于使用各种联机平台，或搭建虚拟局域网，不如自己直接开个服务器。既不用保持至少一人在线，又能避免玩游戏时需要额外运行一个联机程序的臃肿。\n\n本文记录博主自己的mc开服经历。\n\n","link":"/posts/mc-host-server/index","content":"\n想和基友们联机玩mc，相比于使用各种联机平台，或搭建虚拟局域网，不如自己直接开个服务器。既不用保持至少一人在线，又能避免玩游戏时需要额外运行一个联机程序的臃肿。\n\n本文记录博主自己的mc开服经历。\n\n<!-- more -->\n\n## 工具选择与准备\n\n### 主机选择\n\n我起初有开mc服的计划时是还在上高三，没有详细了解各方面的信息，因此当时想拉上几个基友集资购买云主机，在云主机上开服。\n\n但高考完放假之后我去了解了一下云主机的价格，还是把原来的打算作废了。\n\n我的需求是让我的服务器 **安装一些大型模组并保证十人能同时在线不卡顿**。而显然价格相对低的轻量云主机（指几百块一年）难以满足。\n\n于是我决定在自己电脑上开服。但是用自己的主力机实在感觉不妥，一来它的高功耗会导致电费的额外支出，~~二来心疼它二十四小时不关机~~。\n\n最终，我决定再组一台低功耗主机，用来开设mc服务器的同时，还能当nas用。\n\n但是我发现，由于洋垃圾市场炒的厉害，分别购买cpu、主板、内存、硬盘配件，还不如直接购买二手整机来的划算。于是去海鲜市场（闲鱼）买了台整机。\n\n![](./mc-host-server_1.webp)\n\n以T结尾的intel处理器代表低功耗，正适合作为服务器使用。\n\n到手之后重装了Windows10 LTSC。\n\n### 游戏版本选择\n\n游戏版本选择是我最纠结的地方，由于学业原因，我近乎三年没有碰mc，再回过来看的时候最新版本已经是1.19了，而且fabric似乎也流行了起来，越来越多的模组和资源包开始仅支持较高版本且仅兼容fabric，就连java的最新版本居然也到了17。但我更熟悉的是forge和旧版本。本想跟联机基友们共同商量，可他们也是什么都不知道。最终抱着延续初中的玩法的想法，选择了1.12.2这个时至今日已经是远古的版本。\n\n### 服务端软件选择\n\n由于我此前只有建设mc基岩版服的经验，当时基岩版只有官方服务端，所以也没有什么选择。\n\n但je（java edition）服务端不一样，各种服务端看的我眼花缭乱，最终草率地随大流，选择了[Catserver（猫端）](https://catmc.org/)这一使用人数众多的服务端。\n\n~~先开了再说，大不了redo~~\n\n## 开服\n\n选择好以上这些东西之后，就有了开服的方向，接下来的事情就很简单了，只需要动手去做就好了。\n\n### 配置服务端\n\n#### 下载与初始化catserver服务端\n\n先在java官网，下载java8。\n\n前往[catserver官网](https://catmc.org/)或[github仓库](https://github.com/Luohuayu/CatServer)下载所需版本的catserver。\n\n下载的是一个.jar单文件，把它重命名为Catserver.jar放入一个空文件夹，该文件夹名与路径尽量使用纯英文，避免出现奇怪的错误。\n\n在该空文件夹内，新建一个文本文档，并写入以下内容：\n\n```bat\njava -Xmx6G -XX:+UseG1GC -XX:+ParallelRefProcEnabled -XX:MaxGCPauseMillis=200 -XX:+UnlockExperimentalVMOptions -XX:+DisableExplicitGC -XX:+AlwaysPreTouch -XX:G1NewSizePercent=30 -XX:G1MaxNewSizePercent=40 -XX:G1HeapRegionSize=8M -XX:G1ReservePercent=20 -XX:G1HeapWastePercent=5 -XX:G1MixedGCCountTarget=4 -XX:InitiatingHeapOccupancyPercent=15 -XX:G1MixedGCLiveThresholdPercent=90 -Dfml.queryResult=confirm -jar CatServer.jar\n```\n\n这段内容的解释：\n\n-Xmx6G ：设定服务端最大内存为6G\n\n-XX等参数：开启G1GC和优化GC，[详见此贴](https://www.mcbbs.net/thread-1085422-1-1.html)\n\n然后把该文本重命名为strat.bat，双击运行该bat。\n\n之后，猫端会自动下载所需的文件，并释放到同目录下，这样就完成了服务端的初始化。初始化完成后的目录文件如下\n\n![](./mc-host-server_2.webp)\n\n#### 修改服务端配置文件\n\n初始化完成后，需要修改以下几个文件\n\n- server.properties\n- bukkit.yml\n- catserver.yml\n- spigot.yml\n\n参考这两帖，根据需求进行修改。\n\n[ [服务器应用] 【优化】服务器优化指南 | 和卡顿永远说再见 ](https://www.mcbbs.net/forum.php?mod=viewthread&tid=774469)\n\n[ [服务器应用] Minecraft服务器优化教程 —— 让多带50%的玩家不再是梦 ](https://www.mcbbs.net/forum.php?mod=viewthread&tid=478126)\n\n下面是我修改后的配置文件\n\n- server.properties\n\n```ini\n#Minecraft server properties\n#Sun Jun 19 19:24:15 CST 2022\nspawn-protection=16\nmax-tick-time=60000\ngenerator-settings=\nforce-gamemode=false\nallow-nether=true\ngamemode=0\nbroadcast-console-to-ops=true\nenable-query=false\nplayer-idle-timeout=0\ndifficulty=2\nspawn-monsters=true\nop-permission-level=4\npvp=true\nsnooper-enabled=true\nlevel-type=DEFAULT\nhardcore=false\nenable-command-block=true\nmax-players=10\nnetwork-compression-threshold=-1\nresource-pack-sha1=\nmax-world-size=29999984\nserver-port=25565\nserver-ip=0.0.0.0\nspawn-npcs=true\nallow-flight=true\nlevel-name=world\nview-distance=8\nresource-pack=\nspawn-animals=true\nwhite-list=true #开启白名单\ngenerate-structures=true\nonline-mode=flase #关闭正版验证\nmax-build-height=256\nlevel-seed=\nprevent-proxy-connections=false\nenable-rcon=false\nmotd=fish world\n```\n\n- bukkit.yml\n\n```yaml\nsettings:\n  allow-end: true\n  warn-on-overload: true\n  permissions-file: permissions.yml\n  update-folder: update\n  plugin-profiling: false\n  connection-throttle: 4000\n  query-plugins: true\n  deprecated-verbose: default\n  shutdown-message: Server closed\nspawn-limits:\n  monsters: 50\n  animals: 15\n  water-animals: 5\n  ambient: 3\nchunk-gc:\n  period-in-ticks: 400\n  load-threshold: 300\nticks-per:\n  animal-spawns: 400\n  monster-spawns: 2\n  autosave: 6000\naliases: now-in-commands.yml\n```\n\n- catserver.yml\n\n```yaml\nworld:\n  keepSpawnInMemory: false\n  enableSkipEntityTick: true\n  enableSkipTileEntityTick: false\n  worldGenMaxTick: 15\n  disableForgeGenerateWorlds:\n  - ExampleCustomWorld\n  preventBlockLoadChunk: false\n  autoUnloadDimensions:\n  - 99999999\n  enableRealtime: true\n  forceSaveOnWatchdog: true\n  maxEntityCollision: 8\n  saveBukkitWorldDimensionId: true\nfakePlayer:\n  permissions:\n  - essentials.build\n  eventPass: false\nvanilla:\n  fixPlayBossSoundToOtherWorld: true\n  fixLessCrystalRespawnDragon: false\n  preventPistonPushRail: false\n  preventPistonPushSlimeBlock: false\n  limitFastClickGUI: false\nplugin:\n  patcher:\n    enableDynmapCompatible: true\n    enableCoreProtectModBlockCompatible: true\n    enableEssentialsNewVersionCompatible: true\n    enableMythicMobsPatcherCompatible: true\n    enableWorldEditCompatible: true\n    enableCitizensCompatible: true\n  disableHopperMoveEventWorlds: []\n  defaultInstall:\n    spark: true\nasync:\n  waitForgeServerChatEvent: false\nsecurity:\n  opManager: false\n  gameModeManager: false\ndisableUpdateGameProfile: false\ndisableFMLHandshake: false\ndisableFMLStatusModInfo: false\ndisableAsyncCatchWarn: false\nversionCheck: true\n```\n\n- spigot.yml\n\n```yaml\nconfig-version: 11\nsettings:\n  debug: false\n  attribute:\n    maxHealth:\n      max: 2048.0\n    movementSpeed:\n      max: 2048.0\n    attackDamage:\n      max: 2048.0\n  netty-threads: 4\n  timeout-time: 60\n  restart-on-crash: true\n  restart-script: ./start.sh\n  moved-too-quickly-multiplier: 10.0\n  moved-wrongly-threshold: 0.0625\n  filter-creative-items: true\n  bungeecord: false\n  sample-count: 12\n  late-bind: false\n  int-cache-limit: 1024\n  item-dirty-ticks: 20\n  user-cache-size: 1000\n  player-shuffle: 0\n  save-user-cache-on-stop-only: false\nmessages:\n  whitelist: You are not whitelisted on this server!\n  unknown-command: Unknown command. Type \"/help\" for help.\n  server-full: The server is full!\n  outdated-client: Outdated client! Please use {0}\n  outdated-server: Outdated server! I'm still on {0}\n  restart: Server is restarting\nstats:\n  disable-saving: false\n  forced-stats: {}\ncommands:\n  log: true\n  replace-commands:\n  - setblock\n  - summon\n  - testforblock\n  - tellraw\n  spam-exclusions:\n  - /skill\n  silent-commandblock-console: false\n  tab-complete: 0\nadvancements:\n  disable-saving: false\n  disabled:\n  - minecraft:story/disabled\nworld-settings:\n  default:\n    verbose: true\n    merge-radius:\n      item: 2.5\n      exp: 3.0\n    arrow-despawn-rate: 1200\n    wither-spawn-sound-radius: 0\n    nerf-spawner-mobs: false\n    entity-tracking-range:\n      players: 48\n      animals: 48\n      monsters: 48\n      misc: 32\n      other: 64\n    view-distance: 10\n    enable-zombie-pigmen-portal-spawns: true\n    zombie-aggressive-towards-villager: true\n    item-despawn-rate: 6000\n    hanging-tick-frequency: 100\n    growth:\n      cactus-modifier: 100\n      cane-modifier: 100\n      melon-modifier: 100\n      mushroom-modifier: 100\n      pumpkin-modifier: 100\n      sapling-modifier: 100\n      wheat-modifier: 100\n      netherwart-modifier: 100\n      vine-modifier: 100\n      cocoa-modifier: 100\n    entity-activation-range:\n      animals: 32\n      monsters: 28\n      misc: 16\n      tick-inactive-villagers: true\n    random-light-updates: false\n    ticks-per:\n      hopper-transfer: 8\n      hopper-check: 1\n    hopper-amount: 1\n    save-structure-info: true\n    hunger:\n      jump-walk-exhaustion: 0.05\n      jump-sprint-exhaustion: 0.2\n      combat-exhaustion: 0.1\n      regen-exhaustion: 6.0\n      swim-multiplier: 0.01\n      sprint-multiplier: 0.1\n      other-multiplier: 0.0\n    max-tick-time:\n      tile: 50\n      entity: 50\n    squid-spawn-range:\n      min: 45.0\n    max-tnt-per-tick: 100\n    mob-spawn-range: 4\n    dragon-death-sound-radius: 0\n    seed-village: 10387312\n    seed-feature: 14357617\n    seed-monument: 10387313\n    seed-slime: 987234911\n```\n\n#### 在服务端安装模组和插件\n\n在服务端中，有mods和plugins两个文件夹，它们分别是游戏模组和服务端插件。\n\n游戏模组是增强和丰富游戏内容的，而服务端插件是增强服务端功能的。\n\n需要安装的模组，都放在mods文件夹内。\n\n在安装模组时，要看清模组是否需要在服务端安装，不需要在服务端安装的模组不要安装在服务端。（如waila高亮显示等模组）\n\n![](./mc-host-server_3.webp)_服务端需要装\n\n![](./mc-host-server_4.webp)_不要在服务端装\n\n另外在安装模组时，还要留心查看该模组的说明，有些模组需要额外的前置模组，要一起安装（如植物魔法botania需要bauble作为前置模组，二者必须都安装）\n以下是我在服务端安装的模组\n\n![](./mc-host-server_5.webp)\n\n而服务端插件直接放如plugins文件夹即可，可以根据需要去搜索。我曾经安装了[miraimc](https://github.com/DreamVoid/MiraiMC)插件，它是一个能双向同步mc服务器和qq群消息的插件，但由于性能和兼容性问题又把它移除了。目前我只安装了一个luckperm插件，用来管理玩家权限（如单独给玩家tp权限而不给op管理员身份）\n\n#### 设定op、添加白名单\n\n服务端启动完成后，直接在服务端控制台窗口可运行指令（包括游戏内的指令，如 time set）\n\n执行`op <玩家名>`可赋予玩家op\n\n执行`whitelist add <玩家名>`可为玩家添加白名单\n\n注意在控制台窗口输入命令时，都不带`/`\n\n### 配置客户端、制作整合包\n\n客户端即是玩家端，可以选择任意一款启动器，制作整合包发给发给玩家，而我选择的是HMCL这个老牌启动器，版本为3.5.3\n\n下载游戏本体\n![](./mc-host-server_6.webp)\n\n然后把所安装的模组放入游戏目录的mods文件夹\n\n可以使用[litteskin](https://littleskin.cn)，为游戏增加自定义皮肤支持，同时还需要安装customskinloader 模组。\n\n然后启动游戏，在多人游戏中添加搭建的服务器，退出即可。\n\n之后在hmcl中，选择导出整合包，导出时，勾选多人服务列表一起导出。为了以后更新方便，我还构建了服务器自动更新整合包，在hmcl启动器中和mcbbs上均有相关教程。\n参考\n[Nginx 下配置 HMCL 自动更新整合包](https://lo-li.cc/2021/03/11/Nginx%E4%B8%8B%E9%85%8D%E7%BD%AEHMCL%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0%E6%95%B4%E5%90%88%E5%8C%85)\n\n由于构建步骤相对繁琐，我也会另写一篇文章记录。\n\n把制作好的整合包发给玩家后，若使用的是云主机，就可以直接开始联机游戏了。但我用的是自己的主机，其他非内网玩家是无法访问我的服务器的，所以还需要进行端口映射和ddns配置（或内网穿透）\n\n### 使外部网络可访问服务器\n\n我的路由器支持花生壳的ddns，所以我采用了端口映射+ddns的方法。\n\n在路由器管理页面，进行如下配置映射端口（默认端口为25565，可在服务端配置文件server.properties中更改）\n\n![](./mc-host-server_7.webp)\n\n然后登陆花生壳ddns账号，这样外部网络便可以访问局域网中的mc服务器了。\n\n若路由器没有内置任何ddns的支持，还可以在服务器的主机上使用[ddns-go](https://github.com/jeessy2/ddns-go)程序。\n"},{"title":"在vscode里直接粘贴图片——pasteimage","tags":["vscode","博客","安利"],"categories":"小技术","author":"Krau","excerpt":"\n## 前言\n\n使用vscode写博客，要想便捷快速地在文章中插入图片，比较常见的一个做法是通过picgo+图床实现快捷键上传图片，并生成markdown格式的链接。图床常常是利用jsdelivr加速github仓库的方式搭建。\n\n我原本也一直是这样做的，但自从jsdelivr在国内不可用之后，（再者，jsdelivr的使用规范也不允许作为图床使用）我换用了另一种方案，即通过vs的pasteimage插件直接把图片粘贴在文章内，并保存在博客目录内。\n\n","link":"/posts/pasteimage-in-vs/index","content":"\n## 前言\n\n使用vscode写博客，要想便捷快速地在文章中插入图片，比较常见的一个做法是通过picgo+图床实现快捷键上传图片，并生成markdown格式的链接。图床常常是利用jsdelivr加速github仓库的方式搭建。\n\n我原本也一直是这样做的，但自从jsdelivr在国内不可用之后，（再者，jsdelivr的使用规范也不允许作为图床使用）我换用了另一种方案，即通过vs的pasteimage插件直接把图片粘贴在文章内，并保存在博客目录内。\n\n<!-- more -->\n\n## 效果展示\n\n为了突出这个插件的好用，特把效果展示提到使用教程前。\n\n首先，截张图，或者复制一张图片\n\n![](./pasteimage-in-vs_2022-07-07-09-31-48.webp)\n\n然后在vscode内，使用快捷键ctrl+alt+v（可自定义）粘贴这张图片\n\n![](./pasteimage-in-vs_2022-07-07-09-32-56.webp)\n\n这样就完成了，粘贴到文章内的图片会保存在你设置的目录下，粘贴图片实际上是粘贴的图片路径。图片文件以{文章标题_时间}的格式命名，十分有条理。\n\nvscode内的实际效果↓↓↓\n\n![](./pasteimage-in-vs_2022-07-07-09-35-12.webp)\n\n图片文件名↓↓↓\n\n![](./pasteimage-in-vs_2022-07-07-09-37-18.webp)\n\n## 使用\n\n假设你的博客的根目录文件夹名是`hexo-blog-raw`，你想把粘贴的图片以`文章标题_时间.png`的格式命名，并保存在`hexo-blog-raw/source/photo`目录下\n\n### 教程\n\n首先，在vscode的扩展商店中，搜索 paste image并安装\n\n![](./pasteimage-in-vs_2022-07-07-09-38-09.webp)\n\n然后，在博客根目录下，新建.vscode文件夹，用于存放vscode的工作区配置（即局部设置）\n\n在.vscode文件夹内，新建settings.json文件，并写入以下内容并保存。\n\n```json\n{\n    \"pasteImage.namePrefix\": \"${currentFileNameWithoutExt}_\",\n    \"pasteImage.path\": \"${projectRoot}/source/photo\",\n    \"pasteImage.basePath\": \"${projectRoot}/source\",\n    \"pasteImage.forceUnixStyleSeparator\": true,\n    \"pasteImage.prefix\": \"../\"\n}\n```\n\n![](./pasteimage-in-vs_2022-07-07-09-48-46.webp)\n\n这样就完成了。\n\n按照如上配置后，所有配置是只在hexo-blog-raw工作区生效的，即只有在用vscode写博客文章时，以上配置才生效。\n\n使用时，用vscode打开博客文章，用快捷键ctrl+alt+v即可插入图片到文章内。\n\n更多的自定义配置，可参考[pasteimage官方文档](https://marketplace.visualstudio.com/items?itemName=mushan.vscode-paste-image)\n"},{"title":"使用ShareX和Markdown Image自动压缩截图为WebP格式并一键插入Markdown文档","tags":[],"categories":["小技术"],"author":"Krau","excerpt":"\n之前我曾安利过 [PasteImage](http://localhost:4859/posts/pasteimage-in-vs) 这个插件，用 VSCode 写博客/文档的时候，用它可以很快捷地在md文档中插入图片。\n\n受某个友人影响，我也开始尝试 ~~拥抱 webp~~了，近期的文章内的图片都已经压缩成了 webp 格式。但是 PasteImage 却不支持 webp 格式，于是我又想办法整出了今天这个解决方案，实现完全自动化的 压缩+插入图片。\n\n","link":"/posts/use-sharex-and-mdimage-for-efficiency/index","content":"\n之前我曾安利过 [PasteImage](http://localhost:4859/posts/pasteimage-in-vs) 这个插件，用 VSCode 写博客/文档的时候，用它可以很快捷地在md文档中插入图片。\n\n受某个友人影响，我也开始尝试 ~~拥抱 webp~~了，近期的文章内的图片都已经压缩成了 webp 格式。但是 PasteImage 却不支持 webp 格式，于是我又想办法整出了今天这个解决方案，实现完全自动化的 压缩+插入图片。\n\n<!-- more -->\n\n## 配置 ShareX\n\n[sharex](https://getsharex.com/) 是一个强大的截屏、录屏、分享软件，开源免费，支持高度自定义的自动化，\n\n然后还要安装 [ffmpeg](https://ffmpeg.org/) ，它在本文的作用是通过命令调用来压缩图片。如果你没了解过它的话不妨去搜索一下，也是一个十分强大的工具。\n\n然后在 sharex 的动作设置中，添加一个动作\n\n![图 2](./use-sharex-and-mdimage-for-efficiency_01-16-19-19-40.webp)\n\n- 名称: 随意\n- 文件路径: ffmpeg 的安装路径，要指定到 ffmpeg 可执行文件\n- 参数: `-i \"$input\" -q 75 \"$output\"`  其中 -q 75 是以75%质量压缩\n- 输出文件扩展名: webp\n- 扩展名筛选: png\n\n勾上下面的 隐藏窗口 和 删除输入文件\n\n![图 3](./use-sharex-and-mdimage-for-efficiency_01-16-19-24-22.webp)\n然后在截图后的任务里选中这些项(添加图像特效可视情况自行添加)\n\n![图 4](./use-sharex-and-mdimage-for-efficiency_01-16-19-26-14.webp)\n\n## 配置 Markdown Image\n\n[Markdown Image](https://marketplace.visualstudio.com/items?itemName=hancel.markdown-image) 是一个 VSCode 插件，支持将剪贴板中的图片保存在指定路径下(或指定图床中)，并自动生成 markdown 格式的引用。\n\n我的博客的文章图片是按照 `/public/photo/post-pics/文章名/文章名_时间` 的格式和路径保存在本地的，所以按照下面这样配置\n\n```json\n\"markdown-image.base.fileNameFormat\": \"${mdname}/${mdname}_${MM}-${DD}-${HH}-${mm}-${ss}\",\n\"markdown-image.local.path\": \"../../public/photo/post-pics/\",\n\"markdown-image.local.referencePath\": \"/photo/post-pics/${mdname}/\",\n```\n\n更详细的配置，参照 [Markdown Image 的官方文档](https://github.com/imlinhanchao/vsc-markdown-image/blob/HEAD/README.zh-cn.md)\n\n这样就完成啦。现在使用 sharex 截屏时会自动调用 ffmpeg 将文件压缩为 webp 格式并保存在剪贴板中，然后在 VSCode 中使用 `Alt + Shift + V` 粘贴即可。\n"},{"title":"【如何加入一个zerotier网络","tags":["网络","zerotier"],"categories":"小技术","author":"Krau","excerpt":"\n最近把自家宽带从联通转战移动，然而移动不给公网ipv4，导致我mc服的铸币玩家们无法连接服务器，于是决定用zerotier 组建网络，一举多得.\n\n此文只介绍如何加入一个zerotier网络。\n\n","link":"/posts/zerotier-client/index","content":"\n最近把自家宽带从联通转战移动，然而移动不给公网ipv4，导致我mc服的铸币玩家们无法连接服务器，于是决定用zerotier 组建网络，一举多得.\n\n此文只介绍如何加入一个zerotier网络。\n\n<!-- more -->\n\n打开[官网的下载页面](https://www.zerotier.com/download/)\n\n点击windows即可下载\n\n![4](./zerotier-client_2022-08-21-09-59-02.webp)\n\n下载完后双击运行，自动完成安装\n\n安装完成后，点击状态栏图标，点击join new network\n\n![5](./zerotier-client_2022-08-21-10-01-09.webp)\n\n然后填入要加入的网络id，点击join即可\n"}]
